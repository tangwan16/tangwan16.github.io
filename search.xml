<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习 卷积神经网络CNN</title>
      <link href="/2024/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2024/06/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>深度学习</strong>是一种实现机器学习的技术，源于人工神经网络的研究，模型结构是一种含多个隐藏层的神经网络。<br><strong>卷积神经网络</strong>(CNN)是一类包含<strong>卷积算法且具有深度结构的前馈神经网络</strong>，深度学习代表算法之一。卷积神经网络仿造生物的视觉机制构建，能够进行平移不变分类。</p><p>现实场景中，需要更大的输入图像以及更深的网络结构<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233425.png" alt="image.png"><br>输入图像大小为 1024x1024，第一层隐层神经元个数为 1000<br>第一层权重数量级为 10^9，过多的参数会导致过拟合<br> <strong>卷积神经网络可以有效减少权重数量 </strong></p><h4 id="全连接前馈神经网络"><a href="#全连接前馈神经网络" class="headerlink" title="全连接前馈神经网络"></a>全连接前馈神经网络</h4><p>权重矩阵的参数非常多<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233427.png" alt="image.png"><br>局部不变性特征<br>自然图像中的物体都具有局部不变性特征，比如尺度缩放、平移、旋转等操作不影响其语义<br>全连接前馈网络很难提取这些局部不变特征 </p><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>用卷积层代替全连接层<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233428.png" alt="image.png"></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233429.png" alt="image.png"></p><p>卷积神经网络类似于<strong>生物学上局部感受野</strong><br>卷积神经网络的<strong>两个重要特征：局部连接、权重共享</strong><br>可有效<strong>减少权重参数</strong>，<strong>避免过拟合</strong>，为<strong>增加卷积层数</strong>提供可能。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>向量，矩阵，张量<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233430.png" alt="image.png"></p><h3 id="基本操作单元-卷积层"><a href="#基本操作单元-卷积层" class="headerlink" title="基本操作单元:卷积层"></a>基本操作单元:卷积层</h3><h4 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h4><p>$y(n)=\sum_{i=-\infty}^{\infty}x(i)h\left(n-i\right)=x(n)\times h(n)$</p><h4 id="二维卷积"><a href="#二维卷积" class="headerlink" title="二维卷积"></a>二维卷积</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233431.png" alt="image.png"><br>图像处理中，图像以二维矩阵的形式输入到神经网络中，需要二维卷积<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233432.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233433.png" alt="image.png"></p><h4 id="卷积核-或称滤波器，filter-kernel"><a href="#卷积核-或称滤波器，filter-kernel" class="headerlink" title="卷积核(或称滤波器，filter/kernel)"></a>卷积核(或称滤波器，filter/kernel)</h4><p>看成一个特征提取器<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233434.png" alt="image.png"></p><h4 id="特征映射"><a href="#特征映射" class="headerlink" title="特征映射"></a>特征映射</h4><p>图像经过卷积后得到的特征<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233436.png" alt="image.png"></p><h4 id="卷积层如何检测特征"><a href="#卷积层如何检测特征" class="headerlink" title="卷积层如何检测特征"></a>卷积层如何检测特征</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233437.png" alt="image.png"></p><h4 id="多输入特征图-单输出特征图-卷积运算"><a href="#多输入特征图-单输出特征图-卷积运算" class="headerlink" title="多输入特征图 单输出特征图 卷积运算"></a>多输入特征图 单输出特征图 卷积运算</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233438.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233439.png" alt="image.png"><br>多通道卷积<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233440.png" alt="image.png"><br>多卷积核<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233441.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233442.png" alt="image.png"></p><h4 id="典型的卷积层为3维结构"><a href="#典型的卷积层为3维结构" class="headerlink" title="典型的卷积层为3维结构"></a>典型的卷积层为3维结构</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233443.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233444.png" alt="image.png"></p><h3 id="基本操作单元-激活层"><a href="#基本操作单元-激活层" class="headerlink" title="基本操作单元:激活层"></a>基本操作单元:激活层</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233445.png" alt="image.png"><br>激活函数<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233446.png" alt="image.png"></p><h3 id="基本操作单元：池化层-降采样层"><a href="#基本操作单元：池化层-降采样层" class="headerlink" title="基本操作单元：池化层/降采样层"></a>基本操作单元：池化层/降采样层</h3><h4 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233447.png" alt="image.png"></p><h4 id="最大池化层与平均池化层"><a href="#最大池化层与平均池化层" class="headerlink" title="最大池化层与平均池化层"></a>最大池化层与平均池化层</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233448.png" alt="image.png"></p><h3 id="基本操作单元-正则化"><a href="#基本操作单元-正则化" class="headerlink" title="基本操作单元:正则化"></a>基本操作单元:正则化</h3><p>批归一化 Batch Normalization<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233449.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233450.png" alt="image.png"><br>数据扩增/增强<br><strong>减少过拟合的最简单方法就是增加训练样本</strong></p><p>图像增强方法<br>旋转<br>翻转<br>放缩<br>平移<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233451.png" alt="image.png"></p><p><a href="https://blog.csdn.net/weixin_42475060/article/details/128862411">DropOut</a><br>减少神经元之间复杂的共适应关系。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233452.png" alt="image.png"></p><p><a href="https://blog.csdn.net/qq_45652492/article/details/123379156">微调 fune-tuning</a><br>用训练好的参数(从已训练好的模型中获取)初始化自己的网络，然后用自己的数据接着训练。</p><h2 id="卷积网络结构"><a href="#卷积网络结构" class="headerlink" title="卷积网络结构"></a>卷积网络结构</h2><p>卷积网络是由卷积层、汇聚层、全连接层交叉堆叠而成<br>趋向于小卷积、大深度<br>趋向于全卷积<br>典型结构<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233453.png" alt="image.png"><br>一个卷积块为连续的M个卷积层和b个汇聚层(M通常设置为2-5，b为0或1)。一个卷积网络中可以堆叠N个连续的卷积块，然后在接着K个全连接层(N的取值区间比较大，比如1-100)或者更大；k一般为0-2<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233454.png" alt="image.png"></p><h3 id="深度特征学习"><a href="#深度特征学习" class="headerlink" title="深度特征学习"></a>深度特征学习</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233455.png" alt="image.png"></p><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233456.png" alt="image.png"></p><h3 id="表示学习"><a href="#表示学习" class="headerlink" title="表示学习"></a>表示学习</h3><p>CNN以图像的原始像素作为输入，基于输出层定义的损失函数使用反向传播算法端到端(End-to-end)学习，从而自动学习得到图像底层到高层的层次化语义表达<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233458.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233459.png" alt="image.png"><br>浅层学习局部特征，深度学习整体特征<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233460.png" alt="image.png"><br>深层网络选择“深”而非“广”的网络结构<br>深层网络可从局部到整体”理解图像”<br>学习复杂特征时(例如人脸识别)，浅层的卷积层感受野小，学习到局部特征，深层的卷积层感受野大，学习到整体特征<br>深度网络可减少权重数量<br>以宽度换深度，用多个小卷积替代一个大卷积，在获得更多样特征的同时所需权重数量也更少。</p><h2 id="典型的CNN"><a href="#典型的CNN" class="headerlink" title="典型的CNN"></a>典型的CNN</h2><h3 id="CNN模型结构变迁"><a href="#CNN模型结构变迁" class="headerlink" title="CNN模型结构变迁"></a>CNN模型结构变迁</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233461.png" alt="image.png"></p><h3 id="LeNet-5"><a href="#LeNet-5" class="headerlink" title="LeNet-5"></a>LeNet-5</h3><p>基于 LeNet-5 的手写数字识别系统在 90 年代被美国很多银行使用，用来识别支票上面的手写数字<br>LeNet-5共有7层<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233462.png" alt="image.png"></p><h3 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h3><p>2012 ILSVRC winner<br>第一个现代深度卷积网络模型，首次使用了很多现代深度卷积网络的一些技术方法<br>使用GPU进行并行训练，采用了ReLU作为非线性激活函数，使用Dropout防止过拟合，使用数据增强。<br>5个卷积层、3个汇聚层和3个全连接层<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233463.png" alt="image.png"></p><h3 id="Inception网络"><a href="#Inception网络" class="headerlink" title="Inception网络"></a>Inception网络</h3><p>2014 ILSVRC winner(22层)<br>参数：GoogLeNet：4M VS AlexNet：60M<br>Inception网络是由有多个inception模块和少量的汇聚层堆叠而成 </p><p>Inception模块v1<br><strong>在Inception网络中，一个卷积层包含多个不同大小的卷积操作，称为Inception模块。 </strong></p><p>Inception模块同时使用1 × 1、3 × 3、5 × 5等不同大小的卷积核，并将得到的特征映射在深度上拼接（堆叠）起来作为输出特征映射。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233464.png" alt="image.png"><br>Inception模块v3<br><strong>用多层的小卷积核来替换大的卷积核，以减少计算量和参数量</strong><br>使用两层3x3的卷积来替换v1中的5x5的卷积<br>使用连续的nx1和1xn来替换nxn的卷积<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233465.png" alt="image.png"></p><h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p>2015 ILSVRC winner（152）<br>残差网络（Residual Network，ResNet）是通过<strong>给非线性的卷积层增加直连边</strong>的方式来提高信息的传播效率 </p><h3 id="DenseNet"><a href="#DenseNet" class="headerlink" title="DenseNet"></a>DenseNet</h3><h3 id="常用CNN"><a href="#常用CNN" class="headerlink" title="常用CNN"></a>常用CNN</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233466.png" alt="image.png"></p><h3 id="神经网络结构搜索"><a href="#神经网络结构搜索" class="headerlink" title="神经网络结构搜索"></a>神经网络结构搜索</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233467.png" alt="image.png"></p><h2 id="CNN可视化"><a href="#CNN可视化" class="headerlink" title="CNN可视化"></a>CNN可视化</h2><p>CNN解释器：<a href="https://poloclub.github.io/cnn-explainer/">https://poloclub.github.io/cnn-explainer/</a><br>GitHub：<a href="https://github.com/poloclub/cnn-explainer">https://github.com/poloclub/cnn-explainer</a><br>论文：CNN explainer: learning convolutional neural networks with interactive visualization </p><h2 id="相关应用"><a href="#相关应用" class="headerlink" title="相关应用"></a>相关应用</h2><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233468.png" alt="image.png"><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233469.png" alt="image.png"></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406112233470.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 卷积神经网络CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 神经网络简介</title>
      <link href="/2024/06/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/06/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="神经网络的发展历史"><a href="#神经网络的发展历史" class="headerlink" title="神经网络的发展历史"></a>神经网络的发展历史</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059559.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059560.png" alt=""><br>生成神经元结构与人工神经元模型<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059561.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059562.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102104703.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059563.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059564.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059565.png" alt=""></p><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>连续可导(允许少数点上不可导)<br>函数简单<br>值域有限(在合适的区间)<br>单调递增</p><h4 id="常见的激活函数"><a href="#常见的激活函数" class="headerlink" title="常见的激活函数"></a>常见的激活函数</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059566.png" alt=""></p><h5 id="Sigmoid与tanh"><a href="#Sigmoid与tanh" class="headerlink" title="Sigmoid与tanh"></a>Sigmoid与tanh</h5><p>$\begin{aligned}<br>\sigma(x)&amp; =\frac{1}{1+\exp(-x)}  \\<br>\operatorname{tanh}(x)&amp; =\frac{\exp(x)-\exp(-x)}{\exp(x)+\exp(-x)}<br>\end{aligned}$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059567.png" alt=""></p><h6 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h6><p>饱和函数,(当x趋于无穷时,导数趋于0)<br>tanh是零中心化的,sigmoid函数输出恒大于0</p><h6 id="偏置偏移"><a href="#偏置偏移" class="headerlink" title="偏置偏移"></a>偏置偏移</h6><p>非零中心化的输出会使得其后一层的神经元的输入发生偏移量,并进一步链接<a href="https://blog.csdn.net/weixin_45850972/article/details/124654632">使得梯度下降的收敛速度变慢</a></p><h6 id="Sigmoid函数的优缺点"><a href="#Sigmoid函数的优缺点" class="headerlink" title="Sigmoid函数的优缺点"></a>Sigmoid函数的优缺点</h6><p>优点<br>函数处处连续，便于求导<br>可将函数值的范围压缩至[0,1]，可用于压缩数据，且幅度不变<br> 便于前向传输 </p><p>缺点<br>在趋向无穷的地方，函数值变化很小，容易出现梯度消失，不利于深层神经的反馈传输<br>幂函数的梯度计算复杂<br>收敛速度比较慢<br>输出不是以0为中心对称的 </p><h5 id="ReLU系列"><a href="#ReLU系列" class="headerlink" title="ReLU系列"></a>ReLU系列</h5><script type="math/tex; mode=display">\begin{aligned}\operatorname{ReLU}(x)&=\begin{cases}x&x\geq0\\[2ex]0&x<0\end{cases}\\&=\max(0,x).\end{aligned}</script><script type="math/tex; mode=display">\text{LeakyReLU}(x)=\begin{cases}x&\text{if}\:x>0\\[2ex]\gamma x&\text{if}\:x\leq0\end{cases}\\=\max(0,x)+\gamma\min(0,x)</script><p>$f^{\prime}(x)=I(x&gt;0)$死亡ReLU问题(Dying ReLU Problem )<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059568.png" alt=""><br>计算上更加高效<br>生物上的解释性<br>单侧抑制,宽兴奋边界<br>在一定程度上缓解梯度消失问题</p><h5 id="Swish函数"><a href="#Swish函数" class="headerlink" title="Swish函数"></a>Swish函数</h5><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059569.png" alt=""></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059570.png" alt=""></p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>人工神经网络主要由大量的神经元以及他们之间的有向连接构成</p><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h4><p>神经元的激活规则<br>主要是指神经元输入到输出之间的映射关系，一般为非线性函数<br>网络的拓扑结构<br>不同神经元的连接关系<br>学习算法<br>通过训练数据来学习神经网络的参数<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059571.png" alt=""></p><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><p> 参数过多，影响训练<br> 非凸优化问题：即存在局部最优而非全局最优解，影响迭代<br> 梯度消失问题，下层参数比较难调<br> 参数解释起来比较困难 </p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p> 计算资源要大<br> 数据要多<br> 算法效率要好：即收敛快 </p><h4 id="非凸优化问题"><a href="#非凸优化问题" class="headerlink" title="非凸优化问题"></a>非凸优化问题</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059572.png" alt=""></p><h4 id="梯度消失问题"><a href="#梯度消失问题" class="headerlink" title="梯度消失问题"></a>梯度消失问题</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059573.png" alt=""></p><h2 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h2><h3 id="感知器的起源"><a href="#感知器的起源" class="headerlink" title="感知器的起源"></a>感知器的起源</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059574.png" alt=""></p><h3 id="感知器的模型架构"><a href="#感知器的模型架构" class="headerlink" title="感知器的模型架构"></a>感知器的模型架构</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059575.png" alt=""><br>输入输出对：$(X_{k},y_{k}),k=1,2,…,N$ X训练数据，y +1或-1<br>学习目标：确定权重向量W和常数b，使</p><script type="math/tex; mode=display">y_k=\begin{cases}+1,&\mathcal{W}^TX_k+b>0\\-1,&\mathcal{W}^TX_k+b<0\end{cases}</script><h3 id="感知器的学习算法"><a href="#感知器的学习算法" class="headerlink" title="感知器的学习算法"></a>感知器的学习算法</h3><p>一种<strong>错误驱动</strong>的<strong>在线学习</strong>算法<br>1 初始化一个权重向量w&lt;-0（通常是全零向量 ）和常数b<br>2每次分错一个样本 $(x_k,y_k)$时，即<br>$y_k(\mathcal{W}^TX_k+b)&lt;0$<br>用这个样本更新参数<br> $\begin{array}{c}W\leftarrow W+y_kX_k\\b\leftarrow b+y_k\end{array}$<br>3 继续步骤2;<br>4 终止条件：所有训练样本均不满足步骤2, 退出循环 </p><h4 id="感知器的损失函数"><a href="#感知器的损失函数" class="headerlink" title="感知器的损失函数"></a>感知器的损失函数</h4><p>$\mathcal{L}(W;X_{k},y_{k})=\max(0,-y_{k}(W^{T}X_{k}+b))$</p><h4 id="参数的更新过程"><a href="#参数的更新过程" class="headerlink" title="参数的更新过程"></a>参数的更新过程</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059576.png" alt=""></p><h4 id="参数的更新规则"><a href="#参数的更新规则" class="headerlink" title="参数的更新规则"></a>参数的更新规则</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059577.png" alt=""></p><p>如果训练数据线性可分，感知器算法就一定可以停下来。</p><h3 id="感知器的收敛性"><a href="#感知器的收敛性" class="headerlink" title="感知器的收敛性"></a>感知器的收敛性</h3><p>单层感知机只能处理线性问题，无法处理非线性问题<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059578.png" alt=""></p><h3 id="感知器的局限性"><a href="#感知器的局限性" class="headerlink" title="感知器的局限性"></a>感知器的局限性</h3><p>Marvin Minsky and Papert（1969）：<br>感知器的特征层是固定的，并且是通过人工处理过的。这与真正的智能的机器的定义相违背。<br> 它的<strong>单层结构限制</strong>了它能够学习到的函数，例如<strong>异或函数</strong>就已经超出了它的学习能力。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059579.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059580.png" alt=""></p><h2 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h2><p>基本概念<br><strong>前馈神经网络(全连接神经网络，多层感知器)</strong><br>各神经元分别属于不同的<strong>层</strong>，层内无连接<br>相邻两层之间的神经元全部<strong>两两连接</strong><br>整个网络中<strong>无反馈</strong>，信号从输入层向输出层<strong>单向传播</strong>，可用一个有向无环图表示。<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059581.png" alt=""></p><p>前馈神经网络信息传播公司<br>$\mathbf{z}^{(l)}=W^{(l)}\cdot\mathbf{a}^{(l-1)}+\mathbf{b}^{(l)}\\\mathbf{a}^{(l)}=f_{l}(\mathbf{z}^{(l)})$<br>前馈计算<br>$\mathbf{x}=\mathbf{a}^{(0)}\to\mathbf{z}^{(1)}\to\mathbf{a}^{(1)}\to\mathbf{z}^{(2)}\to\cdots\to\mathbf{a}^{(L-1)}\to\mathbf{z}^{(L)}\to\mathbf{a}^{(L)}=f(\mathbf{x};W,\mathbf{b})$</p><h3 id="深层前馈神经网络"><a href="#深层前馈神经网络" class="headerlink" title="深层前馈神经网络"></a>深层前馈神经网络</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059582.png" alt=""></p><h3 id="通用近似定理"><a href="#通用近似定理" class="headerlink" title="通用近似定理"></a>通用近似定理</h3><p>根据通用近似定理，对于具有线性输出层和至少一个使用”挤压”性质的激活函数的隐藏层组成的前馈神经网路，只要其隐藏层神经元的数量足够，它可以以任意的精度来近似任何从一个定义在实数空间中的有界闭集函数。</p><h3 id="应用到机器学习"><a href="#应用到机器学习" class="headerlink" title="应用到机器学习"></a>应用到机器学习</h3><p>神经网络可以作为一个“万能”函数来使用，可以用来进行复杂的特征转换，或逼近一个复杂的条件分布<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059583.png" alt=""><br>对于多分类问题<br>如果使用softmax回归分类器，相当于网络最后一层设置C个神经元，其输出经过softmax函数进行归一化后可以作为每个类的条件概率。<br> $\hat{\mathbf{y}}=\mathrm{softmax}(\mathbf{z}^{(L)})$<br>采用交叉熵损失函数，对于样本(x,y)，其损失函数为<br>$\mathcal{L}(\mathbf{y},\hat{\mathbf{y}})=-\mathbf{y}^\mathrm{T}\log\hat{\mathbf{y}}$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059584.png" alt=""></p><h3 id="参数学习"><a href="#参数学习" class="headerlink" title="参数学习"></a>参数学习</h3><p>给定训练集为D，将每个样本输入给前馈神经网络，得到网络输出。<br>其在数据集D上的结构化风险函数为：<br>$\mathcal{R}(W,\mathbf{b})=\frac{1}{N}\sum_{n=1}^{N}\mathcal{L}(\mathbf{y}^{(n)},\mathbf{\hat{y}}^{(n)})+\frac{1}{2}\lambda|W|_{F}^{2}$<br>$W^{(l)}\leftarrow W^{(l)}-\alpha\frac{\partial\mathcal{R}(W,\mathbf{b})}{\partial W^{(l)}}\\\mathbf{b}^{(l)}\leftarrow\mathbf{b}^{(l)}-\alpha\frac{\partial\mathcal{R}(W,\mathbf{b})}{\partial\mathbf{b}^{(l)}}$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059585.png" alt=""><br>梯度下降<br>初始化网络参数w<br>重复<br>计算梯度：$\partial L/\partial w$<br>更新参数：$:w\leftarrow w-\lambda\cdot\partial L/\partial w$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059586.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059587.png" alt=""></p><h4 id="如何计算梯度"><a href="#如何计算梯度" class="headerlink" title="如何计算梯度"></a>如何计算梯度</h4><p>链式法则<br>$y=f^5(f^4(f^3(f^2(f^1(x)))))\to\frac{\partial y}{\partial x}=\frac{\partial f^1}{\partial x}\frac{\partial f^2}{\partial f^1}\frac{\partial f^3}{\partial f^2}\frac{\partial f^4}{\partial f^3}\frac{\partial f^5}{\partial f^4}$</p><script type="math/tex; mode=display">(1)\text{若 }x\in\mathbb{R},\boldsymbol{u}=u(x)\in\mathbb{R}^s,\boldsymbol{g}=g(\boldsymbol{u})\in\mathbb{R}^t,\text{则}\\\frac{\partial\boldsymbol{g}}{\partial x}=\frac{\partial\boldsymbol{u}}{\partial x}\frac{\partial\boldsymbol{g}}{\partial\boldsymbol{u}}\quad\in\mathbb{R}^{1\times t}.\\(2)\text{若 }x\in\mathbb{R}^p,\boldsymbol{y}=g(\boldsymbol{x})\in\mathbb{R}^s,\boldsymbol{z}=f(\boldsymbol{y})\in\mathbb{R}^t,\text{则}\\\frac{\partial\boldsymbol{z}}{\partial\boldsymbol{x}}=\frac{\partial\boldsymbol{y}}{\partial\boldsymbol{x}}\frac{\partial\boldsymbol{z}}{\partial\boldsymbol{y}}\quad\in\mathbb{R}^{p\times t}.\\(3)\text{若 }X\in\mathbb{R}^{p\times q}\text{ 为矩阵},\boldsymbol{y}=g(X)\in\mathbb{R}^\ast,z=f(\boldsymbol{y})\in\mathbb{R},\text{则}\\\frac{\partial z}{\partial X_{ij}}=\frac{\partial\boldsymbol{y}}{\partial X_{ij}}\frac{\partial z}{\partial y}\quad\in\mathbb{R}.</script><p>反向传播(BP)算法<br>自动微分(AD)<br>$\frac{\partial\mathcal{L}(\mathbf{y},\hat{\mathbf{y}})}{\partial W_{ij}^{(l)}}=\left(\frac{\partial\mathbf{z}^{(l)}}{\partial W_{ij}^{(l)}}\right)^\mathrm{T}\frac{\partial\mathcal{L}(\mathbf{y},\hat{\mathbf{y}})}{\partial\mathbf{z}^{(l)}},\\\frac{\partial\mathcal{L}(\mathbf{y},\hat{\mathbf{y}})}{\partial\mathbf{b}^{(l)}}=\left(\frac{\partial\mathbf{z}^{(l)}}{\partial\mathbf{b}^{(l)}}\right)^\mathrm{T}\frac{\partial\mathcal{L}(\mathbf{y},\hat{\mathbf{y}})}{\partial\mathbf{z}^{(l)}}.$<br>矩阵微积分<br>多元微积分的一种表达方式，即使用矩阵和向量来表示因变量每个成分关于自变量每个成分的偏导数<br>标量关于向量的偏导数<br>$\frac{\partial y}{\partial x}=[\frac{\partial y}{\partial x_1},\cdots,\frac{\partial y}{\partial x_p}]^\mathrm{T}$<br> 向量关于向量的偏导数<br>$\frac{\partial f(x)}{\partial x}=\left.\left[\begin{array}{ccc}\frac{\partial y_1}{\partial x_1}&amp;\cdots&amp;\frac{\partial y_q}{\partial x_1}\\\vdots&amp;\vdots&amp;\vdots\\\\\frac{\partial y_1}{\partial x_p}&amp;\cdots&amp;\frac{\partial y_q}{\partial x_p}\end{array}\right.\right]\in\mathbb{R}^{p\times q}$</p><h2 id="BP算法"><a href="#BP算法" class="headerlink" title="BP算法"></a>BP算法</h2><h3 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059588.png" alt=""></p><h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><p>1 对样本明确预测输出值与损失函数<br>2 明确参数调整策略<br>3 计算输出层阈值的梯度<br>4 计算隐层到输出层连接权值的梯度<br>5  计算隐层阈值的梯度<br>6 计算输入层到隐层连接权值的梯度<br>7 引出归纳结论 </p><h4 id="明确预测输出值与损失函数"><a href="#明确预测输出值与损失函数" class="headerlink" title="明确预测输出值与损失函数"></a>明确预测输出值与损失函数</h4><p>对样本$(x_k,y_k)$,神经网络的预测输出值为$\hat{y_k}$<br>全网络在样本$(x_k,y_k)$上的均方误差$E_{k}=\frac{1}{2}\sum_{j=1}^{l}\left(\hat{y}_{j}^{k}-y_{j}^{k}\right)^{2}$</p><h4 id="明确参数调整策略"><a href="#明确参数调整策略" class="headerlink" title="明确参数调整策略"></a>明确参数调整策略</h4><p>基于梯度下降策略，以目标的负梯度方向对参数进行调整<br>$v=v+\Delta v \\<br>\Delta v=-\rho\frac{\partial E_{n}}{\partial v}$</p><h4 id="计算输出层阈值-theta-j-的梯度-frac-partial-E-k-partial-theta-i"><a href="#计算输出层阈值-theta-j-的梯度-frac-partial-E-k-partial-theta-i" class="headerlink" title="计算输出层阈值$\theta_j$的梯度$\frac{\partial E_k}{\partial\theta_i}$"></a>计算输出层阈值$\theta_j$的梯度$\frac{\partial E_k}{\partial\theta_i}$</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059589.png" alt=""></p><h4 id="计算隐层到输出层连接权值-W-hj-的梯度-frac-partial-E-k-partial-w-hj"><a href="#计算隐层到输出层连接权值-W-hj-的梯度-frac-partial-E-k-partial-w-hj" class="headerlink" title="计算隐层到输出层连接权值$W_{hj}$的梯度$\frac{\partial E_k}{\partial w_{hj}}$"></a>计算隐层到输出层连接权值$W_{hj}$的梯度$\frac{\partial E_k}{\partial w_{hj}}$</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059590.png" alt=""></p><h4 id="计算隐层阈值-gamma-h-的梯度-frac-partial-E-k-partial-gamma-h"><a href="#计算隐层阈值-gamma-h-的梯度-frac-partial-E-k-partial-gamma-h" class="headerlink" title="计算隐层阈值$\gamma_h$的梯度$\frac{\partial E_k}{\partial\gamma_h}$"></a>计算隐层阈值$\gamma_h$的梯度$\frac{\partial E_k}{\partial\gamma_h}$</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059591.png" alt=""></p><h4 id="计算输入层到隐层连接权值-v-ih-的梯度-frac-partial-E-k-partial-v-ih"><a href="#计算输入层到隐层连接权值-v-ih-的梯度-frac-partial-E-k-partial-v-ih" class="headerlink" title="计算输入层到隐层连接权值$v_{ih}$的梯度$\frac{\partial E_k}{\partial v_{ih}}$"></a>计算输入层到隐层连接权值$v_{ih}$的梯度$\frac{\partial E_k}{\partial v_{ih}}$</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059592.png" alt=""></p><h4 id="引出归纳结论"><a href="#引出归纳结论" class="headerlink" title="引出归纳结论"></a>引出归纳结论</h4><p>隐层阈值梯度取决于隐层神经元输出、输出层阈值梯度与输出层的连接权值<br><strong>BP算法的精髓。在阈值调整过程中，当前的阈值梯度取决于下一层的阈值。</strong><br><strong>当前层的连接权值梯度，取决于当前神经元阈值梯度和上层神经元输出</strong>。</p><p>只要知道<strong>上一层神经元的阈值梯度</strong>，即可<strong>计算当前层神经元阈值梯度和连接权值梯度</strong>。随后可以计<strong>算输出层神经元阈值梯度</strong>，从而计算出<strong>全网络的神经元阈值和连接权值梯度</strong>。最终达到训练网络的目的。 </p><h4 id="算法流程回顾"><a href="#算法流程回顾" class="headerlink" title="算法流程回顾"></a>算法流程回顾</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102059593.png" alt=""></p><h3 id="BP算法的优缺点"><a href="#BP算法的优缺点" class="headerlink" title="BP算法的优缺点"></a>BP算法的优缺点</h3><p>优点<br>能够<strong>自适应、自主学习</strong>。BP可以根据预设参数更新规则，通过不断调整神经网络中的参数，已达到最符合期望的输出<br> 拥有很强的<strong>非线性映射能力</strong><br>误差的反向传播采用的是成熟的链式法则，<strong>推导过程严谨且科学</strong><br>算法<strong>泛化能力很强 </strong></p><p>缺点<br>BP神经网络<strong>参数众多</strong>，每次迭代需要更新较多数量的阈值和权值，故<strong>收敛速度较慢 </strong><br>网络中隐层含有的<strong>节点数目没有明确准则</strong>，需要不断设置节点数字试凑，根据网络误差结果最终确定隐层节点个数<br>BP算法是一种速度较快的梯度下降算法，<strong>容易陷入局部极小值</strong>的问题 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 神经网络简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 聚类和降维</title>
      <link href="/2024/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E8%81%9A%E7%B1%BB%E5%92%8C%E9%99%8D%E7%BB%B4/"/>
      <url>/2024/06/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-%E8%81%9A%E7%B1%BB%E5%92%8C%E9%99%8D%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="无监督学习概述"><a href="#无监督学习概述" class="headerlink" title="无监督学习概述"></a>无监督学习概述</h2><h3 id="监督学习和无监督学习的区别"><a href="#监督学习和无监督学习的区别" class="headerlink" title="监督学习和无监督学习的区别"></a>监督学习和无监督学习的区别</h3><p>监督学习：<strong>训练集有标签y</strong>，目标是找到能够区分正样本和负样本的决策边界，需要据此拟合一个假设函数<br>无监督学习：<strong>训练集没有标签y</strong>，主要分为聚类、降维、关联规则、推荐系统等方面</p><h3 id="主要的无监督学习方法"><a href="#主要的无监督学习方法" class="headerlink" title="主要的无监督学习方法"></a>主要的无监督学习方法</h3><p>聚类<br>如何将教室里的学生按爱好、身高划分为5类？<br> 降维<br>如何将将原高维空间中的数据点映射到低维度的空间中<br>关联规则<br>     很多买尿布的男顾客，同时买了啤酒，可以从中找出什么规律来提高超市销售额？<br>推荐系统<br>     很多客户经常上网购物，根据他们的浏览商品的习惯，给他们推荐什么商品呢？</p><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>主要算法<br>K-means、密度聚类、层次聚类</p><h2 id="K-means聚类"><a href="#K-means聚类" class="headerlink" title="K-means聚类"></a>K-means聚类</h2><h3 id="聚类的背景知识"><a href="#聚类的背景知识" class="headerlink" title="聚类的背景知识"></a>聚类的背景知识</h3><p>基本思想<br>图中的数据可以分成三个分开的点集(称为簇)，一个能够分出这些点集的算法，被称为聚类算法<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036570.png" alt=""></p><h3 id="K-means算法概述"><a href="#K-means算法概述" class="headerlink" title="K-means算法概述"></a>K-means算法概述</h3><p>K-means是无监督学习方法，最普及的聚类算法，将没有标签的数据聚类成不同的组<br>K-means算法是一个迭代过程。<br>数据集被分组为若干个预定义的不重叠的聚类或子组，使簇内部点尽可能相似，簇在不同的空间。<br>将数据点分配给簇，以便<strong>簇的质心和数据点之间的平方距离之和最小</strong>，在这个位置，簇的质心是簇中数据点的算术平均值。</p><p>距离度量<br>闵可夫斯基距离<br>$d(x,y)=\left(\sum_i|x_i-y_i|^p\right)^{\frac{1}{p}}$<br>p=1为曼哈顿距离<br>p=2为欧式距离<br>p取无穷时极限情况下，得到切比雪夫距离</p><h3 id="K-means算法流程"><a href="#K-means算法流程" class="headerlink" title="K-means算法流程"></a>K-means算法流程</h3><p>1 选择K个点作为初始质心(K小于训练数据点的数目)。<br>2 将每个点指派到最近的质心，形成K个簇。（计算数据点与质心的距离）<br>3 对于上一步聚类的结果，进行平均计算，得出该类的新的聚类中心。（移动质心）<br>4 重复上述两步/直到迭代结束：质心不发生变化。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036571.png" alt=""></p><p>K-means的代价函数(Distortion function 畸变函数)：</p><script type="math/tex; mode=display">J(c^{(1)},\ldots,c^{(m)},\mu_{1},\ldots,\mu_{K})=\frac{1}{m}\sum_{i=1}^{m}\left\|X^{(i)}-\mu_{c^{(i)}}\right\|^{2} \\\text{其中}\mu_{c^{(i)}}\text{代表与}x^{(i)}\text{最近的聚类中心点。}</script><p>$\{x^{(1)},x^{(2)},x^{(3)},…,x^{(m)}\}$为训练集<br>$C=\{C_{1},C_{2},\cdots,C_{K}\}$簇划分<br>$\mu_{1},\mu_{2},\ldots,\mu_{K}$聚类中心</p><p>K-means优化过程<br>每个簇的样本数目为N1，N2….Nk<br>$J(\mu_{1},\mu_{2},\cdots\mu_{k})=\frac{1}{2}\sum_{j=1}^{K}\sum_{i=1}^{N_{j}}(x_{i}-\mu_{j})^{2}$<br>$\frac{\partial J}{\partial\mu_{j}}=-\sum_{i=1}^{N_{j}}(x_{i}-\mu_{j})\stackrel{\text{令}}{\rightarrow}0\Rightarrow\mu_{j}=\frac{1}{N_{j}}\sum_{i=1}^{N_{j}}x_{i}$<br>注意：该K-means可以根据簇在第一步中的初始化方式给出<strong>不同的结果。</strong></p><h3 id="K值的选择"><a href="#K值的选择" class="headerlink" title="K值的选择"></a>K值的选择</h3><p>找到簇的数量，通过”肘部法则”进行计算<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036572.png" alt=""><br>K-means的一个问题：<br>它有可能停留在一个局部极小值处，而这取决于初始化的情况。<br>为了解决这个问题，需要<strong>多次运行K-menas算法</strong>，每一次都重新进行随机初始化，最后再比较多次运行K-均值的结果，<strong>选择代价函数最小的结果</strong></p><h3 id="K-means的优缺点"><a href="#K-means的优缺点" class="headerlink" title="K-means的优缺点"></a><strong>K-means的优缺点</strong></h3><p>优点<br>原理比较简单，容易实现，收敛速度快<br>聚类效果较优<br>算法的可解释度比较强<br>主要需要调参的参数仅仅是簇数K</p><p>缺点<br>需要预先指定<strong>簇的数量</strong><br>如果有两个<strong>高度重叠</strong>的数据，那么它就不能被区分，也不能判断有两个簇<br> 无法处理分类变量：K均值算法是<strong>基于数值的</strong>，因此无法直接处理分类变量<br>有时<strong>随机选择质心</strong>并不能带来理想的结果<br> 无法处理<strong>异常值和噪声数据</strong>；<br> 不适用于非线性数据集；<br> 对特征尺度敏感；<br> 如果遇到<strong>非常大的数据集</strong>，那么计算机可能会崩溃。 </p><h2 id="密度聚类与层次聚类"><a href="#密度聚类与层次聚类" class="headerlink" title="密度聚类与层次聚类"></a>密度聚类与层次聚类</h2><h3 id="密度聚类-DBSCAN"><a href="#密度聚类-DBSCAN" class="headerlink" title="密度聚类-DBSCAN"></a>密度聚类-DBSCAN</h3><h4 id="DBSCAN概述"><a href="#DBSCAN概述" class="headerlink" title="DBSCAN概述"></a>DBSCAN概述</h4><p>如果S中任两点的连线内的点都在集合S中，那么集合S称为凸集，否则为非凸集<br>DBSCAN(Density-Based  Spatial Clustering of Applications with Noise)基于密度的聚类算法。<br><strong>密度：</strong>空间中任意一点的密度是以该点为圆心，以<strong>扫描半径</strong>构成的圆区域内包含的点数目<br>DBSCAN将簇定义为密度相连的点的最大集合，能够把具<strong>有足够高密度的区域划分为簇</strong>，并可<strong>在噪声的空间数据库中发现任意形状的聚类</strong></p><h4 id="DBSCAN使用两个超参数"><a href="#DBSCAN使用两个超参数" class="headerlink" title="DBSCAN使用两个超参数"></a>DBSCAN使用<strong>两个超参数</strong></h4><p>扫描半径(eps)和最小包含点数(minPts)来获得簇的数量，而不是猜测簇的数目。<br>扫描半径(eps):<br>用于定位点/检查任何点附近密度的距离度量，即扫描半径<br> 最小包含点数(minPts):<br>聚集在一起的最小点数（阈值），该区域被认为是稠密的。 </p><h4 id="DBSCAN的三类数据点"><a href="#DBSCAN的三类数据点" class="headerlink" title="DBSCAN的三类数据点"></a>DBSCAN的三类数据点</h4><p>核心点：在半径Eps内包含超过MinPts数目的点<br>边界点：在半径Eps内点的数量小于MinPts，但是落在核心点的邻域内的点。<br>噪声点：既不是核心点也不是边界点的点。<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036573.png" alt=""></p><h4 id="DBSCAN密度聚类的算法流程"><a href="#DBSCAN密度聚类的算法流程" class="headerlink" title="DBSCAN密度聚类的算法流程"></a>DBSCAN密度聚类的算法流程</h4><p>1.将所有点标记为核心点、边界点或噪声点；<br>2 如果选择的点是<strong>核心点</strong>，则<strong>找出所有从该点出发的密度可达对象形成簇；</strong></p><ol><li>如果该点是<strong>非核心点</strong>，将其<strong>指派到一个与之关联的核心点的簇中；</strong> </li><li>重复以上步骤，直到所点都被处理过 </li></ol><p>对每个点计算其邻域Eps=3内点的集合。<br>集合内点的个数超过MinPts=3的点为核心点。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036576.png" alt=""></p><h4 id="DBSCAN的超参数"><a href="#DBSCAN的超参数" class="headerlink" title="DBSCAN的超参数"></a>DBSCAN的超参数</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036577.png" alt=""></p><h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><p>层次聚类假设簇之间存在<strong>层次结构</strong>，将样本聚到层次化的簇中<br>层次聚类又有<strong>聚合聚类(自下而上)、分裂聚类(自上而下)</strong>两种方法<br>每一个样本只属于一个簇，层次聚类属于<strong>硬聚类</strong><br>背景知识：如果一个聚类方法假定一个样本只能属于一个簇，或簇的交集为空集，那么该方法称为<strong>硬聚类方法</strong>。如果一个样本可以属于多个簇，或簇的交集不为空集，那么该方法称为<strong>软聚类</strong>方法。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036578.png" alt=""></p><h4 id="聚合聚类"><a href="#聚合聚类" class="headerlink" title="聚合聚类"></a>聚合聚类</h4><p>开始将每个样本<strong>各自分到一个簇；</strong><br>之后将<strong>相距最近的两簇合并</strong>，建立一个新的簇；<br>重复操作直到满足停止条件；<br>得到层次化的类别。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102039042.png" alt=""></p><h4 id="分裂聚类"><a href="#分裂聚类" class="headerlink" title="分裂聚类"></a>分裂聚类</h4><p>开始将所有样本分到一个簇<br>之后将已有类中<strong>相距最远的样本分到两个新的簇</strong><br>重复此操作直到满足停止条件；<br>得到层次化的类别。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036580.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036581.png" alt=""></p><h2 id="聚类的评价指标"><a href="#聚类的评价指标" class="headerlink" title="聚类的评价指标"></a>聚类的评价指标</h2><h4 id="均一性"><a href="#均一性" class="headerlink" title="均一性"></a>均一性</h4><p>每个聚簇中正确分类的样本数占该聚簇总样本数的比例和，类似于精确率，一个簇中只包含一个类别的样本，则满足均一性。<br>$p=\frac{1}{k}\sum_{i=1}^{k}\frac{N(C_{i}==K_{i}))}{N(K_{i})}$</p><h4 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h4><p>每个聚簇中正确分类的样本数占该类型的总样本数比例的和，类似于召回率，同类别样本被归类到相同簇中，则满足完整性<br>$r=\frac{1}{k}\sum_{i=1}^{k}\frac{N(C_{i}==K_{i})\big)}{N(C_{i})}$</p><h4 id="V-measure"><a href="#V-measure" class="headerlink" title="V-measure"></a>V-measure</h4><p>均一性和完整性的加权平均<br>$V=\frac{(1+\beta^2)\times pr}{\beta^2\times p+r}$</p><h4 id="轮廓系数"><a href="#轮廓系数" class="headerlink" title="轮廓系数"></a>轮廓系数</h4><p>簇内不相似度a(i)<br>计算样本i到同簇其他样本的平均距离为a(i)，应尽可能小。<br>簇间不相似度b(i)<br>计算样本i到其他簇Cj的所有样本的平均距离b(ij)，应尽可能大。<br>轮廓系数s(i)<br>$s(i)=\frac{b(i)-a(i)}{max\{a(i),b(i)\}}$<br>越接近1表示样本i聚类越合理。<br>越接近-1，表示样本i应该分类到另外的簇中。<br>近似为0，表示样本i应该在边界上;<br>聚类结果的轮廓系数：所有样本的s(i)的均值<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036582.png" alt=""><br>调整兰德系数(ARI,Adjusted Rnd Index)<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036583.png" alt=""></p><h2 id="降维概述"><a href="#降维概述" class="headerlink" title="降维概述"></a>降维概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="维数灾难"><a href="#维数灾难" class="headerlink" title="维数灾难"></a>维数灾难</h4><p>指在涉及到向量的计算的问题中，随着维数的增加，计算量指数倍增长的现象。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036584.png" alt=""><br>维度太大也会导致机器学习性能的下降，并不是特征维度越大越好，模型的性能会随着特征的增加先上升后下降。</p><h4 id="什么是降维"><a href="#什么是降维" class="headerlink" title="什么是降维"></a>什么是降维</h4><p>降维是将训练数据中的样本(实例)<strong>从高维空间转化到低维空间</strong>，<strong>不存在完全无损的降维。</strong><br>降维是通过对原始数据的线性变换实现的</p><h4 id="为什么要降维"><a href="#为什么要降维" class="headerlink" title="为什么要降维"></a>为什么要降维</h4><p>高维数据增加了运算的难度。<br>高维使得学习算法的泛化能力变弱(例如，在最近邻分类器中，样本复杂度随着维度成指数增长)，维度越高，算法的搜索难度和成本就越大。<br>降维能够增加数据的可读性，利于发掘数据的有意义的结构。</p><h4 id="降维的主要作用"><a href="#降维的主要作用" class="headerlink" title="降维的主要作用"></a>降维的主要作用</h4><p>减少冗余特征，降低数据维度<br>数据可视化</p><p>减少冗余特征</p><p>x1：厘米表示的身高，x2：英寸表示的身高<br>表示的内容相同，可以减少数据到一维。</p><p>很多数据具有<strong>线性关系</strong>，<strong>具有线性关系的特征很多都是冗余特征</strong>，去掉冗余特征对机器学习的计算结果不会有影响</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><h4 id="t-SNE-t-distributed-Stochatstic-Neighbor-Embedding"><a href="#t-SNE-t-distributed-Stochatstic-Neighbor-Embedding" class="headerlink" title="t-SNE(t-distributed Stochatstic Neighbor Embedding)"></a>t-SNE(t-distributed Stochatstic Neighbor Embedding)</h4><p>t-SNE将数据点之间的相似度转化为概率。原始空间中的相似度由高斯联合概率表示，嵌入空间的相似度由”学生t分布”表示<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036585.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036586.png" alt=""><br>t-SNE适合准确的可视化样本间的相似度关系，<strong>t-SNE主要关注数据的内部结构</strong></p><h4 id="拥挤现象"><a href="#拥挤现象" class="headerlink" title="拥挤现象"></a>拥挤现象</h4><p>用PCA降维会进行可视化，会出现所谓的“拥挤现象”<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036587.png" alt=""></p><h4 id="t-SNE算法缺点"><a href="#t-SNE算法缺点" class="headerlink" title="t-SNE算法缺点"></a>t-SNE算法缺点</h4><h5 id="只能可视化，不用于数据转换"><a href="#只能可视化，不用于数据转换" class="headerlink" title="只能可视化，不用于数据转换"></a>只能可视化，不用于数据转换</h5><p>t-SNE只能由高维数据集产生低维数据集，这种关系式多对多的。<br>额外添加一个数据，t-SNE不能像PCA那样给出新数据在低维空间下的坐标。</p><h5 id="过于高维一般不直接使用"><a href="#过于高维一般不直接使用" class="headerlink" title="过于高维一般不直接使用"></a>过于高维一般不直接使用</h5><p>t-SNE算法中，当数据维数过高时，计算量很大。所以一般来说，会先用PCA降维到10维左右，再使用t-SNE降维到2或3维空间进行可视化。</p><h3 id="降维的优缺点"><a href="#降维的优缺点" class="headerlink" title="降维的优缺点"></a>降维的优缺点</h3><p>降维的优点<br>数据集存储所需的<strong>空间</strong>也相应减少，减少了特征维数所需的计算训练<strong>时间</strong>；<br>助于快速<strong>可视化数据</strong>；<br>通过处理多重共线性<strong>消除冗余特征</strong></p><p>降维的缺点<br>降维可能会丢失一些数据<br>在主成分分析(PCA)降维技术中，有时需要考虑多少主成分是难以确定的，往往使用经验法则。 </p><h2 id="SVD-奇异值分解"><a href="#SVD-奇异值分解" class="headerlink" title="SVD(奇异值分解)"></a>SVD(奇异值分解)</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="SVD概述"><a href="#SVD概述" class="headerlink" title="SVD概述"></a>SVD概述</h4><p>奇异值分解(SVD)，可用于降维算法中的特征分解 ，用于推免系统，自然语言处理<br>SVD将一个矩阵A分解为三个矩阵的乘积：<br>一个正交矩阵U<br>一个对角矩阵E<br>一个正交矩阵V的转置</p><p>定义矩阵A的SVD为<br>$A=U\Sigma V^\mathrm{T}$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036588.png" alt=""></p><p>$A=U\Sigma V^\mathrm{T}=u_1\sigma_1v_1^\mathrm{T}+\cdots+u_r\sigma_rv_r^\mathrm{T}$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036589.png" alt=""></p><h4 id="SVD求解"><a href="#SVD求解" class="headerlink" title="SVD求解"></a>SVD求解</h4><h5 id="U-矩阵求解"><a href="#U-矩阵求解" class="headerlink" title="$U$矩阵求解"></a>$U$矩阵求解</h5><p>方阵$(AA^\mathrm{T})$为$m\times m$的一个方阵，进行特征分解，得到的特征值和特征向量满足下式<br>$AA^\mathrm{T}u_i=\lambda_iu_i$<br>得到矩阵$(AA^\mathrm{T})$的m个特征值和对应的m个特征向量u了。<br>将$AA^\mathrm{T}$的所有特征向量组成一个$m\times m$的矩阵𝑈，就是我们 𝑆𝑉𝐷 公式里面的𝑈矩阵了<br>U中每个特征向量叫做A的<strong>左奇异向量</strong></p><script type="math/tex; mode=display">AA^{\mathrm{T}}=(U\Sigma V^{\mathrm{T}})(U\Sigma V^{\mathrm{T}})^{\mathrm{T}}=U(\Sigma\Sigma^{\mathrm{T}})U^{\mathrm{T}}\\V^{\mathrm{T}}V=I,\Sigma^{\mathrm{T}}=\Sigma.</script><h5 id="V-矩阵求解"><a href="#V-矩阵求解" class="headerlink" title="$V$矩阵求解"></a>$V$矩阵求解</h5><p>方阵$(A^\mathrm{T}A)$为$n\times n$的一个方阵，进行特征分解，得到的特征值和特征向量满足下式<br>$A^\mathrm{T}Av_i=\lambda_iv_i$<br>得到矩阵$(A^\mathrm{T}A)$的n个特征值和对应的n个特征向量v了。<br>将$A^\mathrm{T}A$的所有特征向量组成一个 n×n的矩阵V，就是我们 SVD公式里面的V矩阵了<br> V中每个特征向量叫做A的<strong>右奇异向量</strong></p><script type="math/tex; mode=display">A^{\mathrm{T}}A=(U\Sigma V^{\mathrm{T}})^{\mathrm{T}}(U\Sigma V^{\mathrm{T}})=V(\Sigma^{\mathrm{T}}\Sigma)V^{\mathrm{T}} \\U^{T}U=I,\Sigma^{T}=\Sigma</script><h5 id="Sigma-矩阵求解"><a href="#Sigma-矩阵求解" class="headerlink" title="$\Sigma$矩阵求解"></a>$\Sigma$矩阵求解</h5><p>特征值矩阵等于奇异值矩阵的平方。<br>$\sigma_i=\sqrt{\lambda_i}$<br>可以不用$\sigma_i=\frac{Av_i}{u_i}$来计算奇异值，可以通过求$AA^\mathrm{T}$的特征值取平方根来求奇异值。</p><p>$A=U\Sigma V^{\mathrm{T}}$则$AV=U\Sigma V^{\mathrm{T}}V$<br>由于$V^{\mathrm{T}}V=I$，$AV=U\Sigma$<br>得到$Av_{i}= \sigma_{i}u_{i}$,$\sigma _{i}= Av_{i}/ u_{i}$</p><h4 id="SVD计算案例"><a href="#SVD计算案例" class="headerlink" title="SVD计算案例"></a>SVD计算案例</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036590.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036591.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036592.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036593.png" alt=""></p><h4 id="SVD的近似描述"><a href="#SVD的近似描述" class="headerlink" title="SVD的近似描述"></a>SVD的近似描述</h4><p>SVD分解可以将一个矩阵进行分解，对角矩阵对角线上的特征值递减存放，<br> 且奇异值的减少特别的快，在很多情况下，前 10%甚至 1%的奇异值的和就占了全部的奇异值之和的 99%以上的比例。<br> 对于奇异值，它跟我们特征分解中的特征值类似，<strong>可以用最大的K个的奇异值和对应的左右奇异向量来近似描述矩阵。 </strong></p><p> $A_{m\times n}=U_{m\times m}\Sigma_{m\times n}V_{n\times n}^{\mathrm{T}}\approx U_{m\times k}\Sigma_{k\times k}V_{k\times n}^{\mathrm{T}}$<br>其中K要比n小很多，也就是一个大的矩阵A可以用三个小的矩阵$U_{m\times k},\Sigma_{k\times k},V_{k\times n}$来表示。<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036594.png" alt=""></p><h3 id="SVD案例"><a href="#SVD案例" class="headerlink" title="SVD案例"></a>SVD案例</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036595.png" alt=""></p><h2 id="PCA-主成分分析"><a href="#PCA-主成分分析" class="headerlink" title="PCA(主成分分析)"></a>PCA(主成分分析)</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>主成分分析(PCA)是一种降维方法，将一个大的特征集转换成一个较小的特征集，这个特征集<strong>仍然包含了原始数据中的大部分信息</strong>，从而降低了原始数据的维数。<br> 减少一个数据集的特征数量自然是以牺牲准确性为代价的，但降维的诀窍是用一点准确性换取简单性。</p><p>主成分分析流程图<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036597.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036598.png" alt=""></p><p>PCA的思想很简单——减少数据集的特征数量，同时尽可能地保留信息。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036599.png" alt=""></p><p>如何得到这些包含最大差异性的主成分方向<br>计算数据矩阵的协方差矩阵<br>计算协方差矩阵的特征值和特征向量<br>选择特征值最大(即方差最大)的K个特征所对应的特征向量组成的矩阵<br>将数据矩阵转换到新的空间中，实现数据特征的降维。</p><h3 id="PCA的两种实现方法"><a href="#PCA的两种实现方法" class="headerlink" title="PCA的两种实现方法"></a>PCA的两种实现方法</h3><p>基于SVD分解协方差矩阵实现PCA算法<br>基于特征值分解协方差矩阵PCA算法</p><h4 id="基于SVD分解协方差矩阵实现PCA算法"><a href="#基于SVD分解协方差矩阵实现PCA算法" class="headerlink" title="基于SVD分解协方差矩阵实现PCA算法"></a>基于SVD分解协方差矩阵实现PCA算法</h4><p>PCA 减少n维到k维<br> 设有m条n维数据，将原始数据按列组成n行m列矩阵X</p><p>第一步 均值归一化<br> 算出所有特征的均值，然后令 $x_{j}=x_{j}-\mu_{j}$$\mu_{j}$是均值<br>如果特征是在不同的数量级上，我们还需要将其除以标准差$\sigma^{2}$<br>第二步 计算协方差矩阵<br>$\Sigma=\frac{1}{m}\sum_{i=1}^{n}\bigl(x^{(i)}\bigr)\bigl(x^{(i)}\bigr)^{\mathrm{T}}$<br>第三步 计算协方差矩阵$\Sigma$的特征矩阵,利用奇异值分解SVD来分解<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036600.png" alt=""></p><h4 id="基于特征值分解协方差矩阵实现PCA算法"><a href="#基于特征值分解协方差矩阵实现PCA算法" class="headerlink" title="基于特征值分解协方差矩阵实现PCA算法"></a>基于特征值分解协方差矩阵实现PCA算法</h4><p>特征值分解矩阵<br>对于矩阵A ，有一组特征向量v ，将这组向量进行正交化单位化，就能得到一组正交单位向量。特征值分解，就是将矩阵𝐴分解为如下式：<br> $A=P\Sigma P^{-1}$<br>其中,P是矩阵A的特征向量组成的矩阵,$\Sigma$是一个对角阵,对角线上的元素就是特征值.<br>对于正交矩阵P,<br>${P}^{-1}=P^{\mathrm{T}}$</p><p>PCA 减少n维到k维<br> 设有m条n维数据，将原始数据按列组成n行m列矩阵X<br>第一步 均值归一化<br> 算出所有特征的均值，然后令 $x_{j}=x_{j}-\mu_{j}$$\mu_{j}$是均值<br>如果特征是在不同的数量级上，我们还需要将其除以标准差$\sigma^{2}$<br>第二步 计算协方差矩阵<br>$\Sigma=\frac{1}{m}\sum_{i=1}^{n}\bigl(x^{(i)}\bigr)\bigl(x^{(i)}\bigr)^{\mathrm{T}}$<br>第三步 用特征值分解方法计算协方差矩阵$\Sigma$的特征值和特征向量<br>第四步 对特征值从大到小排序，选择其中最大的K个。然后将其对应的K个特征向量分别作为行向量组成特征向量矩阵P<br>第五步 将数据转换到K个特征向量构建的新空间中，即$Y=PX$</p><h3 id="PCA的算法案例"><a href="#PCA的算法案例" class="headerlink" title="PCA的算法案例"></a>PCA的算法案例</h3><script type="math/tex; mode=display">X=\begin{pmatrix}-1&&-1&&0&&2&&0\\-2&&0&&0&&1&&1\\\end{pmatrix}</script><p>用PCA的方法将这组二维数据降到一维<br>第一步 均值归一化<br>这个矩阵的每行已经是零均值.<br>第二步 求协方差矩阵</p><script type="math/tex; mode=display">\Sigma=\frac{1}{5}\begin{pmatrix}-1&-1&0&2&0\\-2&0&0&1&1\end{pmatrix}\begin{pmatrix}-1&-2\\-1&0\\0&0\\2&1\\0&1\end{pmatrix}=\begin{pmatrix}\frac{6}{5}&\frac{4}{5}\\\frac{4}{5}&\frac{6}{5}\end{pmatrix}</script><p>第三步 求协方差矩阵的特征值和特征向量</p><script type="math/tex; mode=display">|A-\lambda E|=\begin{vmatrix}\frac{6}{5}-\lambda&\frac{4}{5}\\\frac{4}{5}&\frac{6}{5}-\lambda\end{vmatrix}=(\frac{6}{5}-\lambda)^{2}-\frac{16}{25}=(\lambda-2)(\lambda-2/5)=0</script><script type="math/tex; mode=display">\lambda_{1}=2,\lambda_{2}=2/5</script><script type="math/tex; mode=display">\Sigma_{1}\binom{1}{1},\Sigma_{2}\binom{-1}{1}</script><p>标准化后的特征向量</p><script type="math/tex; mode=display">\begin{pmatrix}1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix},\begin{pmatrix}-1/\sqrt{2}\\1/\sqrt{2}\end{pmatrix}</script><p>矩阵P是  </p><script type="math/tex; mode=display">P=\begin{pmatrix}1/\sqrt{2}&1/\sqrt{2}\\-1/\sqrt{2}&1/\sqrt{2}\end{pmatrix}</script><p>验证协方差矩阵$\Sigma$的对角化</p><script type="math/tex; mode=display">P\Sigma P^\mathrm{T}=\begin{pmatrix}1/\sqrt{2}&1/\sqrt{2}\\-1/\sqrt{2}&1/\sqrt{2}\end{pmatrix}\begin{pmatrix}6/5&4/5\\4/5&6/5\end{pmatrix}\begin{pmatrix}1/\sqrt{2}&-1/\sqrt{2}\\1/\sqrt{2}&1/\sqrt{2}\end{pmatrix}=\begin{pmatrix}2&0\\0&2/5\end{pmatrix}</script><p>用P的第一行乘以数据矩阵,得到降维后的数据表示</p><script type="math/tex; mode=display">Y=(1/\sqrt{2}\quad1/\sqrt{2})\begin{pmatrix}-1&-1&0&2&0\\-2&0&0&1&1\end{pmatrix}=\begin{pmatrix}-3/\sqrt{2}&-1/\sqrt{2}&0&3/\sqrt{2}&-1/\sqrt{2}\end{pmatrix}</script><p>降维后的投影结果图<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102036601.png" alt=""></p><h3 id="PCA的优缺点"><a href="#PCA的优缺点" class="headerlink" title="PCA的优缺点"></a>PCA的优缺点</h3><p>优点<br>1 仅仅需要以方差衡量信息量,不受数据集以外的因素影响<br>2 各主成分之间正交,可消除原始数据成分间的相互影响的因素<br>3 计算方法简单,主要运算时特征值分解,易于实现<br>4 它是无监督学习,完全无参数限制的 </p><p>缺点<br>1 主成分各个特征维度的含义具有一定的模糊性,不如原始样本特征的解释性强<br>2 方差小的非主成分也可能含有对样本差异的重要信息,因降维丢弃可能对后续数据处理有影响 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 聚类 降维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 支持向量机</title>
      <link href="/2024/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <url>/2024/06/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="支持向量机概述"><a href="#支持向量机概述" class="headerlink" title="支持向量机概述"></a>支持向量机概述</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>支持向量机是一类按<strong>监督学习</strong>方式对数据进行<strong>二元分类</strong>的<strong>广义线性分类器</strong><br><strong>决策边界是 对学习样本求解的最大边距超平面</strong><br>与逻辑回归和神经网络相比，支持向量机在学习<strong>复杂的非线性方程</strong>更为强大和更为清晰的方式<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001112.png" alt=""></p><h3 id="硬间隔、软间隔和非线性SVM"><a href="#硬间隔、软间隔和非线性SVM" class="headerlink" title="硬间隔、软间隔和非线性SVM"></a>硬间隔、软间隔和非线性SVM</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001113.png" alt=""><br>硬间隔，完全分类准确，不能存在分类错误的情况。<br><strong>软间隔，允许一定量的样本分类错误</strong> </p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>支持向量</strong>:集合边缘上的若干数据，在代数空间上，可以用向量表示，同时有了这些点的支持，可以找到唯一分离的超平面。<br>找到一个平面(称为决策面)，使支持向量到该平面的距离最大<br><strong>间隔</strong>:两个异类支持向量到超平面的距离之和<br>支持向量机:最大化间隔<br>支持向量机的一个重要性质:训练完成后，大部分的训练样本都不需<br>保留，<strong>最终模型仅与支持向量有关.</strong></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001114.png" alt=""></p><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>任意超平面可以用下面的线性方程来描述<br>$w^{\mathrm{T}}x+b=0$<br>二维空间点(x,y)到直线Ax+By+C=0的距离公式为:<br>$\frac{|Ax+By+C|}{\sqrt{A^2+B^2}}$</p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001115.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001116.png" alt=""></p><script type="math/tex; mode=display">\begin{cases}\frac{w^\mathrm{T}x+b}{\|w\|}\geq d&y=1\\\frac{w^\mathrm{T}x+b}{\|w\|}\leq-d&y=-1\end{cases}</script><p>合并有<br>$y(w^\mathrm{T}x+b)\geq1$</p><h2 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><h3 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h3><p>支持向量机的最终目的是最大化d</p><h3 id="支持向量机求解"><a href="#支持向量机求解" class="headerlink" title="支持向量机求解"></a>支持向量机求解</h3><p>$定义函数间隔: d^\ast=y_i(w^\mathrm{T}x+b)$<br>分类确信度<br>$\text{分类确信度}=\frac{|\omega\cdot x_i+b|}{||\omega||}$<br>意味着离超平面距离越远，分类确信度越高</p><p>分类正确性<br>$\text{分类正确性}=y_i$<br><strong>引入几何间隔来既能确认分类确信度也能判断分类正确性的指标</strong><br>$定义几何间隔:d=\frac{y(w^\mathrm{T}x+b)}{||w||}$当数据被正确分类时，几何间隔就是点到超平面的距离<br>为了求几何间隔最大，SVM基本问题可以转化为求解</p><script type="math/tex; mode=display">\max_{w,b}\frac{d^\ast}{||w||} \quad(subject \quad to)y_i(w^\mathrm{T}x_i+b)\geq d^\ast,i=1,2,\ldots,m</script><h4 id="转化为凸函数"><a href="#转化为凸函数" class="headerlink" title="转化为凸函数"></a>转化为凸函数</h4><p>先令d*=1,方便计算(参考衡量，不影响评价结果)<br>$\max_{w,b}\frac1{||w||}  \quad s.t.y_i(w^\mathrm{T}x_i+b)\geq1,i=1,2,..,m$<br>转化成以下公式，来求取凸函数<br>$\min_{w,b}\frac12||w||^2 \quad s.t.y_i(w^\mathrm{T}x_i+b)\geq1,i=1,2,..,m$</p><h4 id="模型的不可识别性"><a href="#模型的不可识别性" class="headerlink" title="模型的不可识别性"></a>模型的不可识别性</h4><p><strong>求解所得的超平面出现多种表达形式，造成模型的不可识别性</strong><br>$3x^{(1)}+4^{(2)}+1=0$<br>$6x^{(1)}+8^{(2)}+2=0$<br>上面两种超平面都表示同一平面。<br>为了避免这个问题，让模型只有唯一的表达形式，引入归一化的思想，令||w||=1<br>$\frac35x^{(1)}+\frac45x^{(2)}+1=0$</p><script type="math/tex; mode=display">\max_{w,b}\frac{d^\ast}{||w||} \quad(subject \quad to)y_i(w^\mathrm{T}x_i+b)\geq d^\ast,i=1,2,\ldots,m \\||\omega||=1,\text{即 }\omega_1^2+\omega_2^2+\cdots+\omega_n^2=1</script><p>但是计算过程过于复杂<br>令 $d^\ast=y_i(w^\mathrm{T}x+b) =1$，$d^\ast=y_i(w^\mathrm{T}x+b) =B$或者其他数字，转化成=1，例如$\frac{1}{B}y_i(w^\mathrm{T}x+b) =1$<br>平移至$d^\ast=1$的情况，而$d^\ast=1$隐藏在优化问题中，而不是单独列在约束条件里。</p><h4 id="用拉格朗日乘子法和KTT条件求解最优值"><a href="#用拉格朗日乘子法和KTT条件求解最优值" class="headerlink" title="用拉格朗日乘子法和KTT条件求解最优值"></a>用拉格朗日乘子法和KTT条件求解最优值</h4><p>$L(w,b,\alpha)=\frac{1}{2}||w||^{2}+\sum_{i=1}^{m}\alpha_{i}\left(-y_{i}(w^{\mathrm{T}}x_{i}+b)+1\right)\quad\text{其中}\alpha\text{为拉格朗日乘子}$<br>原始问题<br>$\min_{\omega,b}\max_\alpha L(\omega,b,\alpha)$<br>对应的对偶问题<br>$\max_\alpha\min_{\omega,b}L(\omega,b,\alpha)$</p><p>先计算内部极小值问题,将式子只由已知的x，y和唯一未知的变量a有关<br>根据KTT条件</p><script type="math/tex; mode=display">\frac{\partial}{\partial w}L(w,b,\alpha)=w-\sum_{i=1}^{m}\alpha_{i}y_{i}x_{i}=0\\\frac{\partial}{\partial b}L(w,b,\alpha)=0\\\\w=\sum_{i=1}^{m}\alpha_{i}y_{i}x_{i}\\\sum_{i=1}^{m}\alpha_{i}y_{i}=0</script><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001117.png" alt=""></p><p>计算外部极大值问题<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001118.png" alt=""></p><p>例题讲解<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001119.png" alt=""><br>A<br>构造优化问题<br>$\min_\alpha-\theta_D(\alpha)=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_i(x_i\cdot x_j)-\sum_{i=1}^N\alpha_i$<br>$\sum_{i=1}^N\alpha_iy_i=0\quad\alpha_i\geq0,i=1,2,3$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001120.png" alt=""></p><script type="math/tex; mode=display">x_1\text{ 与 }x_2\text{,}2\alpha_1\alpha_2y_1y_2(x_1\cdot x_2)=42\alpha_1\alpha_2\\x_2\text{ 与 }x_3\text{,}2\alpha_2\alpha_3y_2y_3(x_2\cdot x_3)=-14\alpha_2\alpha_3\\x_1\text{ 与 }x_3\text{,}2\alpha_1\alpha_3y_1y_3(x_1\cdot x_3)=-12\alpha_1\alpha_3</script><p>最终优化问题<br>$\min\frac{1}{2}(18\alpha_1^2+25\alpha_2^2+2\alpha_3^2+42\alpha_1\alpha_2-14\alpha_2\alpha_3-12\alpha_1\alpha_3)$<br>$\alpha_1+\alpha_2-\alpha_3=0$<br>$\min4\alpha_1^2+\frac{13}{2}\alpha_2^2+10\alpha_1\alpha_2-2\alpha_1-2\alpha_2=\min S(\alpha_1,\alpha_2)$<br>$\frac{\partial S}{\partial\alpha_1}=8\alpha_1+10\alpha_2-2=0\\\frac{\partial S}{\partial\alpha_2}=13\alpha_2+10\alpha_1-2=0$<br>$\alpha_1=\frac32\\\alpha_2=-1$<br>$\alpha_{1}=\frac{1}{4}\\\alpha_{2}=0\\\alpha_{3}=\frac{1}{4}$</p><p>用$\alpha$计算参数w和b</p><script type="math/tex; mode=display">\omega^{*}=\sum_{i=1}^N\alpha_i^\ast y_ix_i=\frac14(3,3)^T-\frac14(1,1)^T=(\frac12,\frac12)^T\\b^{\ast}=y_{j}-\sum_{i=1}^{N}\omega^{\ast}\cdot x_{j} \\b^\ast=y_1-\sum_{i=1}^N\omega^\ast \cdot x_1=1-(\frac12,\frac12)^T\cdot(3,3)^T=-2</script><p>分离超平面<br>$\omega^\ast\cdot x_j+b^\ast=\frac{1}{2}x^{(1)}+\frac{1}{2}x^{(2)}-2=0$<br>决策函数<br>$f(x)=sign(\frac12x^{(1)}+\frac12x^{(2)}-2)$</p><h2 id="线性不可分支持向量机"><a href="#线性不可分支持向量机" class="headerlink" title="线性不可分支持向量机"></a>线性不可分支持向量机</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001121.png" alt=""><br>对于间隔内的黄色点<br>它对应的距离$y_i(\omega_ix_i+b)&lt;1$<br>添加新的参数，起名为$\xi_i$ </p><script type="math/tex; mode=display">\quad y_i(\omega_ix_i+b)+\xi_i\geq1 \quad\xi_i\in(0,1)</script><p>对于另一方“阵营”的绿色点<br>它的函数间隔明显是小于-1（即函数间隔的绝对值大于1，但是因为错了方向，函数间隔将小于-1）<br>添加新的参数，起名为$\xi_i$ </p><script type="math/tex; mode=display">\quad y_i(\omega_ix_i+b)+\xi_i\geq1 \quad\xi_i>1</script><p>$如果数据线性不可分，则可以引入松弛变量\xi_i&gt;=0,使函数间隔加上松弛变量大于等于1$</p><h3 id="目标函数如下"><a href="#目标函数如下" class="headerlink" title="目标函数如下"></a>目标函数如下</h3><p>$\min_{w,b,\xi}\quad\frac{1}{2}||w||^{2}+C\sum_{i=1}^{m}\xi_{i}\quad s.t.y_{i}(w^{\mathrm{T}}x_{i}+b)\geq1-\xi_{i}$<br><strong>C被称作惩罚系数，决定了原始参数和松弛变量之间的影响权重</strong><br><strong>C越小，对误分类的惩罚力度小，代表正确分类的参数作用更大，容易欠拟合</strong><br><strong>C越大，对误分类的惩罚力度大，代表误分类起到的作用更大，容易过拟合</strong></p><h3 id="生成对偶问题"><a href="#生成对偶问题" class="headerlink" title="生成对偶问题"></a>生成对偶问题</h3><p>约束条件改成：</p><script type="math/tex; mode=display">1-y_i(\omega\cdot x_i+b)-\xi_i\leq0\\-\xi_i\leq0,\quad i=1,2,\cdots,N</script><p>对应有2N个约束条件<br>给出拉格朗日乘子<br>$\alpha=(\alpha_1,\alpha_2,\cdots,\alpha_N),\text{令}\mu=(\mu_1,\mu_2,\cdots,\mu_N)$<br>$L(\omega,b,\xi,\alpha,\mu)=\frac{1}{2}||\omega||^{2}+C\sum_{i=1}^{N}\xi_{i}+\sum_{i=1}^{N}\alpha_{i}(1-y_{i}(\omega\cdot x_{i}+b)-\xi_{i})-\sum_{i=1}^{N}\mu_{i}\xi_{i}$<br>原始问题<br>$\min_{\omega,b,\xi_i}\max_{\alpha,\mu_i} L(\omega,b,\alpha,\mu,\xi)$<br>对偶问题<br>$\max_{\alpha,\mu_i} \min_{\omega,b,\xi_i}L(\omega,b,\alpha,\mu,\xi)$</p><h3 id="求解内部极小化"><a href="#求解内部极小化" class="headerlink" title="求解内部极小化"></a>求解内部极小化</h3><script type="math/tex; mode=display">\frac{\partial L}{\partial\omega}=\omega-\sum_{i=1}^N\alpha_iy_ix_i=0 \\\begin{aligned}&\frac{\partial L}{\partial b}=-\sum_{i=1}^N\alpha_iy_i=0\\&\frac{\partial L}{\partial\xi_i}=C-\alpha_i-\mu_i=0\end{aligned}</script><p>得到的结果如下</p><script type="math/tex; mode=display">\begin{aligned}&\omega=\sum_{i=1}^{N}\alpha_{i}y_{i}x_{i} \\&\sum_{i=1}^N\alpha_iy_i=0 \\&C-\alpha_{i}-\mu_{i}=0,i=1,2,\cdots,N\end{aligned}</script><p>带入拉格朗日函数<br>$L=-\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum_{i=1}^N\alpha_i$</p><h3 id="求解外部极大化"><a href="#求解外部极大化" class="headerlink" title="求解外部极大化"></a>求解外部极大化</h3><p>$\min_{\alpha,\mu}-\Theta_D(\alpha,\mu)=\min\frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^{N}\alpha_i$<br>$\text{对应的 }\mu_i=C-\alpha_i\geq0\text{,得出 }\alpha_i\leq C\text{,并且 }\sum_{i=1}^N\alpha_iy_i=0\text{。}$<br>$\omega^\ast=\sum_{i=1}^N\alpha_i^\ast y_ix_i$</p><p>$b^\ast=y_i-\sum_{i=1}^m\alpha_i^\ast y_i(x_i\cdot x_j)$<br>线性可分支持向量机w唯一，但b不唯一。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>$\xi_i=\max(0,1-y_i(w^\mathrm{T}x_i+b))$<br>hinge损失函数，每一个样本都有一个对应的松弛变量，表征该<strong>样本不满足约束的程度</strong>。<br>蓝色线表示hinge损失函数，黄色线代表0-1损失函数，可以认为它是二类分类问题的真正损失函数，而hinge损失函数是0-1损失函数的上界<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001122.png" alt=""></p><h2 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h2><h3 id="核技巧"><a href="#核技巧" class="headerlink" title="核技巧"></a>核技巧</h3><p><strong>核函数：可以将样本从原始空间映射到一个更高维的特质空间，使得样本在新的空间中线性可分。</strong></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001123.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001124.png" alt=""><br>通过一个非线性转换后的两个样本间的内积。K(x,z)是一个核函数，或正定核，意味着存在一个从输入空间到特征空间的映射，对于任意空间输入的x，z有:<br>$K(x,z)=\phi(x)\cdot\phi(z)$<br>在线性支持向量机学习的对偶问题中，用<strong>核函数K(x,z)替换当中的内积</strong>求解得到的就是非线性支持向量机</p><p>$f(x)=\mathrm{sign}\left(\sum_{i=1}^{N}\alpha_{i}^{\ast}y_{i}K(x,x_{i})+b^{\ast}\right)$</p><h3 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001125.png" alt=""><br>三个常用的核函数中，只有高斯核函数是需要调参的。</p><h3 id="SVM的超参数"><a href="#SVM的超参数" class="headerlink" title="SVM的超参数"></a>SVM的超参数</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001126.png" alt=""></p><h3 id="SVM使用准则"><a href="#SVM使用准则" class="headerlink" title="SVM使用准则"></a>SVM使用准则</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406102001127.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 支持向量机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 KNN</title>
      <link href="/2024/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20KNN/"/>
      <url>/2024/06/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20KNN/</url>
      
        <content type="html"><![CDATA[<h2 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h2><h3 id="KNN解释"><a href="#KNN解释" class="headerlink" title="KNN解释"></a>KNN解释</h3><p> K−近邻法（K-Nearest Neighbor, KNN），用于基本的分类与回归方法<br>图解</p><h3 id="KNN图示说明"><a href="#KNN图示说明" class="headerlink" title="KNN图示说明"></a>KNN图示说明</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948143.png" alt=""><br>x是没有标签的新数据，使用k=5的kNN算法，取出5个与数据x最近的分类标签,<br>其中圆形标签有4 个( 数量多于三角形标签), 因此将数据x归类为与圆形标签相同的类型<br>x1,x2特征属性<br>f(x1,x2)标签，就是在坐标系中位置<br>思考1：<br>为什么选择k=5，可以选择其他值吗<br>思考2：<br>5个“最近”的分类标签，“最近”如何定义，如何取出。<br>思考3：<br>如果三角形和圆形标签数相等如何决策？<br>对于不同最近，权值是否相同。即距离x最近的标签和距离第k近的标签的对于最终的决策是否起相同作用？</p><h3 id="KNN的三要素"><a href="#KNN的三要素" class="headerlink" title="KNN的三要素"></a>KNN的三要素</h3><p>k值选择<br>距离度量<br>决策规则</p><p> K-近邻算法中分类规则一般采用<strong>多数表决</strong>的方式, 即由K个近邻训练数据中多数类决定输入数据所属的类。<br><strong>多数表决规则等价于经验风险最小化规则。  </strong></p><h3 id="KNN算法思路"><a href="#KNN算法思路" class="headerlink" title="KNN算法思路"></a>KNN算法思路</h3><p>对于分类问题： 对新的样本，根据其𝑘个最近邻的训练样本的类别，通过多数表决等方式进行预测。<br>对于回归问题： 对新的样本，根据其𝑘个最近邻的训练样本标签值的均值作为预测值  </p><h3 id="KNN算法特点"><a href="#KNN算法特点" class="headerlink" title="KNN算法特点"></a>KNN算法特点</h3><p> 使用K-近邻算法时,需要已知样本集中每一个数据与所属分类的对应关系(监督学习)<br>通常K是不大于20的整数。 将待分类的新数据归类于所选择的K个最相似数据中出现次数最多的类别</p><h3 id="KNN算法流程"><a href="#KNN算法流程" class="headerlink" title="KNN算法流程"></a>KNN算法流程</h3><p>1  计算测试对象到训练集中每个对象的<strong>距离  </strong><br>2  按照距离的<strong>远近排序  </strong><br>3  选取与当前测试对象<strong>最近的k的训练对象</strong>，作为测试对象的邻居<br>4  统计这k个邻居的<strong>类别频次 </strong><br>5  k个邻居里<strong>频次最高的类别</strong>，即为测试对象的类  </p><h2 id="距离度量和K值选择"><a href="#距离度量和K值选择" class="headerlink" title="距离度量和K值选择"></a>距离度量和K值选择</h2><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><h4 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h4><p>$d(x,y)=\sqrt{\sum_i(x_i-y_i)^2}$<br>pdist()函数</p><h4 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h4><p>$d(x,y)=\sum_i|x_i-y_i|$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948144.png" alt=""><br>pdist(X,”cityblock”)</p><h4 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h4><p> 二个点之间的距离定义是其各坐标数值差绝对值的最大值。<br>$d(x,y)=\max_i|x_i-y_i|$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948145.png" alt=""><br>pdist(X,”chebyshev”)</p><h4 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h4><p>$d(x,y)=\left(\sum_{i}|x_{i}-y_{i}|^{p}\right)^{\frac{1}{p}}$<br> p=1时则为曼哈顿距离<br> p=2 时则为 欧氏距离<br> 当p取无穷时的极限情况下，可以得到切比雪夫距离  </p><h4 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h4><p>$d(x,y)=\frac{1}{N}\sum_i1_{x_i\neq y_i}$<br> 汉明距离是使用在数据传输差错控制编码里面的，汉明距离是一个概念，它表示两个（ 相同长度)字对应位不同的数量，我们以表示两个字之间的汉明距离。对两个字符串进行异或运算，并统计结果为1的个数，那么 这个数就是汉明距离。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948146.png" alt="">  </p><h4 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948147.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948148.png" alt=""></p><h3 id="K值选择"><a href="#K值选择" class="headerlink" title="K值选择"></a>K值选择</h3><p>注意：<br>k值选取不同，可能会得到不同的结果<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948149.png" alt=""></p><h4 id="k值重要性"><a href="#k值重要性" class="headerlink" title="k值重要性"></a>k值重要性</h4><h5 id="k值过小"><a href="#k值过小" class="headerlink" title="k值过小"></a>k值过小</h5><p>相当于用较小邻域中的训练数据进行预测。<br>优点：<br>减少了学习的近似误差，因为只有与输入数据较近的训练数据才会对预测结果起作用<br>缺点：<br>学习的估计误差会增大, 预测结果会对近邻数据点非常敏感。<br> 如果所选取的数据点恰巧是噪声数据, 那么预测就会出错。<br> 简单来说，K值过小会增加模型的复杂程度, 进而增加过拟合问题出现的风险。</p><h5 id="k值过大"><a href="#k值过大" class="headerlink" title="k值过大"></a>k值过大</h5><p>相当于用较大邻域中的训练数据进行预测<br>优点:减少学习的估计误差。<br>缺点:学习的近似误差会增大 ,因为离输入数据较远的训练数据也会起预测作用, 可能导致预测出现误差,K 值的增大意味着模型变得简单。<br> 当K 的值与样本数量相同时, 这样的模型过于简单, 会完全忽略训练中大量有用的信息, 预测未知数据的准确度将会非常低。</p><h4 id="近似误差与估计误差的区别"><a href="#近似误差与估计误差的区别" class="headerlink" title="近似误差与估计误差的区别"></a>近似误差与估计误差的区别</h4><p> 近似误差关注训练数据集。如果模型的近似误差小, 则容易出现过拟合的现象。即对训练集有很好的预测, 但对测试样本的预测将会出现较大偏差, 这种模型不是最佳模型。<br> 估计误差关注测试数据集。如果模型的估计误差小, 则说明其对未知数据的预测能力好, 估计误差越小的模型越接近最佳模型。  </p><h4 id="K值选择-1"><a href="#K值选择-1" class="headerlink" title="K值选择"></a>K值选择</h4><p> 在实际应用中,K值一般取一个比较小的整数值, 通常采用交叉验证法来选择最优K值。<br> 交叉验证法：对原始数据进行分组, 其中一 部分作为训练数据集, 另一部分作为验证数据集。<br>先用训练数据集对分类器进行训练, 再利用验证数据集来测试训练得到的模型<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948150.png" alt=""><br> 注意, 在划分数据时, 要保持数据分布的平衡。  </p><h2 id="KD树划分"><a href="#KD树划分" class="headerlink" title="KD树划分"></a>KD树划分</h2><h3 id="为什么要用KD树"><a href="#为什么要用KD树" class="headerlink" title="为什么要用KD树"></a>为什么要用KD树</h3><p>我们要计算输入数据与每一个训练数据的距离<br>常规思路： 是线性扫描,  按顺序一个个计算<br>当训练集十分大，或者高维特征空间(特征属性很多时)计算十分耗时<br> <strong>为了提高KNN搜索的效率</strong>，考虑使用特殊的结构存储训练数据, <strong>以减少计算距离的次数 </strong>，选用了KD树</p><h3 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h3><p> KD 树是<strong>每个结点都为K维点的二叉树</strong>, 本质上<strong>KD树是一种平衡二叉树</strong>(左子树和右子树的深度之差的绝对值不超过1 ,且它的左子树和右子树都是平衡二叉树),  目的是<strong>提高数据查找的效率 </strong><br> KD 树是一种<strong>空间划分树</strong>, 将整个向量空间划分为特定的几个部分, 然后在划分的特定空间内进行相关搜索操作。比如在二维空间中, KD 树按照 一定的划分规则把二维空间划分出多个空间。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948151.png" alt=""></p><h3 id="KD树的划分"><a href="#KD树的划分" class="headerlink" title="KD树的划分"></a>KD树的划分</h3><p>假设有6个二维数据点，构建KD树的过程：D= {(2,3), (5,7), (9,6), (4,5), (6,4),(7,2)}。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948152.png" alt=""><br>(1) 从x轴开始划分，根据x轴的取值2,5,9,4,6,7 得到中位数为6，因此切分线为：x=6。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948153.png" alt=""><br>(2) 可以根据x轴和y轴上数据的方差，选择方差最大的那个轴作为第一轮划分轴。<br>左子空间(记做D1)包含点 (2,3),(4,5),(5,7)，切分轴轮转，从y轴开始划分，切分线为:y= 5 。<br>右子空间(记做D2)包含点 (9,6),(7,2),切分轴轮转,从y轴开始划分,切分线为:y=6 。<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948154.png" alt=""><br>(3)D1的左子空间(记做D3),包含点(2,3)，切分轴轮转，从x 轴开始划分，切分线为:x= 2。<br> 其左子空间记做D7 ，右子空间记做D8 。由于D7,D8都不包含任何点，因此对它们不再继续拆分<br>𝐷1的右子空间(记做D4),包含点(5,7)，切分轴轮转，从x 轴开始划分，切分线为：x= 5。其左子空间记做D9，右子空间记做D10.由于D9,D10都不包含任何点，因此对它们不再继续拆分<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948155.png" alt=""><br>(4)D2的左子空间（记做D5）包含点(7,2)，切分轴轮转，从x轴开始划分，切分线为：x= 7。<br>其左子空间记做D11，右子空间记做D12 。由于D11,D12都不包含任何点，因此对它们不再继续拆分。D2的右子空间（记做D6）不包含任何点，停止继续拆分 </p><p>对于左右子树进行划分， 切分轴轮转，从𝑦轴开始划分<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948156.png" alt=""></p><h2 id="KD树搜索"><a href="#KD树搜索" class="headerlink" title="KD树搜索"></a>KD树搜索</h2><p>KD树可以省去大部分数据点的搜索，<strong>减少搜索的计算量</strong><br>例如，在搜索最近邻点任务中，给定一个目标点，搜索其最近邻，首先找到包含目标点的叶子结点，然后从该叶子节点出发，依序回溯到父节点，不断查找与目标点最近邻的节点，当确定不可能存在最近的节点时终止。这样搜索就被限制在空间的局部区域上，效率大为提高。</p><p>输入：已构造的KD树，目标点时x<br>输出：x的最近邻<br>寻找“当前最近点”<br>从根节点出发，递归访问KD树，找出包含x的叶节点，以此叶节点为“当前最近点”<br>回溯<br>以目标点和“当前最近点”的距离沿树根部进行回溯和迭代，当前最近点一定存在于该节点一个子节点对应的区域，检查子节点的父节点的另一个子节点对应的区域是否有更近的点</p><p>例子<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948157.png" alt=""><br>目标点x=(2.1,3.1);<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948159.png" alt=""><br>寻找当前最近带你：从根节点开始，x=(2.1,3.1)在根节点(7,2)的左子区域内，继续到(5,4)所确定的左子区域内，继续到(2,3)的右子区域中，(2,3)就是当前最近邻点<br>回溯：以(2.1,3.1)为圆心，以两点之间的距离为半径为一个圆，这个区域没有其他点，证明(2,3)是(2.1,3.1)的最近邻点。</p><p>目标点x=(2,4.5)<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101948160.png" alt=""><br>寻找当前最近点：从根节点开始，x=(2,4.5)在根节点(7,2)的左子区域内，继续到(5,4)所确定的上子区域内，继续到(4,7)的左子区域中，（4,7）就是当前最近邻点<br>回溯：我们以（2,4.5）为圆心，以(2,4.5)到(4,7)两点之间的距离为半径画一个圆，这个区域内有两个节点(2,3)和(5,4)，计算(2,4.5)到这两点的距离，得出到(2,3)的距离最近，那么(2,3)就是最近邻点。以(2,4.5)为圆心，以(2,4.5)到(2,3)两点之间的距离为半径画一个圆，此时圆里没有其他的节点，说明可以确定(2,3)就是(2,4.5)的最近邻点。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 KNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 决策树</title>
      <link href="/2024/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2024/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="决策树原理"><a href="#决策树原理" class="headerlink" title="决策树原理"></a>决策树原理</h2><h3 id="决策树概念"><a href="#决策树概念" class="headerlink" title="决策树概念"></a>决策树概念</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925453.png" alt=""></p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p>从训练数据中学习得出一个树状结构的模型<br>决策树属于<strong>判别模型，监督学习方法</strong>，归纳分类算法<br>决策树归纳的<strong>基本算法是贪心算法</strong>，自顶向下来构建决策树<br>贪心算法：在每一步选择中都采取在当前状态下最好的选择</p><h4 id="决策树的关键"><a href="#决策树的关键" class="headerlink" title="决策树的关键"></a>决策树的关键</h4><p>1 如何选择最优特征：不同的算法提出了不同的<strong>特征选择算法</strong><br>2 如何平衡拟合效果和泛化效果<strong>：预剪枝和后剪枝</strong></p><h4 id="不同的特征选择算法导致的树结构差异"><a href="#不同的特征选择算法导致的树结构差异" class="headerlink" title="不同的特征选择算法导致的树结构差异"></a>不同的特征选择算法导致的树结构差异</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925454.png" alt=""><br>在根节点选择年龄特征<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925455.png" alt=""><br>在根节点选择是否有工作特征<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925456.png" alt=""></p><h3 id="决策树的特点"><a href="#决策树的特点" class="headerlink" title="决策树的特点"></a>决策树的特点</h3><p>优点：<br>推导过程容易理解，计算简单，可解释性强<br>比较适合处理<strong>有缺失属性</strong>的样本<br>可<strong>自动忽略对目标变量没有贡献的属性变量</strong>，也为判断属性变量的重要性，减少变量的数目提供参考。</p><p>缺点：<br><strong>容易造成过拟合</strong>，需要采用剪枝操作。<br><strong>忽略了数据之间的相关性</strong><br>对于各类别样本数量不一致的数据<strong>，信息增益会偏向于那些更多数值的特征</strong></p><h3 id="决策树的三种类型"><a href="#决策树的三种类型" class="headerlink" title="决策树的三种类型"></a>决策树的三种类型</h3><p>建立决策树的关键，即在当前状态下<strong>选择哪个属性</strong>作为分类依据。根据不同的目标函数，建立决策树主要有以下三种算法：ID3，C4.5，CART(Classification And Regression Tree)<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925457.png" alt=""></p><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>ID3是一种决策树构建算法，<strong>算法的核心是”信息熵”</strong>，期望信息越小，信息熵越大，样本的纯度越低。<br>ID3算法是以信息论为基础，<strong>以信息增益为衡量标准</strong>，从而实现对数据的归纳分类。<br>ID3算法<strong>计算每个属性的信息增益</strong>，并<strong>选取具有最高增益的属性</strong>作为给定的测试属性。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1 初始化特征集合和数据集合<br>2 计算<strong>数据集合信息熵和所有特征的条件熵</strong>，选择<strong>信息增益最</strong>大的特征作为当前决策节点。<br>3 更新数据集合和特征集合(删除上一步使用的特征，并按照特征值来划分不同分支的数据集合)<br>4 重复2,3两步，若子集值包含单一特征，则为分支叶子节点。</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>$H(D)=-\sum_{k=1}^K\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$<br>K是类别数，D是数据集，Ck是类别K下的数据集<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101929189.png" alt=""><br>$\begin{aligned}&amp;H(D)=-\sum_{k=1}^{K}\frac{|C_{k}|}{|D|}log_{2}\frac{|C_{k}|}{|D|}=-\frac{9}{15}log_{2}\frac{9}{15}-\frac{6}{15}log_{2}\frac{6}{15}&amp;=0.971\end{aligned}$<br>按年龄划分<br>$H(D|A_{1}=\text{青年})=-\frac{2}{5}log_{2}\frac{2}{5}-\frac{3}{5}log_{2}\frac{3}{5}=0.971$<br>$H(D|A_{1}=\text{中年})=-\frac{3}{5}log_{2}\frac{3}{5}-\frac{2}{5}log_{2}\frac{2}{5}=0.971$<br>$H(D|A_{1}=\text{老年})=-\frac{4}{5}log_{2}\frac{4}{5}-\frac{1}{5}log_{2}\frac{1}{5}=0.7219$</p><h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p>$H(D|A)=\sum_{i=1}^n\frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}\sum_{k=1}^{K}\frac{|D_{ik}|}{|D_{i}|}\log_{2}\frac{|D_{ik}|}{|D_{i}|}$ A是特征，i是特征取值</p><script type="math/tex; mode=display">\begin{aligned}H(D|\text{年龄})& =\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}H(D_{i})  \\&=\frac{5}{15}\times0.971+\frac{5}{15}\times0.971+\frac{5}{15}\times0.7219 \\&=0.888\end{aligned}</script><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益=信息熵-条件熵<br>$g(D,A)=H(D)-H(D|A)$<br>$g(D,A=年龄)\\<br>=H(D)-H(D|A=年龄)\\<br>=0.971-0.888=0.083$</p><p>同理计算其他特征的信息增益<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925459.png" alt=""><br>选择 有自己的房子 为根节点的特征</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925460.png" alt=""></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>ID3没有剪枝策略</strong>，容易<strong>过拟合</strong><br>信息增益准则<strong>对可取值数目较多的特征有所偏好</strong>，类似编号的特征，其信息增益接近于1<br>只能用于处理<strong>离散分布的特征</strong><br>没有考虑<strong>缺失值</strong></p><h2 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a><strong>C4.5算法</strong></h2><h3 id="背景知识-1"><a href="#背景知识-1" class="headerlink" title="背景知识"></a>背景知识</h3><p>C4.5是对ID3算法的改进<br>ID3选择属性用的是子树的信息增益，而C4.5用的是<strong>信息增益率</strong><br>在决策树构造过程中进行<strong>剪枝</strong><br>对<strong>非离散数据</strong>也能处理<br>能够对<strong>不完整数据</strong>进行处理</p><h3 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h3><p>信息增益偏向于选择取值较多的特征，使用(<strong>信息增益率)某一特征单位取值个数下的信息增益</strong>。<br>$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$<br>其中<br>$g(D,A)=H(D)-H(D|A)$<br>$H_A(D)=-\sum_{i=1}^n\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}$ n是特征A的取值个数<br>D关于年龄特征A的熵<br>$H_{A_1}(D)=-\frac{5}{15}\mathrm{log}_2\frac{5}{15}-\frac{5}{15}\mathrm{log}_2\frac{5}{15}-\frac{5}{15}\mathrm{log}_2\frac{5}{15}=1.585$</p><p>$g_R(D,A_1)=\frac{g(D,A_1)}{H_{A1}(D)}=0.052$<br>同理计算其他特征的信息增益比<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925461.png" alt=""></p><h3 id="C4-5的剪枝"><a href="#C4-5的剪枝" class="headerlink" title="C4.5的剪枝"></a>C4.5的剪枝</h3><p><strong>过拟合的原因</strong><br>为了尽可能正确分类训练样本，节点的划分过程会不断重复直到不能再分，可能对训练样本学习地“太好”了，把训练样本的一些特点当做所有数据都具有的一般性质，从而导致过拟合</p><p>剪枝处理<strong>去掉一些分支</strong>来降低过拟合的风险<br>剪枝的基本策略有“<strong>预剪枝</strong>”和“<strong>后剪枝</strong>”。</p><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><p><strong>生成过程中，对每个节点划分前进行估计</strong>，若当前节点的划分不能提升泛化能力，则停止划分，记当前节点为叶节点</p><h4 id="限定决策树的深度"><a href="#限定决策树的深度" class="headerlink" title="限定决策树的深度"></a>限定决策树的深度</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925462.png" alt=""><br>使用ID3算法生成决策树如下<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925463.png" alt=""><br>如果限定深度为3层，直接对色泽特征进行剪枝<br>选取纹理清晰、根蒂稍蜷缩中的数据集，好瓜的个数大于坏瓜<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925464.png" alt=""><br>直接替换为叶节点标记为好瓜<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925465.png" alt=""></p><h4 id="设定一个阈值"><a href="#设定一个阈值" class="headerlink" title="设定一个阈值"></a>设定一个阈值</h4><p>如果把阈值设置为0.4，计算所有特征的信息增益，如果小于阈值，意味着特征并不会给分类带来确定性，直接看总数据集（或者当前节点数据集）中，有多少好瓜和坏瓜<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925466.png" alt="">则当前决策树只有一个节点，坏瓜</p><h4 id="设置某个指标，比较节点划分前后的泛化能力"><a href="#设置某个指标，比较节点划分前后的泛化能力" class="headerlink" title="设置某个指标，比较节点划分前后的泛化能力"></a>设置某个指标，比较节点划分前后的泛化能力</h4><h5 id="将数据集划分为训练集和测试集"><a href="#将数据集划分为训练集和测试集" class="headerlink" title="将数据集划分为训练集和测试集"></a>将数据集划分为训练集和测试集</h5><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925467.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925468.png" alt=""></p><h5 id="计算训练集的信息增益，并进行划分"><a href="#计算训练集的信息增益，并进行划分" class="headerlink" title="计算训练集的信息增益，并进行划分"></a>计算训练集的信息增益，并进行划分</h5><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925469.png" alt=""><br>任意选择信息增益最大的其中一个，例如脐部<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925470.png" alt=""><br>在训练集中，凹陷的瓜有4个，其中3个为好瓜，1个为坏瓜，标记为好瓜<br>稍凹的瓜中，有2个是好瓜，2个是坏瓜，类标记是好瓜；<br>平坦的瓜中，2个都是坏瓜，标记为坏瓜。</p><h5 id="对测试集进行判断，得出测试集的误差"><a href="#对测试集进行判断，得出测试集的误差" class="headerlink" title="对测试集进行判断，得出测试集的误差"></a>对测试集进行判断，得出测试集的误差</h5><p>使用的决策树对测试集进行计算，得出误差率为2/7;</p><h5 id="计算当前节点剪枝后的误差率"><a href="#计算当前节点剪枝后的误差率" class="headerlink" title="计算当前节点剪枝后的误差率"></a>计算当前节点剪枝后的误差率</h5><p>当前节点为根节点，如果剪枝，即直接为最终的类别，为好瓜或者坏瓜，训练集中两者类别个数相等，任选其一。<br>假如记为好瓜，那么测试集的误差率为4/7；<br>如果记为坏瓜，那么测试集的误差率为3/7；<br>比未剪枝，误差率提高了，所以当前节点不剪枝。</p><h5 id="对下一层进行相同的操作决定是否剪枝"><a href="#对下一层进行相同的操作决定是否剪枝" class="headerlink" title="对下一层进行相同的操作决定是否剪枝"></a>对下一层进行相同的操作决定是否剪枝</h5><p>注意根据奥卡姆剃刀原理，对于相同的误差率，选择深度小的决策树。相同的误差率进行剪枝。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925471.png" alt=""></p><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><p>生成一颗完整的决策树，从底部向上对内部节点进行考察，如果将<strong>内部节点变成叶节点</strong>，可以提升泛化能力，那么就进行交换</p><p>后剪枝决策树通常比预剪枝决策树<strong>保留了更多的分支</strong>。一般情况下，后剪枝的欠<strong>拟合风险更小，泛化性能往往优于预剪枝决策树。</strong></p><h4 id="降低错误剪枝REP"><a href="#降低错误剪枝REP" class="headerlink" title="降低错误剪枝REP"></a>降低错误剪枝REP</h4><p>与预剪枝类似，只不过是<strong>自下而上</strong><br>使用「测试集」剪枝，对每个结点计算剪枝前后的误判个数，如果剪枝满足「减少误判或者相同误判」，则减掉该结点所在分枝。</p><h5 id="划分训练集和测试集，生成决策树"><a href="#划分训练集和测试集，生成决策树" class="headerlink" title="划分训练集和测试集，生成决策树"></a>划分训练集和测试集，生成决策树</h5><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925472.png" alt=""></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925473.png" alt=""></p><h5 id="得出可替代的叶子结点"><a href="#得出可替代的叶子结点" class="headerlink" title="得出可替代的叶子结点"></a>得出可替代的叶子结点</h5><p>自下而上，找出当前特征的训练数据集，例如纹理特征的训练数据集是<br>脐部稍凹、根蒂稍蜷缩、色泽乌黑，有一个好瓜和一个坏瓜，设当前节点剪枝后为好瓜<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925474.png" alt=""></p><h5 id="判断剪枝前后的测试集的误判个数"><a href="#判断剪枝前后的测试集的误判个数" class="headerlink" title="判断剪枝前后的测试集的误判个数"></a>判断剪枝前后的测试集的误判个数</h5><p>如果剪枝后的误差个数&gt;剪枝前的误差个数，则不进行剪枝<br>纹理剪枝后的误判个数为2，剪枝前误判个数1</p><h5 id="对上一次特征节点重复前两步"><a href="#对上一次特征节点重复前两步" class="headerlink" title="对上一次特征节点重复前两步"></a>对上一次特征节点重复前两步</h5><h4 id="降低错误剪枝REP的特点"><a href="#降低错误剪枝REP的特点" class="headerlink" title="降低错误剪枝REP的特点"></a>降低错误剪枝REP的特点</h4><p>计算复杂性是线性的，每个节点只需要访问1次<br>操作简单，容易理解<br>受测试集影响大，体现出欠拟合的不足，如果测试集比训练集小，就会限制分类的精度。</p><h4 id="悲观错误剪枝PEP"><a href="#悲观错误剪枝PEP" class="headerlink" title="悲观错误剪枝PEP"></a>悲观错误剪枝PEP</h4><h5 id="悲观错误剪枝原理"><a href="#悲观错误剪枝原理" class="headerlink" title="悲观错误剪枝原理"></a>悲观错误剪枝原理</h5><p>根据剪枝前后的错误率来决定是否剪枝，和REP不同，<strong>PEP只需要训练集</strong>即可。不需要测试集，并且是<strong>从上而下</strong>的剪枝</p><h5 id="悲观错误剪枝算法步骤"><a href="#悲观错误剪枝算法步骤" class="headerlink" title="悲观错误剪枝算法步骤"></a>悲观错误剪枝算法步骤</h5><h6 id="计算剪枝前目标子树每个叶子结点的误差，并进行连续修正"><a href="#计算剪枝前目标子树每个叶子结点的误差，并进行连续修正" class="headerlink" title="计算剪枝前目标子树每个叶子结点的误差，并进行连续修正"></a>计算剪枝前目标子树每个叶子结点的误差，并进行连续修正</h6><p>$Error(Leaf_i)=\frac{error(Leaf_i)+0.5}{N(T)}$<br>根据上述公式<strong>计算每个叶子结点的误差率</strong><br>error(Leaf[i])表示叶子结点Leaf[i]处的误判的样本个数，N(T)表示的是总样本个数，计算出某一个叶子结点对应的误差率，分子上加上0.5进行连续性的修正</p><h6 id="计算剪枝前目标子树的修正误差"><a href="#计算剪枝前目标子树的修正误差" class="headerlink" title="计算剪枝前目标子树的修正误差"></a>计算剪枝前目标子树的修正误差</h6><p>$Error(T)=\sum_{i=1}^LError(Leaf_i)=\frac{\sum_{i=1}^Lerror(Leaf_i)+0.5*L}{N(T)}$<br>得出剪枝前的目标子树的修正误差率，L是叶子结点的个数</p><h6 id="计算剪枝前目标子树误判个数的期望值"><a href="#计算剪枝前目标子树误判个数的期望值" class="headerlink" title="计算剪枝前目标子树误判个数的期望值"></a>计算剪枝前目标子树误判个数的期望值</h6><p>$E(T)=N(T)\times Error(T)=\sum_{i=1}^Lerror(Leaf_i)+0.5*L$</p><h6 id="计算剪枝前目标子树误判个数的标准差"><a href="#计算剪枝前目标子树误判个数的标准差" class="headerlink" title="计算剪枝前目标子树误判个数的标准差"></a>计算剪枝前目标子树误判个数的标准差</h6><p>$std(T)=\sqrt{N(T)\times Error(T)\times(1-Error(T))}$</p><h6 id="计算剪枝前误判上限-即悲观误差"><a href="#计算剪枝前误判上限-即悲观误差" class="headerlink" title="计算剪枝前误判上限(即悲观误差)"></a>计算剪枝前误判上限(即悲观误差)</h6><p>$E(T)+std(T)$<br>悲观误差=期望值+标准差</p><h6 id="计算剪枝后改节点的修正误差"><a href="#计算剪枝后改节点的修正误差" class="headerlink" title="计算剪枝后改节点的修正误差"></a>计算剪枝后改节点的修正误差</h6><p>$Error(Leaf)=\frac{error(Leaf)+0.5}{N(T)}$</p><h6 id="计算剪枝后该节点误差个数的期望值"><a href="#计算剪枝后该节点误差个数的期望值" class="headerlink" title="计算剪枝后该节点误差个数的期望值"></a>计算剪枝后该节点误差个数的期望值</h6><p>$E(Leaf)=error(Leaf)+0.5$</p><h6 id="比较剪枝前后的误判个数，如果满足一下不等式，则剪枝；否则，不剪枝"><a href="#比较剪枝前后的误判个数，如果满足一下不等式，则剪枝；否则，不剪枝" class="headerlink" title="比较剪枝前后的误判个数，如果满足一下不等式，则剪枝；否则，不剪枝"></a>比较剪枝前后的误判个数，如果满足一下不等式，则剪枝；否则，不剪枝</h6><p>$E(Leaf)&lt;E(T)+std(T)$</p><h5 id="悲观错误剪枝例题讲解"><a href="#悲观错误剪枝例题讲解" class="headerlink" title="悲观错误剪枝例题讲解"></a>悲观错误剪枝例题讲解</h5><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925475.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925476.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925477.png" alt=""><br>如果想把目标子树根蒂剪枝，计算虚线框内的误判率。<br>计算修正误差率</p><script type="math/tex; mode=display">Error(T) =\sum_{i=1}^{L}Error(Leaf_{i})\\=\frac{\sum_{i=1}^Lerror(Leaf_i)+0.5*L}{N(T)} \\=\frac{1+0.5\times4}9=\frac13</script><p>计算期望值</p><script type="math/tex; mode=display">E(T) =N(T)\times Error(T)\\=\sum_{i=1}^Lerror(Leaf_i)+0.5*L \\=9\times\frac13=3</script><p>计算标准差</p><script type="math/tex; mode=display">std(T) =\sqrt{N(T)\times Error(T)\times(1-Error(T))}  \\=\sqrt{9\times\frac13\times(1-\frac13)} \\=1.414</script><p>计算剪枝前误差上限</p><script type="math/tex; mode=display">E(T)+std(T)=3+1.414=4.414</script><p>计算剪枝后的修正误差和期望</p><script type="math/tex; mode=display">Error(Leaf) =\frac{error(Leaf)+0.5}{N(T)}  \\=\frac{2+0.5}9=\frac{2.5}9</script><script type="math/tex; mode=display">E(Leaf)=error(Leaf)+0.5=2.5</script><p>看出剪枝前的E(T)+std(T)4.414大于剪枝后的E(Leaf)的值2.5，说明剪枝后的误判率降低了，就可以剪枝了。</p><h5 id="悲观错误剪枝的特点"><a href="#悲观错误剪枝的特点" class="headerlink" title="悲观错误剪枝的特点"></a>悲观错误剪枝的特点</h5><p>不需要分离剪枝数据集，有利于实例少的问题。<br>误差使用了连续修正值，适用性更强。<br>由于自上而下的剪枝策略，PEP效率更高，但是也可能修剪掉不应修剪的。</p><h3 id="C4-5的缺点"><a href="#C4-5的缺点" class="headerlink" title="C4.5的缺点"></a>C4.5的缺点</h3><p>剪枝策略可以再优化；<br>C4.5用的是<strong>多叉树</strong>，用二叉树效率更高；<br>C4.5<strong>只能用于分类</strong><br>C4.5使用的熵模型拥有大量<strong>耗时</strong>的对数运算，连续值还有排序运算；<br>C4.5在构造树的过程中，对数值属性值需要进行排序，从中选择一个分割点，所以只适用于能够驻留在内存的数据集，<strong>当训练集大的无法在内存容纳时，程序无法运行</strong></p><h2 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h2><h3 id="背景知识-2"><a href="#背景知识-2" class="headerlink" title="背景知识"></a>背景知识</h3><p>CART(Classification and Regression Tree)是决策树的一种，可以创建分类树和回归树<br>用<strong>基尼指数</strong>来选择属性(<strong>分类</strong>)，或用<strong>均方差</strong>来选择属性(<strong>回归</strong>)<br>CART树是二叉树</p><h3 id="CART算法-分类"><a href="#CART算法-分类" class="headerlink" title="CART算法-分类"></a>CART算法-分类</h3><h4 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h4><p>假设有K个类，样本点属于第k类的概率为p_k，概率分布的基尼指数定义为：<br>$Gini(p)=\sum_{k=1}^Kp_k(1-p_k)=1-\sum p_k^2$<br>就是样本点<strong>被错分的概率期望，</strong>如果样本集只有一个类别，基尼指数为0，表示样本集纯度达到最高值<br>对于二类分类问题<br>如果样本点属于第一类的概率为p，那么第二类的概率是1-p<br>$\begin{aligned}<br>Gini(p)&amp; =p(1-p)+(1-p)(1-(1-p))  \\<br>&amp;=2p(1-p)<br>\end{aligned}$<br>如果对给定的样本集合D，可以分为两个子集C1，和C2：<br>$Gini(D)=1-\sum_{k=1}^2(\frac{|C_k|}{|D|})^2\\<br>\frac{|C_1|}{|D|}\text{就是}p\text{的经验值。}$<br><strong>使用基尼指数最小化来选出最优特征</strong><br>对于特征A条件下，样本集D的基尼指数如：<br>$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$</p><h4 id="基尼指数计算实例"><a href="#基尼指数计算实例" class="headerlink" title="基尼指数计算实例"></a>基尼指数计算实例</h4><p>一共10个桃子，其中5个好吃，5个不好吃<br>整个数据集的基尼指数：<br>$Gini(D)=2p(1-p)=2\times\frac12\times\frac12=0.5$<br>分类：好吃和不好吃</p><p>Case1选择甜度特征A，按照阈值0.2分为两组<br>假设，甜度大于0.2的有6个桃子，其中5个好吃，1个不好吃，甜度小于等于0.2的有4个桃子，都不好吃，那么我们就可以列出这样一个二叉树。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925478.png" alt=""><br>计算D1数据集的基尼指数<br>$Gini(D_1)=2\times\frac56\times\frac16=\frac{10}{36}$<br>D1所占的权重为 w1=6/10;</p><p>计算D2数据集的基尼指数<br>$Gini(D_2)=2\times\frac04\times\frac44=0$<br>D2所占的权重为w2=4/10<br>计算甜度特征下的基尼指数<br>$Gini(D,A)=\frac6{10}\times\frac{10}{36}+\frac4{10}\times0=\frac16=0.17$</p><p>Case2选择硬度特征B，按照软硬分为两组<br>假设，有5个硬桃子，其中2个好吃，3个不好吃，5个软桃子中，有3个好吃，2个不好吃。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925479.png" alt=""><br>计算D1，D2的基尼指数<br>计算硬度下的基尼指数<br>$Gini(D,B)=\frac{1}{2}\times\frac{12}{25}+\frac{1}{2}\times\frac{12}{25}=\frac{12}{25}=0.48$</p><p>$Gini(D,A)&lt;Gini(D,B)$<br>甜度分类的错误分类更小，选择甜度为最优特征<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925480.png" alt=""><br>$Gini(D,A)=\frac{|D_{1}|}{|D|}Gini(D_{1})+\frac{|D_{2}|}{|D|}Gini(D_{2})\quad Gini(p)=\sum_{k=1}^{K}p_{k}(1-p_{k})$<br>$Gini(D,A_1=\text{青年})=\frac{5}{15}\times\left(2\times\frac{2}{5}\times\left(1-\frac{2}{5}\right)\right)+\frac{10}{15}\times\left(2\times\frac{7}{10}\times\left(1-\frac{7}{10}\right)\right)=0.44$</p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925481.png" alt=""></p><h4 id="离散特征处理"><a href="#离散特征处理" class="headerlink" title="离散特征处理"></a>离散特征处理</h4><p>假如特征a有m个离散值。<br>分类标准是：每一次将其中一个特征值分为一类，其他非该特征值分为另一类<br>依照这个标准遍历所有分类情况，计算每个分类下的基尼指数。<br>最终选择最小的作为最终的特征划分。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925482.png" alt=""><br>比如第1次取{𝒂𝟏}为类别1，那么剩下的特征{𝒂𝟐 , 𝒂𝟑,……, 𝒂𝒎}为类别2，由此遍历，第𝒎次取{ 𝒂𝒎}为类别1，那么剩下的特征{𝒂𝟏,𝒂𝟐 , 𝒂𝟑,……, 𝒂𝒎-𝟏}为类别2。 </p><p>CART的特征会多次参与节点的建立，而在ID3或者C4.5的一颗子树中，离散特征只会参与一次节点的建立。</p><h4 id="连续特征处理"><a href="#连续特征处理" class="headerlink" title="连续特征处理"></a>连续特征处理</h4><p>𝒎个样本的连续特征𝑨有𝒎个，𝒂𝟏, 𝒂𝟐 ,𝒂𝟑,……, 𝒂𝒎-𝟏, 𝒂𝒎从小到大排列<br>取相邻两样本值的平均数做划分点，一共取𝒎 - 𝟏个，其中第m个划分点Tm表示为:<br>Tm=(am-1+am) /2<br> 分别计算着m-1个点作为二元分类点时的基尼指数<br>选择基尼指数最小的点为该连续特征的二元离散分类点。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925483.png" alt=""><br>比如取到的基尼指数最小的点为𝒂𝒕，则小于𝒂𝒕的值为类别1，大于𝒂𝒕的值为类别2，这样就做到了连续特征的离散化，接着采用基尼指数的大小来度量特征的各个划分点 </p><p>鸾尾花决策树原理-连续特征处理<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925484.png" alt=""></p><h3 id="CART算法-回归"><a href="#CART算法-回归" class="headerlink" title="CART算法-回归"></a>CART算法-回归</h3><h4 id="用均方差来选择属性"><a href="#用均方差来选择属性" class="headerlink" title="用均方差来选择属性"></a>用均方差来选择属性</h4><p>对于任意划分特征 𝑨，对应的任意划分点𝒔 两边划分成的数据集 𝑫𝟏和𝑫𝟐 ，求出使 𝑫𝟏和𝑫𝟐各自集合的均方差最小，同时 𝑫𝟏和𝑫𝟐的均方差之和最小所对应的特征和特征值划分点。表达式为：<br>$\min_{a,s}[\min_{c_{1}}\sum_{x_{i}\in D_{1}}(y_{i}-c_{1})^{2}+\min_{c_{2}}\sum_{x_{i}\in D_{2}}(y_{i}-c_{2})^{2}]$<br>𝒄𝟏为𝑫𝟏数据集的样本输出均值，𝒄𝟐为𝑫𝟐 数据集的样本输出均值 </p><p>预测方式<br>CART分类树采用叶子节点里概率最大的类别作为当前节点的预测类别<br>CART回归树采用最终叶子的均值或者中位值来预测输出结果</p><h3 id="CART剪枝"><a href="#CART剪枝" class="headerlink" title="CART剪枝"></a>CART剪枝</h3><p>CART算法采用一种“<strong>基于代价复杂度的剪枝</strong>”方法进行<strong>后剪枝</strong>。<br>这种方法会生成一系列树，每个树都是通过将前面的树的某个或某些子树替换成一个叶节点而得到的，这一系列树中的最后一棵树仅含一个用来预测类别的叶节点<br>然后用一种成本复杂度的度量准则来判断哪颗子树应该被一个预测类别值的叶节点所代替<br>需要使用一个单独的测试数据集来评估所有的树，根据他们在测试数据集熵的分类性能选出最佳的树<br>具体流程<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925485.png" alt=""></p><p>1 计算每一个节点的条件熵<br>2 递归地从叶子结点开始往上遍历，减掉叶子节点，然后判断损失函数的值是否减少，如果减少了，则将父节点作为新的叶子节点<br> 3 重复2，直到完全不能剪枝</p><h2 id="决策树差异总结"><a href="#决策树差异总结" class="headerlink" title="决策树差异总结"></a>决策树差异总结</h2><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101925486.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 逻辑回归</title>
      <link href="/2024/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/06/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>分类：标签离散，但是输入变量可以是离散的，也可以是连续的。<br>指根据已有样本，通过一个或多个特征判断新样本属于那个已知的样本类<br>根据前几天的天气，预测未来几天的天气是阴、晴还是雨？<br>根据前几天的天气，预测未来几天的天气是否晴？ </p><h3 id="分类类型"><a href="#分类类型" class="headerlink" title="分类类型"></a>分类类型</h3><p><strong>二分类问题</strong><br>二元输出<br><strong>多分类问题</strong><br>输出许多离散类标签之一<br>类标签互斥<br><strong>多标签分类问题</strong><br>一个样本可以分配给多个标签<br>各类标签不相互排斥</p><h4 id="二分类问题"><a href="#二分类问题" class="headerlink" title="二分类问题"></a>二分类问题</h4><p>只需要分类1次，一种数据定义为类型1(正类,1)，其余数据为类型2(父类,-1or0)</p><h4 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h4><p>通常将<strong>多分类问题拆解成多个二分类问题去解决</strong></p><h5 id="One-Versus-One-OvO-：一对一"><a href="#One-Versus-One-OvO-：一对一" class="headerlink" title="One-Versus-One(OvO)：一对一"></a>One-Versus-One(OvO)：一对一</h5><p>每一个类别都和另一个类别做一次1V1的二分类<br>一个有N种分类的问题使用此策略需要进行$N*(N-1)/2$次二分类处理<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657285.png" alt=""></p><h5 id="One-Versus-The-Rest-OvR-One-Versus-All-OvA-一对多"><a href="#One-Versus-The-Rest-OvR-One-Versus-All-OvA-一对多" class="headerlink" title="One-Versus-The-Rest(OvR)/One-Versus-All(OvA):一对多"></a>One-Versus-The-Rest(OvR)/One-Versus-All(OvA):一对多</h5><p>每一个类别和所有其他类别做一次二分类。<br>一个有N种分类的问题使用此策略需要进行N次二分类处理。</p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657287.png" alt=""><br>如果产生了多个正例，则根据分类器的置信度作为指标，来<strong>选择置信度最大的分类器</strong>作为最终效果</p><p>另外一种处理方式(不常见)<br>定义其中一类为类型1(正类)，其余数据为负类(rest);<br>去掉类型1数据，剩余部分再次进行二分类，分成类型2和负类；<br>如果有n类，则需要分类n-1次。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657288.png" alt=""></p><p>OvO和OvR的区别<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657289.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657290.png" alt=""></p><h5 id="Error-Correcting-Output-codes-纠错码机制-：多对多"><a href="#Error-Correcting-Output-codes-纠错码机制-：多对多" class="headerlink" title="Error Correcting Output codes(纠错码机制)：多对多"></a>Error Correcting Output codes(纠错码机制)：多对多</h5><p>编码阶段和解码阶段<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657291.png" alt=""></p><p>编码阶段对N个类别进行M次划分，每次划分将一部分数据分为正类，一部分数据分为反类，每次划分都构建出一个模型，模型的结果是在空间中对于每个类别都定义了一个点；<br>解码阶段中使用训练出来的模型对测试样例进行预测，将预测样本对应的点和类别之间的点求距离，选择距离最近的类别作为最终的预测类别。</p><h3 id="多标签分类问题"><a href="#多标签分类问题" class="headerlink" title="多标签分类问题"></a>多标签分类问题</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657292.png" alt=""><br><a href="https://www.cnblogs.com/yifanrensheng/p/12355009.html">多分类及多标签分类算法</a></p><h2 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在逻辑回归、神经网络中有广泛应用</p><h4 id="图形形式"><a href="#图形形式" class="headerlink" title="图形形式"></a>图形形式</h4><p>连续，光滑，严格单调，以(0,0.5)中心对称，是一个非常良好的阙值函数<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657293.png" alt=""></p><h4 id="数学形式"><a href="#数学形式" class="headerlink" title="数学形式"></a>数学形式</h4><p>$\sigma(z)=g(z)=\frac{1}{1+e^{-z}}$<br>符合概率函数的特性，一件事要么发生，要么不发生<br>$1-\sigma(z)=\sigma(-z)$<br>Sigmoid函数的积分<br>$\int\sigma(z)dz=\int\frac{e^z}{1+e^z}dz=\int\frac{u’}{u}dz=\int\frac{1}{u}du=\ln(u)=\ln(1+e^z)$<br>Sigmoid函数的导数，是其本身的函数</p><script type="math/tex; mode=display">\begin{aligned}g^{\prime}(z)& =(\frac{1}{1+e^{-z}})^{\prime}=\frac{e^{-z}}{(1+e^{-z})^{2}}  \\&=\frac{1+e^{-z}-1}{(1+e^{-z})^{2}}=\frac{1}{(1+e^{-z})}(1-\frac{1}{(1+e^{-z})}) \\&=g(z)(1-g(z))\end{aligned}</script><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657294.png" alt=""><br>可用作概率累积分布函数：其概率密度就是其导数。与正态概率分布函数非常接近。</p><h3 id="逻辑回归使用Sigmoid函数的原因"><a href="#逻辑回归使用Sigmoid函数的原因" class="headerlink" title="逻辑回归使用Sigmoid函数的原因"></a>逻辑回归使用Sigmoid函数的原因</h3><p>y发生的概率[0,1];<br>$p\in[0,1]$<br>x与p的关系<br>$p=w^{\mathrm{T}}x$<br>事件的几率odds<br>$p/(1-p)\in[0,+\infty)$<br>对数变化，Log-odds<br>$\log(p/(1-p))\in(-\infty,+\infty)$<br>$\log\frac{p}{1-p}=w^{\mathrm{T}}x=z$<br>$p=\frac{1}{1+e^{-w^{\mathrm{T}}x}}=\frac{1}{1+e^{-z}}$</p><h2 id="逻辑回归求解"><a href="#逻辑回归求解" class="headerlink" title="逻辑回归求解"></a>逻辑回归求解</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>又称逻辑回归分析，是一种广义的线性回归分析模型。通过逻辑回归分析能得到自变量的权重，同时也可预测在确定条件下因变量所处状态的可能性。<br>逻辑回归的因变量可以是二分类，也可以是多变量<br>逻辑回归的自变量既可以是连续变量也可以是离散常量。<br>使用sigmoid函数预测事件发生的概率，<br>当g(z)大于等于0.5时，预测y=1；<br>当g(z)小于0.5时，预测y=0；</p><h3 id="求解推导"><a href="#求解推导" class="headerlink" title="求解推导"></a>求解推导</h3><p>设一个二分类模型</p><script type="math/tex; mode=display">p(y=1|x;w)=h(x)\\p(y=0|x;w)=1-h(x)</script><p>则<br>$p(y|x;w)=(h(x))^y(1-h(x))^{1-y}$ （1）</p><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>对式(1)进行取对数操作<br>$\mathrm{L}\big(\hat{y},y\big)=y\mathrm{log}(\hat{y})+(1-y)\mathrm{log}(1-\hat{y}\big)$<br>利用最大似然估计原理，利用已知的样本分布，或者参数使这组数据的概率最大。<br>对似然函数加负号，通过求等价问题的最小值来求原问题的最大值。<br>$\mathrm{L}\big(\hat{y},y\big)=-y\mathrm{log}(\hat{y})-(1-y)\mathrm{log}(1-\hat{y}\big)$</p><h4 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h4><p>$J(w)=\frac{1}{m}\sum_{i=1}^{m}\mathrm{L}\left(\hat{y}^{(i)},y^{(i)}\right)=\frac{1}{m}\sum_{i=1}^{m}\left(-y^{(i)}\mathrm{log}\hat{y}^{(i)}-(1-y^{(i)})\mathrm{log}(1-\hat{y}^{(i)})\right)$<br>梯度下降求解过程<br>$w_j{:}=w_j-\alpha\frac{\partial J(w)}{\partial w}$<br>$J(w)=-\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}\mathrm{log}(h(x^{(i)}))+(1-y^{(i)})\mathrm{log}(1-h(x^{(i)})))$</p><script type="math/tex; mode=display">\begin{gathered}y^{(i)}\mathrm{log}(h(x^{(i)}))+(1-y^{(i)})\mathrm{log}(1-h(x^{(i)})) \\=y^{(i)}\mathrm{log}(\frac{1}{1+e^{-w^{\mathrm{T}}x^{(i)}}})+(1-y^{(i)})\mathrm{log}(1-\frac{1}{1+e^{-w^{\mathrm{T}}x^{(i)}}})\\=-y^{(i)}\mathrm{log}(1+e^{-w^{\mathrm{T}}x^{(i)}})-(1-y^{(i)})\mathrm{log}(1+e^{w^{\mathrm{T}}x^{(i)}}) \end{gathered}</script><p>$\frac{\partial}{\partial w_{j}}J(w)=\frac{\partial}{\partial w_{j}}(-\frac{1}{m}\sum_{i=1}^{m}(-y^{(i)}\mathrm{log}\Big(1+e^{-w^{\mathrm{T}}x^{(i)}}\Big)-\Big(1-y^{(i)}\Big)\mathrm{log}\Big(1+e^{w^{\mathrm{T}}x^{(i)}}\Big)))$<br>$=-\frac{1}{m}\sum_{i=1}^{m}(-y^{(i)}\frac{-x_{j}^{(i)}e^{-w^{\mathrm{T}}x^{(i)}}}{1+e^{-w^{\mathrm{T}}x^{(i)}}}-(1-y^{(i)})\frac{x_{j}^{(i)}e^{w^{\mathrm{T}}x^{(i)}}}{1+e^{w^{\mathrm{T}}x^{(i)}}})$<br>$=-\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}-h(x^{(i)}))x_{j}^{(i)}$<br>$=\frac{1}{m}\sum_{i=1}^{m}(h(x^{(i)})-y^{(i)})x_{j}^{(i)}$</p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p><strong>目的：防止过拟合</strong><br>$J(w)=\frac{1}{m}\sum_{i=1}^{m}\left[-y^{(i)}\mathrm{log}\Big(h\Big(x^{(i)}\Big)\Big)-\Big(1-y^{(i)}\Big)\mathrm{log}\Big(1-h\Big(x^{(i)}\Big)\Big)\right]+\frac{\lambda}{2m}\sum_{j=1}^{n}w_{j}^{2}$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657295.png" alt=""></p><h2 id="逻辑回归不使用MSE而使用交叉熵损失的原因分析"><a href="#逻辑回归不使用MSE而使用交叉熵损失的原因分析" class="headerlink" title="逻辑回归不使用MSE而使用交叉熵损失的原因分析"></a>逻辑回归不使用MSE而使用交叉熵损失的原因分析</h2><h3 id="两种损失函数的定义"><a href="#两种损失函数的定义" class="headerlink" title="两种损失函数的定义"></a>两种损失函数的定义</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101703373.png" alt=""><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657296.png" alt=""></p><h3 id="逻辑回归中的-MSE-和非凸性问题"><a href="#逻辑回归中的-MSE-和非凸性问题" class="headerlink" title="逻辑回归中的 MSE 和非凸性问题"></a>逻辑回归中的 MSE 和非凸性问题</h3><p>在分类场景中，我们通常使用基于梯度的技术，通过最小化损失函数来找到系数的最优值。因此，如果损失函数不是凸函数，就不能保证我们总是能达到全局最小值，相反，我们可能会陷入局部最小值。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657297.png" alt=""></p><h3 id="什么是凸函数"><a href="#什么是凸函数" class="headerlink" title="什么是凸函数"></a>什么是凸函数</h3><p>如果函数图形上任意两点之间的线段位于图形上方或图形上，则称为凸函数。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657298.png" alt=""><br>如果 f 是两次可微分的，并且域是实线，那么我们可以将其表征如下：<br>f 是凸的，当且仅当 对于所有 x, f ‘’(x) ≥ 0。 因此，如果我们能证明我们的损失函数的二阶导数≥0，那么我们可以声称它是凸的。 </p><h3 id="为什么MSE损失函数是非凸的？"><a href="#为什么MSE损失函数是非凸的？" class="headerlink" title="为什么MSE损失函数是非凸的？"></a>为什么MSE损失函数是非凸的？</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657299.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657300.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657301.png" alt=""><br>基于凸性定义，我们在数学上表明逻辑回归的 MSE 损失函数是非凸的，不推荐使用。</p><h3 id="为什么log-loss”函数是凸的？"><a href="#为什么log-loss”函数是凸的？" class="headerlink" title="为什么log-loss”函数是凸的？"></a>为什么log-loss”函数是凸的？</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101657302.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 回归分析</title>
      <link href="/2024/06/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/"/>
      <url>/2024/06/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="监督学习分为分类和回归"><a href="#监督学习分为分类和回归" class="headerlink" title="监督学习分为分类和回归"></a>监督学习分为分类和回归</h4><p>分类问题，标签是离散的<br>根据前几天的天气，预测未来几天的天气是阴、晴还是雨？<br>回归问题，标签是连续的<br>根据前几天的温度，预测未来几天的温度？  </p><h4 id="回归vs分类"><a href="#回归vs分类" class="headerlink" title="回归vs分类"></a>回归vs分类</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638981.png" alt=""></p><h4 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h4><p>回归分析是估计因变量和自变量之间关系的过程，通过建立数学模型预测因变量的取值<br>可以估计数据范围内的缺失数据(插值)<br>可以估计数据范围之外的未来数据(外推法)</p><h3 id="回归类型"><a href="#回归类型" class="headerlink" title="回归类型"></a>回归类型</h3><h4 id="回归的类型"><a href="#回归的类型" class="headerlink" title="回归的类型"></a>回归的类型</h4><p>线性回归<br>多项式回归<br>岭(Ridge)回归<br>Lasso回归<br>ElasticNet回归</p><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><p>是一种通过属性的线性组合来进行预测的线性模型，其目的是找到一条直线或者一个平面或者更高维的超平面，使得预测值与真实值之间的误差最小化。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638983.png" alt=""><br>注意：<strong>线性回归假设因变量和自变量之间是线性的</strong>。当数据点之间的关系不是线性时，它无法拟合数据点。</p><h4 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h4><p>多项式回归通过将m次多项式拟合到数据点来拓展线性回归的拟合能力。所考虑的<strong>函数越丰富，(一般来说)其拟合能力越好,但更容易过拟合</strong><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638984.png" alt=""></p><h4 id="岭回归"><a href="#岭回归" class="headerlink" title="岭回归"></a>岭回归</h4><p><strong>解决了回归分析中的过度拟合问题</strong>。通过<strong>增加惩罚项</strong>来破坏训练点的拟合来最小化泛化误差。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638985.png" alt=""><br>$min_\beta\quad\sum_i|y_i-f(x_i)|^2+\alpha|\beta|^2$<br>缩放常数$\alpha&gt;0$用来控制这种权衡<br><strong>较小的</strong>$\alpha$<strong>值</strong>，将导致<strong>较高的范数权重</strong>并<strong>过度拟合训练数据点</strong>。<br>$\alpha$值较小，正则化项权重较小，意味着对回归系数$\beta$的惩罚较小。<br>模型可以选择较大的回归系数$\beta$(即较高的范数权重)，从而更加精细地拟合训练数据。<br>但是可能会出现过拟合，可能泛化能力较差<br><strong>较大的</strong>$\alpha$<strong>值</strong>，将导致函数与训练数据点<strong>拟合较差</strong>，但<strong>权重范数非常小</strong>。<br>$\alpha$值较大，正则化项权重较大，意味着对回归系数$\beta$的惩罚较大<br>模型会倾向于选择较小的回归系数$\beta$(较低的范数权重)，从而简化模型。<br>模型可能无法很好地拟合训练数据，由于模型较为简单，泛化能力较好，不容易过度拟合。</p><h4 id="LASSO回归"><a href="#LASSO回归" class="headerlink" title="LASSO回归"></a>LASSO回归</h4><p>与岭回归类似，都是<strong>防止训练数据点过度拟合的正则化器</strong>。<br>LASSO<strong>强制学习权重的稀疏性</strong><br>$min_\beta\quad\sum_i|y_i-f(x_i)|^2+\alpha|\beta|_1$<br>常数$\alpha$&gt;0用来控制学习权重的拟合度和稀疏度之间的权衡<br><strong>较小的</strong>$\alpha$<strong>值</strong>会导致训练数据点紧密拟合 <strong>(可能导致过度拟合)</strong>，但<strong>权重集较少稀疏</strong><br>$\alpha$值较小，对回归系数的惩罚较轻，更多的回归系数$\beta$会非零，模型会包含更多的特征<br><strong>较大的</strong>$\alpha$<strong>值</strong>会导致<strong>拟合效果不佳</strong>，但学习到的<strong>权重集会更稀疏</strong><br>$\alpha$值较大，对回归系数的惩罚较重，许多回归系数$\beta$会被压缩为0，导致模型变得稀疏，只包含少量重要特征。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638986.png" alt=""></p><h4 id="ElasticNet回归"><a href="#ElasticNet回归" class="headerlink" title="ElasticNet回归"></a>ElasticNet回归</h4><p><strong>岭回归和LASSO回归的组合</strong>。<strong>损失项包括权重的L1和L2范数</strong>及其各自的缩放常数。<br>通过用于解决LASSO回归的局限性，例如非凸性质<br>ElasticNet添加了权重的二次惩罚，使其主要是凸的<br>$min_\beta\quad\sum_i|y_i-f(x_i)|^2+\alpha_1|\beta|_1+\alpha_2|\beta|^2$</p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638987.png" alt=""></p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>含有多个特征的线性回归为多元线性回归<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638988.png" alt=""><br><strong>损失函数采用平方和损失</strong><br>$l(x^{(i)})=\frac12(h(x^{(i)})-y^{(i)})^2$<br>要找到一组w(w0,w1,w2….wn)使得残差平方和最小<br>$J(w)=\frac{1}{2}\sum_{i=1}^{m}(h(x^{(i)})-y^{(i)})^{2}$<br>上述公式到的系数1/2是为了便于计算，不影响结果。</p><p><strong>损失函数(Loss Function)</strong><br>度量<strong>单样本预测的错误程度</strong>，损失函数值越小，模型就越好。<br>常用的损失函数包括:0-1损失函数、平方损失函数、绝对损失函数、对数损失函数</p><p><strong>代价函数(Cost Function)</strong><br>度量<strong>全部样本集的平均误差</strong>。<br>常用的代价函数包括均方误差、均方根误差、平均绝对误差等。</p><p><strong>目标函数(Object Function)</strong><br><strong>代价函数和正则化函数</strong>，最终要优化的函数。</p><h3 id="最小二乘法-LSM"><a href="#最小二乘法-LSM" class="headerlink" title="最小二乘法(LSM)"></a>最小二乘法(LSM)</h3><p>在线性回归中，最小二乘法的目标是<strong>使预测值与实际值的残差的平方和最小化</strong>。<br><strong>正规方程：通过对损失函数的偏导数等于0来求解线性回归模型参数的解析解。</strong><br>线性回归的损失函数，其正规方程：<br>$w=\begin{pmatrix}X^TX\end{pmatrix}^{-1}X^TY$</p><p>证明<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638989.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638990.png" alt=""><br>正规方程的求解涉及矩阵的求逆运算，因此当特征矩阵$X^TX$可逆时，可以得到唯一解。<br>如果特征矩阵不可逆，或者计算代价较高，考虑其他优化算法，若梯度下降法。</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>用于求解线性和非线性模型最优解的迭代算法，不端迭代计算函数的梯度，调整使得目标函数最小化的权重。<br>作用是优化目标函数，<br>如果要最小化一个损失函数，使用梯度下降法。<br>如果要最大化一个效用函数，使用梯度上升法。</p><h4 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638991.png" alt=""></p><h4 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638992.png" alt=""></p><h4 id="方向导数"><a href="#方向导数" class="headerlink" title="方向导数"></a>方向导数</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638993.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638994.png" alt=""></p><h3 id="梯度下降的图示"><a href="#梯度下降的图示" class="headerlink" title="梯度下降的图示"></a>梯度下降的图示</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638995.png" alt=""></p><h3 id="梯度下降的三种形式"><a href="#梯度下降的三种形式" class="headerlink" title="梯度下降的三种形式"></a>梯度下降的三种形式</h3><h4 id="批量梯度下降-Batch-Gradient-Descent-BGD"><a href="#批量梯度下降-Batch-Gradient-Descent-BGD" class="headerlink" title="批量梯度下降(Batch Gradient Descent,BGD)"></a>批量梯度下降(Batch Gradient Descent,BGD)</h4><p>梯度下降的每一步中，都用到了<strong>所有的训练样本</strong><br>参数更新公式<br>$\begin{aligned}&amp;w_{j}{:}=w_{j}-\alpha\frac{1}{m}\sum_{i=1}^{m}\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right)\cdot x_{j}^{(i)}\right)\\&amp;(\text{同步更新}w_{j},(j=0,1,…,n))\end{aligned}$<br>证明<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638996.png" alt=""></p><h4 id="随机梯度下降-Stochastic-Gradient-Descent-SGD"><a href="#随机梯度下降-Stochastic-Gradient-Descent-SGD" class="headerlink" title="随机梯度下降(Stochastic Gradient Descent,SGD)"></a>随机梯度下降(Stochastic Gradient Descent,SGD)</h4><p>梯度下降的每一步中，用到<strong>一个样本</strong>，在每一次计算之后便更新参数，而不需要首先将所有的训练集求和<br>参数更新</p><script type="math/tex; mode=display">w_{j}{:}=w_{j}-\alpha\big(h\big(x^{(i)}\big)-y^{(i)}\big)x_{j}{}^{(i)}\\(\text{同步更新}w_{j},(j=0,1,...,n))</script><h4 id="小批量梯度下降-Mini-Batch-Gradient-Descent-MBGD"><a href="#小批量梯度下降-Mini-Batch-Gradient-Descent-MBGD" class="headerlink" title="小批量梯度下降(Mini-Batch Gradient Descent,MBGD)"></a>小批量梯度下降(Mini-Batch Gradient Descent,MBGD)</h4><p>梯度下降的每一步中，用到了<strong>一定批量的训练样本</strong></p><p>例如每计算b次训练实例，便更新一次参数w,通常是2的指数倍，常见有32,64,128等</p><script type="math/tex; mode=display">\begin{aligned}&w_{j}{:}=w_{j}-\alpha\frac{1}{b}\sum_{k=i}^{i+b-1}\left(h\left(x^{(k)}\right)-y^{(k)}\right)x_{j}^{(k)}\\&(\text{同步更新}w_{j},(j=0,1,...,n))\end{aligned}</script><h3 id="梯度下降与最小二乘法比较"><a href="#梯度下降与最小二乘法比较" class="headerlink" title="梯度下降与最小二乘法比较"></a>梯度下降与最小二乘法比较</h3><h4 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>需要选择学习率$\alpha$；<br>$\alpha$需要多次迭代；<br>当特征数量n大时也能较好适用；<br>适用于各种类型的模型；</p><h4 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h4><p>不要选择学习率；<br>一次计算得出；<br>需要计算正规方程，如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为𝑂(n^3)，通常来说当n小于10000 时还是可以接受的；<br>只适用于线性模型，不适合逻辑回归模型等其他模型。 </p><h3 id="数据归一化-标准化"><a href="#数据归一化-标准化" class="headerlink" title="数据归一化/标准化"></a>数据归一化/标准化</h3><h4 id="为什么要标准化-归一化"><a href="#为什么要标准化-归一化" class="headerlink" title="为什么要标准化/归一化"></a>为什么要标准化/归一化</h4><p>提高模型精度:  不同维度之间的特征在数值上有一定比较性，可以大大提高分类器的准确性。<br>加速模型收敛：最优解的寻优过程明显会变得平缓，更容易正确的收敛到最优解</p><h4 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h4><p>数据映射到[0,1]区间<br>$x^{\ast}=\frac{x-x_{\min}}{x_{\max}-x_{\min}}$<br>归一化的目的是使得各特征对目标变量的影响一致，会使特征数据进行伸缩变化，所以数据归一化是会改变特征数据分布的。</p><h4 id="Z-Score标准化"><a href="#Z-Score标准化" class="headerlink" title="Z-Score标准化"></a>Z-Score标准化</h4><p>处理后的数据均值为0,方差为1<br>$x^\ast=\frac{x-\mu}{\sigma}$<br>$\sigma^{2}=\frac{1}{m}\sum_{i=1}^{m}(x^{(i)}-\mu)^{2}\\\mu=\frac{1}{m}\sum_{i=1}^{m}x^{(i)}$</p><p>为了不同特征之间具备可比性，经过标准化变化之后的特征数据分布没有发生改变。<br>当数据特征取值范围或单位差异较大时，最好是做一下标准化处理。 </p><h4 id="什么时候需要数据归一化-标准化"><a href="#什么时候需要数据归一化-标准化" class="headerlink" title="什么时候需要数据归一化/标准化"></a>什么时候需要数据归一化/标准化</h4><p><strong>线性模型</strong>，如基于距离度量的模型包括KNN(K近邻)、K-means聚类、感知机和SVM。<br>另外，线性回归类的几个模型一般情况下也是需要做数据归一化/标准化处理的 </p><h4 id="什么时候不需要做数据归一化-标准化"><a href="#什么时候不需要做数据归一化-标准化" class="headerlink" title="什么时候不需要做数据归一化/标准化"></a>什么时候不需要做数据归一化/标准化</h4><p><strong>决策树</strong>、基于决策树的Boosting和Bagging等集成学习模型<strong>对于特征取值大小</strong>并不敏感，如随机森林、XGBoost、LightGBM等树模型，以及朴素贝叶斯</p><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><h3 id="过拟合和欠拟合"><a href="#过拟合和欠拟合" class="headerlink" title="过拟合和欠拟合"></a>过拟合和欠拟合</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638997.png" alt=""></p><h3 id="过拟合的处理"><a href="#过拟合的处理" class="headerlink" title="过拟合的处理"></a>过拟合的处理</h3><h4 id="获得更多的训练数据"><a href="#获得更多的训练数据" class="headerlink" title="获得更多的训练数据"></a>获得更多的训练数据</h4><p><strong>解决过拟合问题最有效的手段</strong>，因为更多的样本能够让模型学习到更多更有效的特征，减小噪声的影响。 </p><h4 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h4><p>即丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如PCA） </p><h4 id="正则化-1"><a href="#正则化-1" class="headerlink" title="正则化"></a>正则化</h4><p>正则化(regularization)的技术，<strong>保留所有的特征，但是减少参数的大小(magnitude)，它可以改善或者减少过拟合问题</strong></p><h4 id="集成学习方法"><a href="#集成学习方法" class="headerlink" title="集成学习方法"></a>集成学习方法</h4><p>把多个模型集成在一起，来降低单一模型的过拟合风险 </p><h3 id="欠拟合的处理"><a href="#欠拟合的处理" class="headerlink" title="欠拟合的处理"></a>欠拟合的处理</h3><h4 id="添加新特征"><a href="#添加新特征" class="headerlink" title="添加新特征"></a>添加新特征</h4><p><strong>当特征不足或者现有特征与样本标签的相关性不强时</strong>，模型容易出现欠拟合。通过挖掘组合特征等新的特征，往往能够取得更好的效果 </p><h4 id="增加模型复杂度"><a href="#增加模型复杂度" class="headerlink" title="增加模型复杂度"></a>增加模型复杂度</h4><p>例如，在线性模型中添加高次项，在神经网络模型中增加网络层数或神经元个数等</p><h4 id="减小正则化系数"><a href="#减小正则化系数" class="headerlink" title="减小正则化系数"></a>减小正则化系数</h4><p>正则化是用来防止过拟合的，但当模型出现欠拟合现象时，则需要有针对性地减小正则化系数。 </p><h3 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h3><h4 id="L1正则化"><a href="#L1正则化" class="headerlink" title="L1正则化"></a>L1正则化</h4><p>$J(w)=\frac{1}{2}\sum_{i=1}^{m}(h(x^{(i)})-y^{(i)})^{2}+\lambda\sum_{j=1}^{n}|w_{j}|$<br>LASSO回归使用</p><h4 id="L2正则化"><a href="#L2正则化" class="headerlink" title="L2正则化"></a>L2正则化</h4><p>$J(w)=\frac{1}{2}\sum_{i=1}^{m}(h(x^{(i)})-y^{(i)})^{2}+\lambda\sum_{j=1}^{n}w_{j}^{2}$<br>岭回归使用</p><h4 id="ElasticNet"><a href="#ElasticNet" class="headerlink" title="ElasticNet"></a>ElasticNet</h4><p>$J(w)=\frac{1}{2}\sum_{i=1}^{m}(h(x^{(i)})-y^{(i)})^{2}+\lambda(\rho\cdot\sum_{j=1}^{n}|w_{j}|+(1-\rho)\cdot\sum_{j=1}^{n}w_{j}^{2})$<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638998.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638999.png" alt=""><br>图上面中的蓝色轮廓线是没有正则化损失函数的等高线，中心的蓝色点为最优解<br> L1正则化给出的最优解$w^\ast$是使解更加靠近某些轴,而其它的轴则为0,所以L1正则化能使得到的参数稀疏化。<br> L2正则化给出的最优解$w^\ast$是使解更加靠近原点,也就是说L2正则化能降低参数范数的总和。 </p><h2 id="回归的评价指标"><a href="#回归的评价指标" class="headerlink" title="回归的评价指标"></a>回归的评价指标</h2><h3 id="均方误差-Mean-Square-Error-MSE"><a href="#均方误差-Mean-Square-Error-MSE" class="headerlink" title="均方误差(Mean Square Error,MSE)"></a>均方误差(Mean Square Error,MSE)</h3><p>$\mathrm{MSE}=\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}-\widehat{y}^{(i)})^{2}$</p><h3 id="均方根误差-Root-Mean-Square-Error，RMSE"><a href="#均方根误差-Root-Mean-Square-Error，RMSE" class="headerlink" title="均方根误差(Root Mean Square Error，RMSE)"></a>均方根误差(Root Mean Square Error，RMSE)</h3><p>$\mathrm{RMSE}(y,\widehat{y})=\sqrt{\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}-\widehat{y}^{(i)})^{2}}$</p><h3 id="平均绝对误差"><a href="#平均绝对误差" class="headerlink" title="平均绝对误差"></a>平均绝对误差</h3><p>$\mathrm{MAE}(y,\widehat{y})=\frac{1}{m}\sum_{i=1}^{m}\bigl|y^{(i)}-\widehat{y}^{(i)}\bigr|$</p><h3 id="R方-𝑅𝑆𝑞𝑢𝑎𝑟𝑒𝑑-𝑟2𝑠𝑐𝑜𝑟𝑒"><a href="#R方-𝑅𝑆𝑞𝑢𝑎𝑟𝑒𝑑-𝑟2𝑠𝑐𝑜𝑟𝑒" class="headerlink" title="R方[𝑅𝑆𝑞𝑢𝑎𝑟𝑒𝑑(𝑟2𝑠𝑐𝑜𝑟𝑒)]"></a>R方[𝑅𝑆𝑞𝑢𝑎𝑟𝑒𝑑(𝑟2𝑠𝑐𝑜𝑟𝑒)]</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406101638000.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 回归分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 绪论</title>
      <link href="/2024/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E7%BB%AA%E8%AE%BA/"/>
      <url>/2024/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="机器学习范畴和定义"><a href="#机器学习范畴和定义" class="headerlink" title="机器学习范畴和定义"></a>机器学习范畴和定义</h2><p>范围从小到大<br>深度学习&lt;——表征学习&lt;——机器学习&lt;——人工智能<br>人工智能:机器展示的人类智能<br>机器学习:计算机利用已有的数据(经验)，得出某种模型，最终形成能够解决问题的方法<br>表征学习:将原始的数据转化成更容易被机器学习应用的数据的过程<br>深度学习:实现机器学习的一种技术</p><h2 id="机器学习相关学科"><a href="#机器学习相关学科" class="headerlink" title="机器学习相关学科"></a>机器学习相关学科</h2><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011732764.png" alt=""></p><h2 id="机器学习类型"><a href="#机器学习类型" class="headerlink" title="机器学习类型"></a>机器学习类型</h2><p>监督学习，半监督学习，无监督学习，强化学习，深度学习，迁移学习</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>通过与环境的交互学习策略以最大化奖励，强调在特定环境中的行为学习。</p><h3 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h3><p>通过在一个任务或领域中学到的知识帮助在另一个任务或领域中进行学习，强调知识的迁移和重用。</p><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>使用带标签的数据集来训练算法，目的是对数据进行分类或预测<br>分类问题<br>身高1.65m，体重100kg的男人肥胖吗？<br>回归问题<br>如何预测上海浦东的房价？ </p><h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>使用不带标签的数据集来训练算法，目的是从数据中提取有意思的模式或结构，而不是依赖预先设定的标签或结果。<br>聚类问题<br>如何将教室里的学生按爱好、身高划分为5类？<br>降维<br>如何将原高维空间中的数据点映射到低维度的空间中？ </p><p>机器学习能解决什么————给定数据的预测问题<br>数据清洗/特征选择<br>确定算法模型/参数优化<br>结果预测</p><p>不能解决什么<br>大数据存储/并行计算<br>做一个机器人</p><h2 id="机器学习的一般步骤"><a href="#机器学习的一般步骤" class="headerlink" title="机器学习的一般步骤"></a>机器学习的一般步骤</h2><p>数据搜集——数据清洗——特征工程——数据建模<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011732765.png" alt=""></p><h2 id="机器学习重要元素——数据"><a href="#机器学习重要元素——数据" class="headerlink" title="机器学习重要元素——数据"></a>机器学习重要元素——数据</h2><p>成功的机器学习应用不是拥有最好的算法，而是拥有最多的数据。</p><h2 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>概率模型和非概率模型<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011732766.png" alt=""></p><p>监督学习中<br>概率模型可以表示为<br>$P(y|x)$<br>非概率模型则为<br>$y=f(x)$<br>其中，x是输入，y是输出</p><p>无监督学习中<br>概率模型可以表示为<br>$P(z|x)或者P(x|z)$<br>非概率论模型则为<br>$z=g(x)$<br>其中，x是输入，y是输出</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>常见损失函数<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011732767.png" alt=""><br>损失函数值越小，模型性能越好<br>经验风险: 训练数据集的平均损失<br>基于经验风险最小化原则，构建全局损失函数最优化问题<br>$\min_f\frac{1}{N}\sum_{n=1}^NL(y_n,f(x_n))$<br>求得使全局损失函数最小的模型<br><strong>当样本数量足够大时，根据大数定理，经验风险会近似于模型的期望风险</strong>。此时，经验风险最小化能确保有好的学习性能。当样本数量不足时候，单单利用经验风险最小化可能会导致”过拟合”问题。<br>个人理解:过拟合一般模型都会很复杂,所以引入结构最小化准则来平衡数据量与模型复杂量.<br>在原有基础上加上用于控制模型复杂度的正则项(Regularizer)，得到<strong>结构最小化准则</strong>。具体定义<br>$\min_f[\frac{1}{N}\sum_{n=1}^NL(y_n,f(x_n))+\lambda\times J(f)]$<br>模型越复杂，𝐽(𝑓)越大，模型越简单，𝐽(𝑓)就越小 .<br>𝜆是一个正的常数，也叫<strong>正则化系数</strong>，用于平衡经验风险和模型复杂度。<br> 一般来说,结构风险小的模型需要经验风险和模型复杂度同时小,因此对训练数据和测试数据都能有较好的拟合.</p><h3 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h3><p>算法：模型学习中的具体计算方法<br>基于参数模型构建的统计学习问题都为最优化问题,都具有显式的解析解<br>现有的优化方法主要有:梯度下降法、牛顿法、拟牛顿法、ADAM等等</p><h3 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h3><p>当损失函数给定时，我们将基于模型训练数据的误差和测试数据的误差作为模型评估的标准<br>测试误差的具体定义<br>$E_{test}=\frac{1}{N^{\prime}}\sum_{n=1}^{N^{\prime}}L\left(y_{n},\hat{f}(x_{n})\right)$<br>$N^{\prime}$为测试数据数量，$L\left(y_{n},\hat{f}(x_{n})\right)$是损失函数，$y_n$代表真实标签，$\hat{f}(x_{n})$代表预测标签。<br>若模型学习的效果好，则训练误差和测试误差接近一致 </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章_二叉树_part02</title>
      <link href="/2024/06/01/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%BA%8C%E5%8F%89%E6%A0%91_part02/"/>
      <url>/2024/06/01/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%BA%8C%E5%8F%89%E6%A0%91_part02/</url>
      
        <content type="html"><![CDATA[<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>层序遍历一个二叉树，从左到右一层一层的去遍历二叉树。使用先进先出的对列，类似图论中广度优先遍历。</p><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">102.二叉树的层序遍历</a></h3><p>使用队列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用递归法<br>使用了先序遍历，先序遍历处理的是中间结点，按照深度，push_back的指定vector<int>中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp;res,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>()==depth)res.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        res[depth].<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)<span class="built_in">order</span>(cur-&gt;left,res,depth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)<span class="built_in">order</span>(cur-&gt;right,res,depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">order</span>(root,res,depth);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="107-二叉树的层序遍历II"><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">107.二叉树的层序遍历II</a></h3><p>题目重述<br>给定二叉树的根节点root，返回其节点值自底向上的层序遍历<br>思路<br>层数遍历后，将vector<vector<int>&gt;res,reverse(res.begin(),res.end());<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode*cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/">199.二叉树的右视图</a></h3><p>题目重述<br>给定一二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值<br>思路<br>层数遍历，输出每一层的最后一个节点<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size= q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode*cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==size<span class="number">-1</span>)res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="637-二叉树的层平均数"><a href="#637-二叉树的层平均数" class="headerlink" title="637.二叉树的层平均数"></a><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/">637.二叉树的层平均数</a></h3><p>题目重述<br>给定一个非空二叉树根节点root，以数组的形式返回没一层的平均值。<br>思路<br>层次遍历中，将每个节点加sum，再裘平均值<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt;res;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">double</span> sum =<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                sum+=cur-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(sum/size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a><a href="">429.N叉树的层序遍历</a></h3><p>题目重述<br>给定一个N叉树，返回其节点的层序遍历<br>思路<br>vector<Node*> children;遍历所以得children节点，而不是仅仅left和right<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(Node* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        queue&lt;Node*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">            <span class="type">int</span> size =q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node*cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cur-&gt;children.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;children[i])q.<span class="built_in">push</span>(cur-&gt;children[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="515-在每个树行中找最大值"><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/">515.在每个树行中找最大值</a></h3><p>题目重述<br>给定一二叉树的根节点root，找出该二叉树每一层的最大值<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> maxNum=INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode*cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                maxNum=maxNum&gt;cur-&gt;val?maxNum:cur-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/">116.填充每个节点的下一个右侧节点指针</a><br>题目重述<br>有个完美二叉树，所有叶子结点都在同一层，每个父节点都有两个子节点。二叉树定义如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>填充next指针，使该指针指向下一个右侧节点，如果找不到右侧节点，next指针设置为null<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011344603.png" alt="image.png"><br>返回填充next后的根节点</p><p>思路<br>填充每个节点net指针为右侧节点，使用层次遍历<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==size<span class="number">-1</span>)cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next=q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/">117.填充每个节点的下一个右侧节点指针II</a><br>题目重述<br>和上一题差不多，但不在有满二叉树这个条件<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;Node*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                Node* cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i==size<span class="number">-1</span>)cur-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">else</span> cur-&gt;next=q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">104.二叉树的最大深度</a></h3><p>题目重述<br>给定一个二叉树(root)，返回最大深度<br>思路<br>首先想法是层次遍历，每次for循环完后，然后cnt++。<br>第二个想法是直接递归<br>处理参数当前树节点cur，返回参数当前树节点所在的深度int<br>递归出口<br>if(cur==nullptr)return 0;<br>处理逻辑<br>当前树节点的深度等于左子树和右子树的深度的最大值，然后再+1；<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">depth</span>(cur-&gt;left),<span class="built_in">depth</span>(cur-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">depth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode*cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">111.二叉树的最小深度</a></h3><p>题目重述<br>给定一个二叉树的最小深度，最小深度是从根节点到最近子节点的最短路径上的节点数量<br>思路<br>使用递归法<br>处理参数和返回参数<br>为当前树节点cur，返回参数当前树节点所在的最小深度int<br>递归出口<br>if(cur==nullptr)return 0;<br>处理逻辑<br>当前树节点的深度等于左子树和右子树的深度的最小值，然后再+1；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode*cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depthLeft,depthRight;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left==<span class="literal">nullptr</span>&amp;&amp;cur-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left) depthLeft=<span class="built_in">depth</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)depthRight=<span class="built_in">depth</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(depthLeft,depthRight)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">depth</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">int</span> depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(!cur-&gt;left&amp;&amp;!cur-&gt;right)<span class="keyword">return</span> depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/description/">226.翻转二叉树</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>给你一颗二叉树的根节点root，翻转这颗二叉树，并返回其根节点<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011344604.png" alt="image.png"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用swap直接交换左右节点指针，这样更加简单，而不是仅仅交换值。<br>使用递归的方法，可以使用前序遍历和后序遍历，不能使用中序遍历<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011344605.jpg" alt="IMG_20240601_100831.jpg"><br>打算使用栈来做，应用2-7,7-2符合先进后出的特点<br>或者使用递归的方法</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>递归<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseTree</span><span class="params">(TreeNode*cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">swap</span>(cur-&gt;left,cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;left)<span class="built_in">reverseTree</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;right)<span class="built_in">reverseTree</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverseTree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>层序遍历<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt;q;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode*cur=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left,cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101.对称二叉树</a></h2><h3 id="题目重述-1"><a href="#题目重述-1" class="headerlink" title="题目重述"></a>题目重述</h3><p>给你一个二叉树的根节点root，检查它是否轴对称</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>层次遍历，判断每一层是否都是对称的</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>迭代法<br>错误代码，下面的代码，无法判断是左节点的值，还是有节点的值<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202406011344606.png" alt="image.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode*cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;<span class="built_in">temp</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">            <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(temp!=res) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br> 错误原因，因为我使用层序遍历模版时，只将非空的节点数放入队列中，对于左右子节点等于nullptr的节点无法识别。<br>解决办法，对于空节点数也放入队列中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        q.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode*left=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode*right=q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="literal">nullptr</span>&amp;&amp;right==<span class="literal">nullptr</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="literal">nullptr</span>||right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val!=right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            q.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            q.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用栈也是可以的。但是不一定一层一层开始比较是否对称的。</p><p>递归法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode*left,TreeNode*right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span>&amp;&amp;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span>||right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (left-&gt;val==right-&gt;val)&amp;&amp;<span class="built_in">isMirror</span>(left-&gt;left,right-&gt;right)&amp;&amp;<span class="built_in">isMirror</span>(left-&gt;right,right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isMirror</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a><a href="https://leetcode.cn/problems/same-tree/description/">100.相同的树</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left,q-&gt;left)&amp;&amp;<span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="572-另外一个树的子树"><a href="#572-另外一个树的子树" class="headerlink" title="572.另外一个树的子树"></a><a href="https://leetcode.cn/problems/subtree-of-another-tree/">572.另外一个树的子树</a></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSametree</span><span class="params">(TreeNode*left,TreeNode*right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span>&amp;&amp;right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">nullptr</span>||right==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSametree</span>(left-&gt;left,right-&gt;left)&amp;&amp;<span class="built_in">isSametree</span>(left-&gt;right,right-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isSametree</span>(root,subRoot))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSubtree</span>(root-&gt;left,subRoot)||<span class="built_in">isSubtree</span>(root-&gt;right,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL标准模板库</title>
      <link href="/2024/05/29/C++%20STL%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93/"/>
      <url>/2024/05/29/C++%20STL%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h2><h3 id="STL组件-容器、算法、迭代器"><a href="#STL组件-容器、算法、迭代器" class="headerlink" title="STL组件:容器、算法、迭代器"></a>STL组件:容器、算法、迭代器</h3><p>容器：容纳各种数据类型的数据结构<br>迭代器：可依次存取容器中的元素，类似指针（对象指针）<br>算法：用来操作容器中的元素的函数模板,sort(),copy(),find(),count().<br>函数对象：行为类似函数的对象，用来传给通用算法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>       <span class="comment">//向量头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  vector&lt;string&gt; Food;                             </span><br><span class="line">  vector&lt;string&gt;::iterator  FoodIterator;   </span><br><span class="line">  Food.<span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),<span class="string">&quot;---食物清单---&quot;</span>); </span><br><span class="line">  Food.<span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),<span class="string">&quot;   牛奶&quot;</span>); </span><br><span class="line">  Food.<span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),<span class="string">&quot;   蓝莓&quot;</span>); </span><br><span class="line">  Food.<span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),<span class="string">&quot;   香蕉&quot;</span>); </span><br><span class="line">  Food.<span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),<span class="string">&quot;   牛油果&quot;</span>); </span><br><span class="line">  Food.<span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (FoodIterator=Food.<span class="built_in">begin</span>(); FoodIterator!=Food.<span class="built_in">end</span>(); ++FoodIterator)</span><br><span class="line">  &#123;  cout &lt;&lt; *FoodIterator &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">insert</span>(Food.<span class="built_in">end</span>(),..) 往向量尾部插入一个元素</span><br><span class="line">Food.<span class="built_in">begin</span>() 头部迭代器</span><br><span class="line">Food.<span class="built_in">end</span> ()尾部迭代器</span><br><span class="line">*FoodIterator 输出迭代器指向的元素</span><br><span class="line">iterator  迭代器</span><br><span class="line">FoodIterator 迭代器变量</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span>      <span class="comment">//链表头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">//算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintLine</span> <span class="params">(string&amp; StringLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;  cout &lt;&lt; StringLine &lt;&lt; endl; &#125; </span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span> <span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123; list&lt;string&gt; Food;</span><br><span class="line">   Food.<span class="built_in">push_back</span>(<span class="string">&quot;---食物清单---&quot;</span>);</span><br><span class="line">   Food.<span class="built_in">push_back</span>(<span class="string">&quot;    牛奶&quot;</span>);</span><br><span class="line">   Food.<span class="built_in">push_back</span>(<span class="string">&quot;    蓝莓&quot;</span>);</span><br><span class="line">   Food.<span class="built_in">push_back</span>(<span class="string">&quot;    香蕉&quot;</span>);</span><br><span class="line">   Food.<span class="built_in">push_back</span>(<span class="string">&quot;    牛油果&quot;</span>);</span><br><span class="line">   Food.<span class="built_in">push_back</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">   for_each  (Food.<span class="built_in">begin</span>(), Food.<span class="built_in">end</span>(), PrintLine);</span><br><span class="line">&#125;</span><br><span class="line">for_each(….)是STL中遍历算法,</span><br><span class="line">PrintLine是前面定义的函数作为函数对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遍历容器元素的数据结构<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(fooditerator=food.<span class="built_in">begin</span>();fooditerator!=food.<span class="built_in">end</span>();fooditerator++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*fooditerator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size=food.<span class="built_in">size</span>()</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;food.<span class="built_in">at</span>(i);</span><br><span class="line">    cout&lt;&lt;food[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>STL容器分为三类<br>顺序容器：<br>元素的插入位置同元素的值无关。<br>向量(vector),链表(list),双端队列(deque)</p><p>关联容器：<br>元素是排序的，插入元素，按相应排序准则来确定位置<br>集合(set)，多重集合(multiset)，映射(map),多重映射(multimap)</p><p>容器适配器<br>顺序容器的基础上，增加行为规范(如后进后出，先进先出)<br>顺序容器基础上，增加行为规范(如后进先出、先进先出)<br>堆栈(stack)和队列(queue)</p><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><p>1 vector 头文件<vector><br>插入或删除数据时，能够自动扩展和压缩其大小的动态数组。随机存取任何元素都能在常数时间完成。在尾端增删元素具有最佳性能<br>2 deque 头文件<deque><br>动态数组，随机存取任何元素都能在常数时间完成(性能次于vector)。在两端增删元素具有较佳的性能<br>3 list 头文件<list><br>双向链表，在任何位置增删元素都能在常数时间完成。不支持随机存取<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; number;</span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">number.<span class="built_in">insert</span>(number.<span class="built_in">begin</span>(),<span class="number">99</span>);</span><br><span class="line">number.<span class="built_in">insert</span>(number.<span class="built_in">end</span>(),<span class="number">97</span>);  </span><br><span class="line">number.<span class="built_in">push_back</span>(<span class="number">97</span>);</span><br><span class="line"><span class="comment">//擦掉元素</span></span><br><span class="line">number.<span class="built_in">erase</span>(number.<span class="built_in">begin</span>());  </span><br><span class="line">number.<span class="built_in">erase</span>(number.<span class="built_in">end</span>());</span><br><span class="line">number.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;number.<span class="built_in">size</span>();i++)</span><br><span class="line">    <span class="comment">//cout&lt;&lt;number.at(i)&lt;&lt;endl</span></span><br><span class="line">    cout&lt;&lt;number[i]&lt;&lt;endl;   <span class="comment">//number[i] 下标访问第i个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = number.<span class="built_in">begin</span>(); iter != number.<span class="built_in">end</span>();iter++ )</span><br><span class="line">   cout &lt;&lt; *theIterator;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">number</span><span class="params">(<span class="number">5</span>,<span class="number">99</span>)</span></span>;         <span class="comment">//向量存5个99(vector元素大小，元素的值)</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">number1</span>(number);   <span class="comment">//向量拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(number.<span class="built_in">begin</span>(), number.<span class="built_in">end</span>()); <span class="comment">//sort()排序算法   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;number;</span><br><span class="line">number.<span class="built_in">reverse</span>()<span class="comment">//逆转</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num =<span class="built_in">count</span>(Scores.<span class="built_in">begin</span>(), Scores.<span class="built_in">end</span>(), <span class="number">100</span>);<span class="comment">//count()算法统计list中100出现个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">const</span> string <span class="title">FlashDriveCode</span><span class="params">(<span class="string">&quot;0003&quot;</span>)</span></span>;  </span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IsAFlashDrive</span></span><br><span class="line">&#123; <span class="keyword">public</span>: </span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( string&amp; SalesRecord )</span></span></span><br><span class="line"><span class="function">     </span>&#123;  <span class="keyword">return</span> SalesRecord.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">4</span>)==FlashDriveCode;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; list&lt;string&gt; SalesRecords;</span><br><span class="line">   SalesRecords.<span class="built_in">insert</span>(SalesRecords.<span class="built_in">begin</span>(),<span class="string">&quot;0001 4GB&quot;</span>);</span><br><span class="line">   SalesRecords.<span class="built_in">insert</span>(SalesRecords.<span class="built_in">begin</span>(),<span class="string">&quot;0003 16GB&quot;</span>);</span><br><span class="line">   SalesRecords.<span class="built_in">insert</span>(SalesRecords.<span class="built_in">begin</span>(),<span class="string">&quot;0002 8GB&quot;</span>);</span><br><span class="line">   SalesRecords.<span class="built_in">insert</span>(SalesRecords.<span class="built_in">begin</span>(),<span class="string">&quot;0003 16GB&quot;</span>);</span><br><span class="line">   SalesRecords.<span class="built_in">insert</span>(SalesRecords.<span class="built_in">begin</span>(),<span class="string">&quot;0004 64GB&quot;</span>);</span><br><span class="line">   SalesRecords.<span class="built_in">insert</span>(SalesRecords.<span class="built_in">begin</span>(),<span class="string">&quot;0003 16GB&quot;</span>);</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">NumberOfFlashDrives</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   NumberOfFlashDrives=<span class="built_in">count_if</span> (SalesRecords.<span class="built_in">begin</span>(), SalesRecords.<span class="built_in">end</span>(), </span><br><span class="line">   <span class="built_in">IsAFlashDrive</span>());</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;卖出16GB U 盘 &quot;</span> &lt;&lt; NumberOfFlashDrives &lt;&lt;<span class="string">&quot;个&quot;</span>&lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">count_if</span>(…, 函数对象)当函数对象返回真，计数值+<span class="number">1</span></span><br><span class="line">IsAFlashDrivele类重载了<span class="built_in">operator</span>(), 类实例可以作为函数对象，功能就是<span class="built_in">operator</span>()的函数行为</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>               </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;                        </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span> <span class="params">( )</span>                                    </span></span><br><span class="line"><span class="function"></span>&#123;list&lt;<span class="type">char</span>&gt; TargetCharacters;          </span><br><span class="line">  list&lt;<span class="type">char</span>&gt; ListOfCharacters;                  </span><br><span class="line">  TargetCharacters.<span class="built_in">push_back</span>(<span class="string">&#x27;l&#x27;</span>);  </span><br><span class="line">  TargetCharacters.<span class="built_in">push_back</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">  ListOfCharacters.<span class="built_in">push_back</span>(<span class="string">&#x27;i&#x27;</span>);</span><br><span class="line">  ListOfCharacters.<span class="built_in">push_back</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">  ListOfCharacters.<span class="built_in">push_back</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">  ListOfCharacters.<span class="built_in">push_back</span>(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">  list&lt;<span class="type">char</span>&gt;::iterator PositionOfNulls = <span class="built_in">search</span>(ListOfCharacters.<span class="built_in">begin</span>(), </span><br><span class="line">          ListOfCharacters.<span class="built_in">end</span>(), TargetCharacters.<span class="built_in">begin</span>(), TargetCharacters.<span class="built_in">end</span>());</span><br><span class="line">   <span class="comment">//search()在一个序列里寻找另外一个序列第一次出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PositionOfNulls!=ListOfCharacters.<span class="built_in">end</span>())</span><br><span class="line">    cout&lt;&lt; <span class="string">&quot;找到! &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cout&lt;&lt; “没找到! <span class="string">&quot; &lt;&lt; endl;   </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h3><p>1 stack： 头文件<stack><br>栈是顶的有限序列。后进先出：被删除、检索和修改的项只能是最近插入的项(栈顶)</p><p>2 queue: 头文件<queue><br>插入只可以在尾部进行：删除、检索和修改只允许从头部进行。遵循先进先出原则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; mystack;</span><br><span class="line">mystack.<span class="built_in">push</span>(x) <span class="comment">//进栈</span></span><br><span class="line">mystack.<span class="built_in">top</span>()<span class="comment">//取栈顶元素</span></span><br><span class="line">mystack.<span class="built_in">pop</span>() <span class="comment">//退栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myqueue;</span><br><span class="line">myqueue.<span class="built_in">push</span>(i);<span class="comment">//队尾插入元素</span></span><br><span class="line">myqueue.<span class="built_in">front</span>();<span class="comment">//队头元素</span></span><br><span class="line">!myqueue.<span class="built_in">empty</span>();<span class="comment">//队列是否为空</span></span><br><span class="line">myqueue.<span class="built_in">pop</span>();<span class="comment">//出队列</span></span><br></pre></td></tr></table></figure><h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>1 set/multiset: 头文件<set><br>set集合不允许相同元素，multiset中允许存在相同的元素<br>2 map/multimap：头文件<map><br>map中存放的是成对的  key/value。<br>根据key对元素进行排序，可快速根据key来检索元素<br>map同multimap的不同：是否允许多个元素有相同的key值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line">set&lt;string&gt;s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="string">&quot;linxiao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;s;</span><br><span class="line">s[<span class="string">&quot;Monday&quot;</span>]=<span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;s[<span class="string">&quot;Monday&quot;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章_二叉树_part01</title>
      <link href="/2024/05/29/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%BA%8C%E5%8F%89%E6%A0%91_part01/"/>
      <url>/2024/05/29/%E7%AC%AC%E5%85%AD%E7%AB%A0_%E4%BA%8C%E5%8F%89%E6%A0%91_part01/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h2><h3 id="满二叉树和完全二叉树"><a href="#满二叉树和完全二叉树" class="headerlink" title="满二叉树和完全二叉树"></a>满二叉树和完全二叉树</h3><p>满二叉树：一颗二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。或者是深度为k，有2^k-1个节点的二叉树<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405282112527.png" alt=""><br>完全二叉树：除了最底层节点没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第h层(h从1开始)，则该层包含1-2^(h-1)个节点<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405282112528.png" alt=""></p><h3 id="二叉搜索树和平衡二叉搜索树"><a href="#二叉搜索树和平衡二叉搜索树" class="headerlink" title="二叉搜索树和平衡二叉搜索树"></a>二叉搜索树和平衡二叉搜索树</h3><p>二叉搜索树是一个有序树。没有值相等的节点<br>若左子树非空，则左子树所有节点的值<strong>均小于</strong>它的根节点的值。<br>若右子树非空，则右子树所有节点的值<strong>均大于</strong>它的根节点的值<br>左右子树都是二叉搜索树<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405282112529.png" alt=""><br>平衡二叉搜索树(AVL树)<br>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405282112530.png" alt=""><br>C++的map，set，multimap，multiset的底层实现都是平衡二叉搜索树<br>unordered_map,unordered_set的底层实现都是哈希表</p><h3 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h3><p>二叉树可以链式存储(链表)，顺序存储(数组),一般使用链式存储<br>顺序存储的下标开始为0，左孩子是i<em>2+1,右孩子是i</em>2+2,</p><h3 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h3><p>深度优先遍历：先往深走，遇到叶子结点再往回走<br>前序遍历(递归法，迭代法)<br>中序遍历(递归法，迭代法)<br>后序遍历(递归法，迭代法)<br>广度优先遍历<br>层次遍历（迭代法）</p><p>前中后序遍历，指的是中间节点的顺序<br>前序遍历：中左右<br>中序遍历：左中右<br>后序遍历：左右中<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405282112531.png" alt=""><br>栈是递归的一种实现结构，也就是说前中后序遍历的逻辑可以借助栈使用递归的方式来实现<br>广度优先遍历的实现使用队列实现，使用队列先进先出的特点，来一层一层遍历二叉树</p><h3 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p>递归的三要素<br>1.确定递归函数的参数和返回值：<br>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数<br>明确每次递归的返回值是什么，进而确定递归函数的返回类型<br>2.确定终止条件：<br>写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然会溢出<br>3 确定单层递归的逻辑<br>确定每一层递归需要处理的信息，重复调用自己来实现递归的过程</p><p>以前序遍历，将要打印节点顺序加入到vector中<br>1 确定递归函数的参数和返回值：<br>参数要传入vector来放节点的数值，以及要处理的树，不要返回值void<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp;vec)</span></span></span><br></pre></td></tr></table></figure><br>2 确定终止条件<br>当前遍历的节点为空，即空树时，本层递归结束<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><br>3 确定单层递归的逻辑<br>前序遍历，先打印当前中间节点，再处理左子树和右子树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left,vec);</span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right,vec);</span><br></pre></td></tr></table></figure></p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">144.二叉树的前序遍历</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode*cur,vector&lt;<span class="type">int</span>&gt;&amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,res);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">145.二叉树的后序遍历</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode*cur,vector&lt;<span class="type">int</span>&gt;&amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,res);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">94.二叉树的中序遍历</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode *cur,vector&lt;<span class="type">int</span>&gt;&amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="built_in">traversal</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。这就是递归为什么可以返回上一层位置的原因。</p><p>递归可以返回上一层位置，而递归使用栈实现的，所以可以用栈实现二叉树的前后中序遍历。</p><h3 id="前序遍历-迭代法"><a href="#前序遍历-迭代法" class="headerlink" title="前序遍历(迭代法)"></a>前序遍历(迭代法)</h3><p><a href="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif">前序遍历栈实现动图解释</a><br>前序遍历是中左右，每次先处理的中间节点，先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。<br>为什么要先加入右孩子，再加入左孩子呢？因为这样出栈的时候才是中左右的顺序。<br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* cur;</span><br><span class="line">            cur = st.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="中序遍历-迭代法）"><a href="#中序遍历-迭代法）" class="headerlink" title="中序遍历(迭代法）"></a>中序遍历(迭代法）</h3><p><a href="https://code-thinking.cdn.bcebos.com/gifs/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89.gif">中序遍历栈实现动图解释</a><br>中序遍历是左中右，先到达树左面的最底部，每遇到一个节点都存入栈中，到底后输出栈顶元素(左)，再输出栈顶元素(中)，之后再处理右子树，合并一下<br>就是输出栈顶元素后，处理右子树.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>||!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>先序遍历是中左右—调整代码左右循序—中右左—-反转result数组—左右中<br>后序遍历是左右中———-<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>二叉树的统一迭代法<br>见<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF">二叉树的统一法</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ I/O流库</title>
      <link href="/2024/05/28/C++%20I_O%E6%B5%81%E5%BA%93/"/>
      <url>/2024/05/28/C++%20I_O%E6%B5%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章-C-的I-O流类库"><a href="#第七章-C-的I-O流类库" class="headerlink" title="第七章 C++的I/O流类库"></a>第七章 C++的I/O流类库</h2><h3 id="C-为何建立自己输入输出系统"><a href="#C-为何建立自己输入输出系统" class="headerlink" title="C++为何建立自己输入输出系统"></a>C++为何建立自己输入输出系统</h3><p>C++除了支持C的输入输出函数:printf(),scanf().fprintf()…,增加cin&gt;&gt;,cout&lt;&lt;<br>C不支持输入输出用户自定义类型:结构、类<br>C++引入输入输出流，通过重载&lt;&lt;和&gt;&gt;运算符，支持用户自定义类型输出</p><p>C++流的概述<br>C++中预定义的流对象<br>cin,cout<br>cerr:非缓冲型标准出错流对象<br>cerr&lt;&lt;”The average cannot be computed.\n”;显示器输出，不能自定义文件输出<br>clog：缓冲型标准出错流对象<br>信息存在缓冲区，缓冲满或者遇上endl，输出信息。显示器输出，不能自定义文件输出。</p><h3 id="预定义类型的输入输出"><a href="#预定义类型的输入输出" class="headerlink" title="预定义类型的输入输出"></a>预定义类型的输入输出</h3><h4 id="无格式输入输出"><a href="#无格式输入输出" class="headerlink" title="无格式输入输出"></a>无格式输入输出</h4><p>cin&gt;&gt;<br>cout&lt;&lt;</p><h4 id="输入输出的格式控制"><a href="#输入输出的格式控制" class="headerlink" title="输入输出的格式控制"></a>输入输出的格式控制</h4><p>1 用ios的成员函数进行格式控制<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405280948486.png" alt="image.png"><br>以普通十进制小数形式输出，n表示有效数字个数，以fixed(固定小数点位置)形式和scientific(指数)形式输出时，n表示小数部分的位数<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405280948488.png" alt="image.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;  </span><br><span class="line">       cin.<span class="built_in">setf</span>(ios::shipws);       <span class="comment">//键盘输入时跳过输入空白</span></span><br><span class="line">       cout.<span class="built_in">setf</span>(ios::left);           <span class="comment">//设置输出左对齐</span></span><br><span class="line">       <span class="comment">//中间用运算符 “|”分隔</span></span><br><span class="line">       cout.<span class="built_in">setf</span>(ios::showpos | ios::scientific);      </span><br><span class="line">       cout&lt;&lt;<span class="number">567</span>&lt;&lt;“    ” &lt;&lt;<span class="number">567.89</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">+<span class="number">567</span> +<span class="number">5.6789e02</span></span><br></pre></td></tr></table></figure></p><p>2用预定义的操作符进行输入输出格式控制<br>加上头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip.h&gt;</span></span></span><br></pre></td></tr></table></figure><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405280948489.png" alt="image.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;oct&lt;&lt;<span class="number">123</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::left)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>3 使用用户自定义的操作符进行输入输出格式控制<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp; <span class="title">manip_name</span><span class="params">(ostream &amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//自定义代码</span></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">manip_name</span><span class="params">(istream &amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//自定义代码</span></span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip.h&gt;</span></span></span><br><span class="line"><span class="function">ostream &amp; <span class="title">output1</span><span class="params">(ostream &amp;stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;   stream.<span class="built_in">setf</span>(ios::left);</span><br><span class="line">     stream&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;hex&lt;&lt;<span class="built_in">setfill</span>(‘&amp;’);</span><br><span class="line">     <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">(  )</span></span></span><br><span class="line"><span class="function"></span>&#123;   cout&lt;&lt;<span class="number">123</span>&lt;&lt;endl;</span><br><span class="line">     cout&lt;&lt;output1&lt;&lt;<span class="number">123</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">7b</span>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><br></pre></td></tr></table></figure></p><h3 id="用户自定义类型的输入输出"><a href="#用户自定义类型的输入输出" class="headerlink" title="用户自定义类型的输入输出"></a>用户自定义类型的输入输出</h3><p>重载运算符“&lt;&lt;“ 一般为友元函数非成员函数重载主要为了与iostream标准库兼容<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;out,   class_name &amp;obj )</span><br><span class="line">&#123;</span><br><span class="line">       out&lt;&lt;obj.item1;</span><br><span class="line">       out&lt;&lt;obj.item2;</span><br><span class="line">       ........................</span><br><span class="line">       out&lt;&lt;obj.itemn;</span><br><span class="line">       <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>重载输入运算符”&gt;&gt;”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">istream &amp; <span class="keyword">operator</span> &gt;&gt;(istream &amp;in,   class_name &amp;obj )</span><br><span class="line">&#123;    </span><br><span class="line">      in&gt;&gt;obj.item1;</span><br><span class="line">      in&gt;&gt;obj.item2;</span><br><span class="line">         ..............</span><br><span class="line">      in&gt;&gt;obj.itemn;</span><br><span class="line">      <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">three_d</span>&#123;</span><br><span class="line">      <span class="type">int</span> x,y,z;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">three_d</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)   &#123;x=a; y=b; z=c;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;output,  three_d ob);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;input,   three_d &amp;ob);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文件的输入输出"><a href="#文件的输入输出" class="headerlink" title="文件的输入输出"></a>文件的输入输出</h3><p>C++将文件当做字符序列，是一种字符流。要对文件进行输入输出，需要创建文件流对象<br>文件分为:文本文件(字符流)，二进制文件(字节流)</p><p>三个文件流类<br>ofstream         文件输出流<br>ifstream         文件输入流<br>fstream         文件输入输出流</p><p>1 #include&lt;<fstream>&gt;<br>2 建立流对象打开文件<br>ofstream  out(文件名，打开方式)<br>ifstream   in(文件名，打开方式)<br>fstream    both(文件名，打开方式)</p><p>3 检验文件是否成功打开<br>if(!out)<br>{<br>    cout&lt;&lt;”bad”&lt;&lt;endl;<br>    exit(0);<br>}<br>打开成功out=1，不成功out =0；<br>4 完成输入输出后，关闭文件<br>out.close()        in.close()        both.close()</p><p>文件打开方式<br>ios::app 使输出追加到文件尾部       用ios::app打开的文件只能用于输出<br>ios::ate 文件指针移到文件尾<br>ios::in 打开一个文件进行读操作<br>ios::out 打开一个文件进行写操作<br>ios::trunc 同名文件删除<br>ios::binary 文件以二进制方式打开<br>fstream both(“test”,ios::in|ios::out|ios::binary)</p>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章_栈与队列_part03</title>
      <link href="/2024/05/28/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part03/"/>
      <url>/2024/05/28/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part03/</url>
      
        <content type="html"><![CDATA[<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239.滑动窗口最大值</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>有一个整数数组nums，大小为k的滑动窗口从最左侧移动到数组最右侧，每次滑动窗口都有一个最大值，返回由最大值组成的数组</p><h3 id="看到题目的第一想法"><a href="#看到题目的第一想法" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>两层循环，时间复杂度o(n*k)，超出时间限制41/51<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n-k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> count=nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;i+k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;count)count=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>整个滑动窗口移动的过程，与队列的pop掉移除元素，push移进元素。并且每次获得最大值的时候都是front()，这样就好了。<br>我们用到了单调队列，本体中的单调递减的，我们使用双端队列deque实现，front存当前滑动窗口的最大值。每次push时，将dq中元素小于等于nums[i]的元素都删掉(小于nums[i]的值是不可能添加到res的，删除就可以了)，双端队列size不超过k。<br>双端队列存的是元素的下标，当dq.front()==i-k时，说明当前最大值是滑动窗口要移除的值。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405281536937.jpg" alt="IMG_20240522_152722.jpg"><br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;dq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>()&amp;&amp;dq.<span class="built_in">front</span>()==i-k)&#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>()&amp;&amp;nums[dq.<span class="built_in">back</span>()]&lt;=nums[i])&#123;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h2><h3 id="题目重述-1"><a href="#题目重述-1" class="headerlink" title="题目重述"></a>题目重述</h3><p>有一个整数数组nums，和一个整数k，返回频率前k高的元素</p><h3 id="看到题目的第一想法-1"><a href="#看到题目的第一想法-1" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>unordered_map将值与频率映射，然后返回前k高的元素，遍历一次nums，然后在while(k—)再遍历k次unordered_map,时间复杂度o(k*n)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            umap[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter=umap.<span class="built_in">begin</span>();iter!=umap.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">                <span class="type">int</span> num=iter-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;count)&#123;</span><br><span class="line">                    count=num;</span><br><span class="line">                    index=iter-&gt;first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[index]=<span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>使用了最小堆和最大堆的方式，最小堆和最大堆的底层实现都是优先队列，特征就是自动排序，我们按照umap的value进行排序，使用最小堆，如果当前元素&gt;k，就pop，即将当前出现频率最小的弹出去了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            umap[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;min_heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=umap.<span class="built_in">begin</span>();iter!=umap.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(&#123;iter-&gt;second,iter-&gt;first&#125;);</span><br><span class="line">            <span class="keyword">if</span>(min_heap.<span class="built_in">size</span>()&gt;k)min_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!min_heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(min_heap.<span class="built_in">top</span>().second);</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 模版</title>
      <link href="/2024/05/27/C++%20%E6%A8%A1%E7%89%88/"/>
      <url>/2024/05/27/C++%20%E6%A8%A1%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="模版的概念"><a href="#模版的概念" class="headerlink" title="模版的概念"></a>模版的概念</h3><p>模板：写一个函数模子，用这个模子套印出许多功能相同，参数类型和返回类型不同的函数。</p><p>函数重载：同一个名字定义不同的函数，这些函数的功能不同，执行不同的操作<br>每个函数体内可以执行不同的动作。<br>函数模板：同一个名字定义不同的函数，这些函数功能相同，而参数类型和返回类型不同。</p><p>模版分为函数模版和类模版<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405262154321.png" alt="image.png"></p><h3 id="函数模版和模版函数"><a href="#函数模版和模版函数" class="headerlink" title="函数模版和模版函数"></a>函数模版和模版函数</h3><h4 id="函数模版的声明与模版函数的生成"><a href="#函数模版的声明与模版函数的生成" class="headerlink" title="函数模版的声明与模版函数的生成"></a>函数模版的声明与模版函数的生成</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板的声明格式：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> 类型参数&gt;</span><br><span class="line">返回类型 函数名(模板形参表)</span><br><span class="line">&#123;</span><br><span class="line">     函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   或  <span class="keyword">template</span>  &lt;<span class="keyword">typename</span>  T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x , T y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x&gt;y)? x:y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用函数模板时，必须实例化，用实际数据类型代替T</span></span><br></pre></td></tr></table></figure><p>在函数模板中允许使用多个类型参数，但在template定义部分的每个模板形参前必须有关键词class/typename.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> type1,  <span class="keyword">class</span> type2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(type1 x,type2 y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;x&lt;&lt;“ ”&lt;&lt;y&lt;&lt;end1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="built_in">myfunc</span>(<span class="number">10</span>, ”hao”);</span><br><span class="line"> <span class="built_in">myfunc</span>(<span class="number">0.123</span>, <span class="number">10L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在template语句与函数模块定义语句之间不允许有别的语句<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Template &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> i;    <span class="comment">//错误，不允许有别的语句</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x,T y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (x&gt;y)? x : y;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>函数模板可以重载<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, Ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x&gt;y?x:y ;&#125;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T x, T y, T z)</span></span></span><br><span class="line"><span class="function"></span>&#123;T t;  t=x&gt;y?x:y; <span class="keyword">return</span> t&gt;z?t:z; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>  a=<span class="number">10</span>, b=<span class="number">20</span>, max2;</span><br><span class="line">    <span class="type">float</span> x=<span class="number">1.1</span>, y=<span class="number">2.2</span>, z=<span class="number">3.3</span>, max3;</span><br><span class="line">    max2=<span class="built_in">max</span>(a,b);</span><br><span class="line">    max3=<span class="built_in">max</span>(x,y,z);</span><br><span class="line">    cout&lt;&lt;“Maximum of a, b :”&lt;&lt;max2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;“Maximum of x, y, z:”&lt;&lt;max3&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数模板可以与同名的非函数模板重载<br>调用顺序<br>1 先调用参数完全匹配的非函数模板函数,找到就调用<br>2 没找到，则寻找模板函数，实例化得到模板函数,再调用。</p><h3 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h3><p>类模版为类定义一种模子，然后实例化，类中的某些数据成员，某些成员函数的参数或者返回值，能取任意数据类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> 类名 </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">用类模板定义对象：</span><br><span class="line">类名&lt;实际类型名&gt;对象名（实参表）</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">compare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       T x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">compare</span>(T x1, T y1)</span><br><span class="line">       &#123;x=x1; y=y1;&#125;</span><br><span class="line">       <span class="function">T <span class="title">max</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="type">int</span> a=<span class="number">2</span>, b=<span class="number">3</span>;    </span><br><span class="line">      compare &lt;<span class="type">int</span>&gt; <span class="built_in">c1</span>(a,b);</span><br><span class="line">      cout&lt;&lt;“Maximum of a , b:”&lt;&lt;c1.<span class="built_in">max</span>()&lt;&lt;endl;</span><br><span class="line">      <span class="type">float</span> x=<span class="number">2.5</span>, y=<span class="number">4.3</span>;</span><br><span class="line">      compare&lt;<span class="type">float</span>&gt;<span class="built_in">c2</span>(x,y);</span><br><span class="line">      cout&lt;&lt;“Maximum of x, y:”&lt;&lt;c2.<span class="built_in">max</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类外定义</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">compare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       T x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">compare</span>(T x1, T y1);</span><br><span class="line">       <span class="function">T <span class="title">max</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">compare&lt;T&gt;::<span class="built_in">compare</span>(T x1, T y1)</span><br><span class="line">&#123;x=x1; y=y1;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T compare&lt;T&gt;::<span class="built_in">max</span>()</span><br><span class="line">&#123;<span class="keyword">return</span> x&gt;y?x:y; &#125;</span><br></pre></td></tr></table></figure><p>两个模板参数的类模板<br>Template<typename T1,T2></p><p>定义模板类对象<br>类名<char，char*>对象名<br>类名<int，double>对象名</p>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ 模版 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多态性</title>
      <link href="/2024/05/26/C++%20%E5%A4%9A%E6%80%81%E6%80%A7/"/>
      <url>/2024/05/26/C++%20%E5%A4%9A%E6%80%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-多态性"><a href="#第五章-多态性" class="headerlink" title="第五章 多态性"></a>第五章 多态性</h2><h3 id="静态和动态多态性"><a href="#静态和动态多态性" class="headerlink" title="静态和动态多态性"></a>静态和动态多态性</h3><p>多态性，用同一个名字定义不同的函数，这些函数执行不同但又类似的操作</p><p>联编：一个源程序经过编译、链接、成为可执行文件的过程是把可执行代码联编/装配的过程</p><p>静态联编：编译时实现联编<br>动态联编：执行时实现联编</p><p>静态多态性（编译多态性）：函数重载，运算符重载,模板<br>动态多样性（执行多态性）：虚函数（继承）</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>operator@（）       //@为运算符<br>例如：operator+(),operator-(),operator*() operator/()</p><p>实现途径：<br>1成员函数<br>2友元函数<br>3类外函数</p><h4 id="类外函数实现运算符重载"><a href="#类外函数实现运算符重载" class="headerlink" title="类外函数实现运算符重载"></a>类外函数实现运算符重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">              <span class="type">double</span> real;</span><br><span class="line">              <span class="type">double</span> imag;</span><br><span class="line">              <span class="built_in">complex</span>(<span class="type">double</span> r=<span class="number">0</span>,<span class="type">double</span> i=<span class="number">0</span>)</span><br><span class="line">              &#123;real=r;imag=i;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">complex <span class="keyword">operator</span>+(complex co1,complex co2)</span><br><span class="line">&#123;</span><br><span class="line">   complex temp;</span><br><span class="line">   temp.real=co1.real+co2.real;</span><br><span class="line">   temp.imag=co1.imag+co2.imag;</span><br><span class="line">   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用重载运算符的两种方式<br>Com=operator+(com1,com2)<br>Com=com1+com2</p><p>说明<br>1 运算符重载函数(operator @())可以返回任何类型，一般返回类型与他操作类型相同<br>2不能定义新的运算符      不能定义的运算符 （  .        ::           ?   :   ）<br>3不能改变原有运算符的参数个数，也不改变原有的优先级和结合性<br>4可以为同一个运算符定义几个运算符重载函数来进行不同的操作<br>5 运算符重载尽量保持原义</p><h4 id="友元函数实现运算符重载"><a href="#友元函数实现运算符重载" class="headerlink" title="友元函数实现运算符重载"></a>友元函数实现运算符重载</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内声明：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">   <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">friend</span> 返回类型 <span class="keyword">operator</span>@(参数表)；</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外定义：因为友元函数不是成员函数，所以不需要加类名：：</span></span><br><span class="line">返回类型 <span class="keyword">operator</span> @(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双目运算符需要2个参数，单目运算符需要1个参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">           <span class="type">double</span> real;</span><br><span class="line">           <span class="type">double</span> imag;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">           <span class="built_in">complex</span> (<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> I=<span class="number">0.0</span>)  &#123;real=r; imag=i;&#125; </span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span></span>;</span><br><span class="line">           <span class="keyword">friend</span> complex <span class="keyword">operator</span> + (complex a, complex b);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">complex <span class="keyword">operator</span> +(complex a,complex b)</span><br><span class="line">&#123;   complex temp;</span><br><span class="line">    temp.real=a.real+b.real;        </span><br><span class="line">    temp.imag=a.imag+b.imag; </span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::print</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;real;</span><br><span class="line">    <span class="keyword">if</span>(imag&gt;<span class="number">0</span>)  cout&lt;&lt;“+”;</span><br><span class="line">    <span class="keyword">if</span>(imag!=<span class="number">0</span>)  cout&lt;&lt;imag&lt;&lt;“i\n”</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="function">complex <span class="title">A1</span><span class="params">(<span class="number">2.2</span>,<span class="number">4.4</span>)</span>, <span class="title">A2</span><span class="params">(<span class="number">3.3</span>,<span class="number">5.5</span>)</span>, A3</span>;</span><br><span class="line">    A3=A1+A2;   </span><br><span class="line">    A3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>单目运算符重载<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coord</span></span><br><span class="line">&#123; <span class="keyword">private</span>:</span><br><span class="line"> <span class="type">float</span> x, y;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Coord</span>(<span class="type">float</span> _x, <span class="type">float</span> _y);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">friend</span> Coord <span class="keyword">operator</span>++(Coord &amp;obj);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Coord::<span class="built_in">Coord</span>(<span class="type">float</span> _x, <span class="type">float</span> _y)</span><br><span class="line">&#123;  x=_x; y=_y; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Coord::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;<span class="string">&quot;x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;y&lt;&lt;endl; &#125;</span><br><span class="line">Coord <span class="keyword">operator</span>++(Coord &amp;obj)</span><br><span class="line">&#123; obj.x++;</span><br><span class="line">  obj.y++;</span><br><span class="line">  <span class="keyword">return</span> obj; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Coord <span class="title">obj1</span><span class="params">(<span class="number">1.1</span>,<span class="number">2.2</span>)</span></span>;</span><br><span class="line">obj1.<span class="built_in">show</span>();</span><br><span class="line">       obj1++;</span><br><span class="line">       obj1.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="成员函数实现运算符重载"><a href="#成员函数实现运算符重载" class="headerlink" title="成员函数实现运算符重载"></a>成员函数实现运算符重载</h4><p>单目运算符，参数表为空， 不需要操作数，当前对象为操作数;<br>双目运算符，参数只有一个操作数（右操作），左操作数为隐含的当前对象，友this指针传递。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内声明：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">返回类型  <span class="keyword">operator</span> @ (形参表)；</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外定义：</span></span><br><span class="line">返回类型 X:: <span class="keyword">operator</span>  运算符  (形参表)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>双目运算符重载<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">           <span class="type">double</span> real;</span><br><span class="line">           <span class="type">double</span> imag;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">           <span class="built_in">complex</span> (<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> I=<span class="number">0.0</span>)  &#123;real=r; imag=i;&#125; </span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">( )</span></span>;</span><br><span class="line">           complex <span class="keyword">operator</span> + (complex a);</span><br><span class="line">&#125;;</span><br><span class="line">complex complex:: <span class="keyword">operator</span> +(complex a)</span><br><span class="line">&#123;   complex temp;</span><br><span class="line">     temp.real=a.real+real;        </span><br><span class="line">     temp.imag=a.imag+imag; </span><br><span class="line">     <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">complex::print</span><span class="params">( )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;real;</span><br><span class="line">    <span class="keyword">if</span>(imag&gt;<span class="number">0</span>)  cout&lt;&lt;“+”;</span><br><span class="line">    <span class="keyword">if</span>(imag!=<span class="number">0</span>)  cout&lt;&lt;imag&lt;&lt;“i\n”</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="function">complex <span class="title">A1</span><span class="params">(<span class="number">1.1</span>,<span class="number">2.2</span>)</span>, <span class="title">A2</span><span class="params">(<span class="number">3.3</span>,<span class="number">4.4</span>)</span>, A3</span>;</span><br><span class="line">    A3=A1+A2;   </span><br><span class="line">    A3.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>单目运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">coord</span>&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> x, y;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">coord</span>(<span class="type">int</span> i=<span class="number">0</span>,<span class="type">int</span> j=<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    coord <span class="keyword">operator</span> ++();</span><br><span class="line">&#125;;</span><br><span class="line">coord::<span class="built_in">coord</span> (<span class="type">int</span> i,<span class="type">int</span> j)     </span><br><span class="line">&#123;x=i; y=j;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coord::print</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;cout&lt;&lt;<span class="string">&quot; x:&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;,y:&quot;</span>&lt;&lt;y&lt;&lt;endl;&#125;</span><br><span class="line">coord coord::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;    ++x;</span><br><span class="line">   ++y;</span><br><span class="line">   <span class="keyword">return</span>  *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">     <span class="function">coord <span class="title">ob</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">ob.<span class="built_in">print</span>();</span><br><span class="line">++ob;                        <span class="comment">//隐式调用</span></span><br><span class="line">ob.<span class="built_in">print</span>();</span><br><span class="line">ob.<span class="keyword">operator</span> ++();     <span class="comment">//显式调用</span></span><br><span class="line">ob.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="友元函数与成员函数实现运算符重载的比较"><a href="#友元函数与成员函数实现运算符重载的比较" class="headerlink" title="友元函数与成员函数实现运算符重载的比较"></a>友元函数与成员函数实现运算符重载的比较</h4><p>1 参数数目不同<br>友元函数 单目运算符 1          双目运算符  2<br>成员函数 单目运算符 0          双目运算符  2</p><p>2 大部分运算符既可以用友元函数重载，也可以用成员函数重载。<br>双目运算符采用友元函数重载<br>单目运算符用成员函数重载。<br>如果操作数需要类型转换的（特别是左操作数为对象），必须用友元函数进行重载。</p><p>3 调用形式<br>a+b      operator+(a,b)            a.operator+(b)<br>++a      operator++(&amp;a)            a.operator++()</p><h4 id="赋值运算符“-”重载与指针悬挂问题"><a href="#赋值运算符“-”重载与指针悬挂问题" class="headerlink" title="赋值运算符“=”重载与指针悬挂问题"></a>赋值运算符“=”重载与指针悬挂问题</h4><p>默认的赋值运算符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(<span class="type">const</span> X &amp;source)</span><br><span class="line"> &#123;      </span><br><span class="line">    <span class="comment">//成员间赋值</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>对象赋值直接调用 obj2=obj1<br>如果有涉及动态分配内存，有可能会出现”指针悬挂”问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>(<span class="type">char</span>* str);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line">&#125;;</span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">char</span>* str)</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot;Constructor called.&quot;</span>&lt;&lt;endl;</span><br><span class="line">ptr=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(ptr,str); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Deconstructor called.-----&quot;</span>&lt;&lt;ptr&lt;&lt;endl;</span><br><span class="line"><span class="keyword">delete</span> [] ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">p1</span><span class="params">(<span class="string">&quot;book&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">p2</span><span class="params">(<span class="string">&quot;jeep&quot;</span>)</span></span>;</span><br><span class="line">    p2=p1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Constructor called.</span></span><br><span class="line"><span class="comment">//Constructor called.</span></span><br><span class="line"><span class="comment">//Deconstructor called.-----book</span></span><br><span class="line"><span class="comment">//Deconstructor called.-----乱码</span></span><br></pre></td></tr></table></figure><br>   <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405262124326.png" alt="image.png"><br>深层赋值解决指针悬挂问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">String</span>(<span class="type">char</span>* str);</span><br><span class="line">~<span class="built_in">String</span>();</span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="type">const</span> String &amp;p);  &#125;;</span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">char</span>* str)</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot;Constructor called.&quot;</span>&lt;&lt;endl;</span><br><span class="line">ptr=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(ptr,str); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot;Deconstructor called.-----&quot;</span>&lt;&lt;ptr&lt;&lt;endl;</span><br><span class="line"><span class="keyword">delete</span> [] ptr; &#125;</span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;p)</span><br><span class="line">&#123;<span class="keyword">delete</span> [] ptr;</span><br><span class="line">ptr=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(p.ptr)+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(ptr,p.ptr);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="function">String <span class="title">p1</span><span class="params">(<span class="string">&quot;book&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">p2</span><span class="params">(<span class="string">&quot;jeep&quot;</span>)</span></span>;</span><br><span class="line">p2=p1;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Constructor called.</span></span><br><span class="line"><span class="comment">//Constructor called.</span></span><br><span class="line"><span class="comment">//Deconstructor called.-----book</span></span><br><span class="line"><span class="comment">//Deconstructor called.-----book</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>（1）赋值运算符“=” 只能用成员函数重载。<br>（2）重载的赋值运算符“=”不能被继承。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="系统预定义类型间的转换"><a href="#系统预定义类型间的转换" class="headerlink" title="系统预定义类型间的转换"></a>系统预定义类型间的转换</h4><p>隐式转换<br>1 a=b 时，b的值需先转换为a类型后再进行赋值<br>2 char或short类型变量与int类型进行运算时，将char与short类型转换为int类型<br>3当两个操作对象类型不一致时，在算术运算前，级别低的自动转换为级别高的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">5</span>,y;</span><br><span class="line">y=<span class="number">3.5</span>+x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//y=8  3.5与int（x）进行计算时，先把x转换为5.0</span></span><br><span class="line"><span class="comment">//当将8.5赋值给y时，8.5先转换为int型，即8再赋值给y</span></span><br></pre></td></tr></table></figure><p>显示转换<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j</span><br><span class="line"><span class="comment">//C语言</span></span><br><span class="line">cout&lt;&lt;(<span class="type">float</span>)(i+j);                    </span><br><span class="line"><span class="comment">//C++新增</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">float</span> (i+j);                 </span><br></pre></td></tr></table></figure></p><h4 id="类类型与系统预定义类型间的转换"><a href="#类类型与系统预定义类型间的转换" class="headerlink" title="类类型与系统预定义类型间的转换"></a>类类型与系统预定义类型间的转换</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型转换函数格式：</span></span><br><span class="line"><span class="keyword">class</span> 源类类名&#123;</span><br><span class="line"><span class="comment">//…………</span></span><br><span class="line">    <span class="keyword">operator</span>  目的类型( )</span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//…………</span></span><br><span class="line">         <span class="keyword">return</span>  目的类型的数据；</span><br><span class="line">    ｝</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类型转换函数:  X obj;  int(obj)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> complex&#123;</span><br><span class="line">       <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">float</span>  real, imag;</span><br><span class="line">       <span class="keyword">public</span>:</span><br><span class="line">          <span class="built_in">complex</span>(<span class="type">float</span>  r=<span class="number">0</span>, <span class="type">float</span>  i=<span class="number">0</span>)</span><br><span class="line">          &#123;  real=r; imag=i;</span><br><span class="line">              cout&lt;&lt;<span class="string">&quot;Constructing…\n&quot;</span>;&#125;</span><br><span class="line">          <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">( )</span>                       <span class="comment">//complexfloat</span></span></span><br><span class="line"><span class="function">          </span>&#123;  cout&lt;&lt;<span class="string">&quot;Type changed to float…\n&quot;</span>;</span><br><span class="line">               <span class="keyword">return</span> real;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">( )</span>                            <span class="comment">// complexint</span></span></span><br><span class="line"><span class="function">          </span>&#123; cout&lt;&lt;<span class="string">&#x27;Type changed to int …\n&quot;;</span></span><br><span class="line"><span class="string">              return int (real);</span></span><br><span class="line"><span class="string">           &#125;</span></span><br><span class="line"><span class="string">           void print( )</span></span><br><span class="line"><span class="string">          &#123;  cout&lt;&lt;&#x27;</span>(<span class="string">&#x27;&lt;&lt;real&lt;&lt;&#x27;</span>,<span class="string">&#x27;&lt;&lt;imag&lt;&lt;&#x27;</span>)<span class="string">&#x27;&lt;&lt;endl; &#125;</span></span><br><span class="line"><span class="string"> &#125;;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;  complex A(2.2, 4.4);</span></span><br><span class="line"><span class="string">   A.print();</span></span><br><span class="line"><span class="string">   cout&lt;&lt;float(A)*0.5&lt;&lt;endl;</span></span><br><span class="line"><span class="string">   complex B(4, 6);</span></span><br><span class="line"><span class="string">   B.print();</span></span><br><span class="line"><span class="string">   cout&lt;&lt;int(B)*2&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>说明<br>1 类型转换函数只能是成员函数而不能用友元函数<br>2 类型转换函数没有参数，也不是显式给出返回类型<br>3 在函数体中必须用return返回目的类型的一个数据。<br>4 可以定义多个类型转换函数，编译器会根据操作数的类型自动的选择一个合适的类型转换函数。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数是一种动态的重载方式，虚函数允许函数调用与函数之间的联系在运行时才建立，也就是运行时才决定如何动作，即动态联编。</p><h4 id="虚函数引入"><a href="#虚函数引入" class="headerlink" title="虚函数引入"></a>虚函数引入</h4><p>基类指针可以指向公有派生类的对象。<br>但是只能用它来直接访问派生类中从基类继承来的成员，，而不能访问公有派生类定义的新成员，使用虚函数解决该问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">my_base</span>&#123;</span><br><span class="line">           <span class="type">int</span> a,b;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">           <span class="built_in">my_base</span>(<span class="type">int</span> x, <span class="type">int</span> y) </span><br><span class="line">           &#123; a=x; b=y; &#125;</span><br><span class="line">           <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">          </span>&#123;    cout &lt;&lt;“基类 my_base----\n”;</span><br><span class="line">                cout &lt;&lt;a&lt;&lt;“  “&lt;&lt;b&lt;&lt;endl; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>: <span class="keyword">public</span> my_base&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">my_class</span>(<span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> z):<span class="built_in">my_base</span>(x,y) </span><br><span class="line">    &#123; c=z; &#125;</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">     </span>&#123; cout &lt;&lt;“派生类my_class----\n”; cout &lt;&lt;“c=” &lt;&lt;c&lt;&lt;endl;  &#125;            </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="function">my_base <span class="title">mb</span><span class="params">(<span class="number">50</span>,<span class="number">50</span>)</span>, *mp</span>;</span><br><span class="line">  <span class="function">my_class <span class="title">mc</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">  mp=&amp;mb;</span><br><span class="line">  mp-&gt;<span class="built_in">show</span>();</span><br><span class="line">  mp=&amp;mc;</span><br><span class="line">  mp-&gt;<span class="built_in">show</span>(); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//基类 my_base----</span></span><br><span class="line"><span class="comment">//50    50</span></span><br><span class="line"><span class="comment">//基类 my_base----          </span></span><br><span class="line"><span class="comment">//10    20</span></span><br></pre></td></tr></table></figure></p><p>基类指针对象与派生类指针对象关系：<br>1基类指针只能指向公有派生类对象，不能指向私有派生类对象<br>2.派生类对象不能指向基类对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">my_base</span>&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">my_base</span>(<span class="type">int</span> x, <span class="type">int</span> y) </span><br><span class="line">       &#123; a=x; b=y; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">       </span>&#123; cout &lt;&lt;“基类 my_base----\n”; cout &lt;&lt;a&lt;&lt;“  “&lt;&lt;b&lt;&lt;endl; &#125; </span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">my_class</span>: <span class="keyword">public</span> my_base&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">my_class</span>(<span class="type">int</span> x, <span class="type">int</span> y,<span class="type">int</span> z):<span class="built_in">my_base</span>(x,y) </span><br><span class="line">    &#123; c=z; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">    </span>&#123; cout &lt;&lt;“派生类my_class----\n”; cout &lt;&lt;“c=” &lt;&lt;c&lt;&lt;endl;  &#125;            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="function">my_base <span class="title">mb</span><span class="params">(<span class="number">50</span>,<span class="number">50</span>)</span>, *mp</span>;</span><br><span class="line">    <span class="function">my_class <span class="title">mc</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    mp=&amp;mb;</span><br><span class="line">    mp-&gt;<span class="built_in">show</span>();</span><br><span class="line">    mp=&amp;mc;</span><br><span class="line">    mp-&gt;<span class="built_in">show</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//基类 my_base----</span></span><br><span class="line"><span class="comment">//50    50</span></span><br><span class="line"><span class="comment">//派生类my_class---</span></span><br><span class="line"><span class="comment">//30</span></span><br></pre></td></tr></table></figure><h4 id="虚函数的定义"><a href="#虚函数的定义" class="headerlink" title="虚函数的定义"></a>虚函数的定义</h4><p>引入虚函数之后，利用基类指针可以分别指向不同的公有派生类对象，调用不同的同名成员函数，可以实现动态多态性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span>    函数类型    函数名(形参表)</span><br><span class="line">&#123;    </span><br><span class="line">        函数体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在基类中用关键字virtual说明，并在派生类中重新定义</span></span><br><span class="line"><span class="comment">//在派生类中重新定义时，其函数原型，</span></span><br><span class="line"><span class="comment">//包括返回类型、函数名、参数个数与参数类型的顺序，</span></span><br><span class="line"><span class="comment">//都必须与基类中的原形完全相同。</span></span><br></pre></td></tr></table></figure><p>关于虚函数的注意要点<br>1.派生类对基类声明的虚函数进行重新定义时，关键字可写也可以不写，但是最好加上virtual。<br>2.在派生类中重新定义时，其函数原型，包括返回类型，函数名，参数个数，参数类型的顺序都必须与基类中原型完全相同<br>3派生类如果没有重新定义虚函数，其自动继承虚函数。<br>4.构造函数不能是虚函数，析构函数可以是虚函数<br>//创建对象时需要知道对象的类型，但是虚函数是在执行时实现联编的，所有构造函数不能是虚函数。<br>5.虚函数必须是成员函数，不能是友元函数，也不能使静态成员函数</p><p>虚函数与重载函数的关系<br>1 虚函数是重载函数的一种形式<br>2 普通的函数重载，函数的参数、参数类型必须有所不同，函数的返回类型也可以不同（也可以相同）<br>3 虚函数需要函数名、返回类型、参数个数、参数的类型和顺序与基类的虚函数原型完全相同。<br>虚函数和普通函数重载的比较<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span>  <span class="type">void</span>  <span class="title">func1</span><span class="params">( )</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span>  <span class="type">void</span>  <span class="title">func2</span><span class="params">( )</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span>  <span class="type">void</span>  <span class="title">func3</span><span class="params">( )</span></span>;</span><br><span class="line">       <span class="function"><span class="type">void</span>  <span class="title">func4</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">derived</span> : <span class="keyword">public</span>  base &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">virtual</span>  <span class="type">void</span>  <span class="title">func1</span><span class="params">( )</span></span>;       <span class="comment">//虚函数重新定义</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> x)</span></span>;              <span class="comment">//普通函数重载</span></span><br><span class="line">     <span class="function"><span class="type">char</span>  <span class="title">func3</span><span class="params">( )</span></span>;                    <span class="comment">//错误，返回类型不同，应删除</span></span><br><span class="line">     <span class="function"><span class="type">void</span>  <span class="title">func4</span><span class="params">( )</span></span>;                   <span class="comment">//普通的函数重载，不是虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::func1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;“----base func1----\n”;  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::func2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;“----base func2 ----\n”;  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::func3</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;“----base func3----\n”;  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">base::func4</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;“----base func4----\n”;  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">derived::func1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout &lt;&lt;“----derived func1----\ n”;  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">derived::func2</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;“----derived func2----\n”;  &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">derived::func4</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; cout&lt;&lt;“----derived func4----\n”;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  base d1, *bp;</span><br><span class="line">    derived d2;</span><br><span class="line">    bp=&amp;d2;</span><br><span class="line">    bp-&gt;<span class="built_in">func1</span>();    <span class="comment">//调用derived::func1()</span></span><br><span class="line">    bp-&gt;<span class="built_in">func2</span>();    <span class="comment">//调用base::func2()</span></span><br><span class="line">    bp-&gt;<span class="built_in">func4</span>();    <span class="comment">//调用base::func4()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>纯虚函数是一个在基类中说明的虚函数，但是在该基类中没有定义，要派生类中定义自己的版本</p><p>纯虚函数的格式<br>Virtual 返回类型 函数名（参数表）=0；</p><p>抽象类<br>类至少包含一个纯虚函数<br>1 抽象类只能作为基类，不能创建抽象类对象   ////如果一个基类中含有纯虚函数，但是派生类没有重新说明纯虚函数，，则该函数在派生类中任然是纯虚函数，该派生类仍然是抽象类。<br>2抽象类不能用作参数类型，返回类型或者转换类型<br>3可以声明抽象类指针，此指针指向派生类对象。进而实现多态性<br>4如果派生类中没有重新定义纯虚函数，则派生类只继承基类的纯虚函数。<br>5不能从具体类派生抽象类</p>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ 多态性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 派生类与继承</title>
      <link href="/2024/05/26/C++%20%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/05/26/C++%20%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-派生类与继承"><a href="#第四章-派生类与继承" class="headerlink" title="第四章 派生类与继承"></a>第四章 派生类与继承</h2><h3 id="派生类的概念"><a href="#派生类的概念" class="headerlink" title="派生类的概念"></a>派生类的概念</h3><h4 id="派生类的声明"><a href="#派生类的声明" class="headerlink" title="派生类的声明"></a>派生类的声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:继承方式 基类名&#123;</span><br><span class="line">    <span class="comment">//派生类新增的数据成员和函数成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">employee</span> : <span class="keyword">public</span> person &#123;</span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         <span class="type">char</span> department[<span class="number">20</span>];</span><br><span class="line">         <span class="type">float</span> salary;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式 ：<br>公有(public)，<br>私有(private)，<br>保护(protected)</p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261947066.png" alt="image.png"></p><h3 id="派生类的构造函数和析构函数"><a href="#派生类的构造函数和析构函数" class="headerlink" title="派生类的构造函数和析构函数"></a>派生类的构造函数和析构函数</h3><p>先基类的构造再派生类的构造，先派生类的析构，再基类的析构。</p><p>派生类构造函数的类内定义和类外定义<br>类内定义：<br>derive（int a,int b): base(a){  x=b;}<br>类外定义：<br>首先在类内声明<br>Derive(int a,int b);  // 可以不加base（a)<br>类外定义格式同类内定义格式一致</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><p>派生类构造函数可以省去：base（a），当基类中不带参数的构造函数，或带缺省参数的构造函数</p><p>当派生类的基类也是个派生类时，派生类构造函数只需要负责其最近的基类构造函数即可。<br>A (int a,int b):B(a){x=b}<br>C(int a,int b,int c):A(a,b){y=c}</p><h3 id="调整基类的访问属性"><a href="#调整基类的访问属性" class="headerlink" title="调整基类的访问属性"></a>调整基类的访问属性</h3><p>在派生类中存在与基类同名成员，派生类同名成员覆盖基类同名成员。要访问基类的同名成员<br>使用    基类名::同名成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123; </span><br><span class="line">     <span class="keyword">public</span>:  </span><br><span class="line">          <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> : <span class="keyword">public</span> X &#123;</span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">           <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">( )</span></span>;</span><br><span class="line">           <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Y::g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="built_in">f</span>();            <span class="comment">//类Y的f( )</span></span><br><span class="line">   X::<span class="built_in">f</span>();          <span class="comment">// X类的f( ),       X::  作用域分辨符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><h4 id="多重继承的声明"><a href="#多重继承的声明" class="headerlink" title="多重继承的声明"></a>多重继承的声明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 派生方式<span class="number">1</span> 基类名<span class="number">1</span>, ... , 派生方式n 基类名n</span><br><span class="line">  &#123;      </span><br><span class="line">      <span class="comment">//派生类新增的数据成员和函数成员 </span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>对于基类名1与基类名n的同名成员，使用基类名::同名成员</p><h4 id="多重继承的构造函数和析构函数"><a href="#多重继承的构造函数和析构函数" class="headerlink" title="多重继承的构造函数和析构函数"></a>多重继承的构造函数和析构函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">派生类名(参数总表):基类名<span class="number">1</span>(参数表<span class="number">1</span>),基类名<span class="number">2</span>(参数表<span class="number">2</span>),.....,基</span><br><span class="line">类名<span class="built_in">n</span>(参数表n)</span><br><span class="line">&#123;        </span><br><span class="line">    <span class="comment">//派生类新增成员的初始化语句…     </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Z</span>: <span class="keyword">public</span> X, <span class="keyword">private</span> Y &#123;</span><br><span class="line">         <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">Z</span>(<span class="type">int</span> sa, <span class="type">int</span> sb, <span class="type">int</span> sc):<span class="built_in">X</span>(sa),<span class="built_in">Y</span>(sb) </span><br><span class="line">         &#123; c=sc; &#125;                               <span class="comment">//Z类构造函数</span></span><br><span class="line">         <span class="function"><span class="type">int</span> <span class="title">getZ</span><span class="params">( )</span> </span>&#123; <span class="keyword">return</span> c; &#125;</span><br><span class="line">         <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">( )</span> </span>&#123; <span class="keyword">return</span> Y::<span class="built_in">getY</span>( ); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h4><p>类名::函数可以消除二义性，但是会保留2个副本，若只留一个副本，需要引入虚基类。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261947068.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span>: </span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">base</span>( )</span><br><span class="line">        &#123;  a=<span class="number">5</span>;   cout&lt;&lt;“base  a=”&lt;&lt;a&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span>:<span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>: <span class="built_in">base1</span>( )</span><br><span class="line">              &#123;  a=a+<span class="number">10</span>;   cout&lt;&lt;“base1  a=”&lt;&lt;a&lt;&lt;endl;  &#125;                       </span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span>:<span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>: <span class="built_in">base2</span>( )</span><br><span class="line">              &#123;  a=a+<span class="number">20</span>;   cout&lt;&lt;“base2  a=”&lt;&lt;a&lt;&lt;endl;  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">derived</span> :<span class="keyword">public</span> base1, <span class="keyword">public</span> base2 &#123;</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">              <span class="built_in">derived</span>( )</span><br><span class="line">             &#123;  cout&lt;&lt;“base1::a=”&lt;&lt;base1::a&lt;&lt;endl; </span><br><span class="line">                 cout&lt;&lt;“base2::a=”&lt;&lt;base2::a&lt;&lt;endl; </span><br><span class="line">             &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">      derived obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//base a=5  基类的base的构造函数</span></span><br><span class="line"><span class="comment">//base1 a=15 base1的构造函数</span></span><br><span class="line"><span class="comment">//base a=5  主函数base的构造函数</span></span><br><span class="line"><span class="comment">//base2 a=25 base2的构造函数</span></span><br><span class="line"><span class="comment">//base1::a=15 cout&lt;&lt;base1::a</span></span><br><span class="line"><span class="comment">//base2::a =25 cout&lt;&lt;base2::b</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名:<span class="keyword">virtual</span> 继承方式 基类名&#123;</span><br><span class="line">    <span class="comment">// ............</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261947069.png" alt="image.png"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span>: </span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">base</span>( )</span><br><span class="line">        &#123;  a=<span class="number">5</span>;   cout&lt;&lt;“base  a=”&lt;&lt;a&lt;&lt;endl;  &#125;</span><br><span class="line">  &#125;;      </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">base1</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>: <span class="built_in">base1</span>( )</span><br><span class="line">              &#123;  a=a+<span class="number">10</span>;   cout&lt;&lt;“base1  a=”&lt;&lt;a&lt;&lt;endl;  &#125;                       </span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">base2</span>: <span class="keyword">virtual</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">  <span class="keyword">public</span>: <span class="built_in">base2</span>( )</span><br><span class="line">              &#123;  a=a+<span class="number">20</span>;   cout&lt;&lt;“base2  a=”&lt;&lt;a&lt;&lt;endl;  &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">derived</span> :<span class="keyword">public</span> base1, <span class="keyword">public</span> base2 &#123;</span><br><span class="line">          <span class="keyword">public</span>:</span><br><span class="line">             <span class="built_in">derived</span>( )</span><br><span class="line">             &#123;  cout&lt;&lt;“a=”&lt;&lt;a&lt;&lt;endl; &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">      derived obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base a=<span class="number">5</span></span><br><span class="line">base1 a=<span class="number">15</span></span><br><span class="line">base2 a=<span class="number">35</span></span><br><span class="line">a=<span class="number">35</span></span><br></pre></td></tr></table></figure></p><p>虚基类构造函数调用顺序<br>从左往右，从上往下，先虚基类后普通基类，最后派生类。</p><p>虚基类的初始化<br>1 对同一个虚基类的构造函数只调用一次，且是在第一次出现时调用</p><p>2 当虚基类定义有带参数的构造函数并且没有定义默认形式的构造函数，则所有直接或间接地派生类在构造函数地初始化表中列出对虚基类构造函数地调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span> &#123;</span><br><span class="line">         <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">base</span>(<span class="type">int</span> sa)                                          <span class="comment">//base类构造函数</span></span><br><span class="line">         &#123; a=sa; cout&lt;&lt;<span class="string">&quot;构造 base 类&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">         <span class="type">int</span> b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">base1</span>(<span class="type">int</span> sa, <span class="type">int</span> sb):<span class="built_in">base</span>(sa)             <span class="comment">//base1类构造函数</span></span><br><span class="line">         &#123; b=sb; cout&lt;&lt;<span class="string">&quot;构造 base1 类&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base2</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> base &#123;</span><br><span class="line">         <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">base2</span>(<span class="type">int</span> sa, <span class="type">int</span> sc):<span class="built_in">base</span>(sa)      <span class="comment">//base2类构造函数</span></span><br><span class="line">        &#123; c=sc; cout&lt;&lt;<span class="string">&quot;构造 base2 类&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">derived</span>:<span class="keyword">public</span> base1, <span class="keyword">public</span> base2&#123;</span><br><span class="line">         <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">derived</span>(<span class="type">int</span> sa, <span class="type">int</span> sb, <span class="type">int</span> sc, <span class="type">int</span> sd):<span class="built_in">base</span>(sa),<span class="built_in">base1</span>(sa,sb),</span><br><span class="line">         <span class="built_in">base2</span>(sa,ac)  <span class="comment">//derived类构造函数</span></span><br><span class="line">         &#123; d=sd; cout&lt;&lt;<span class="string">&quot;构造 derived 类&quot;</span>&lt;&lt;endl;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">      <span class="function">derived <span class="title">obj</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="赋值兼容"><a href="#赋值兼容" class="headerlink" title="赋值兼容"></a>赋值兼容</h3><p>赋值兼容规则：在需要基类对象的地方，都可以用公有派生类对象来代替</p><p>1 对象兼容<br>Derive b；Base a ；a=b;  a.show()<br>2 引用兼容<br>Derive b;Base &amp;a=b;a.show()<br>3指针兼容<br>Derive b;Base <em>ptr;</em>ptr=&b;ptr-&gt;show()<br>不允许派生类的指针指向基类<br>4指针赋值<br>Derive <em>ptr1;Base </em>ptr2;ptr2=ptr1;ptr2-&gt;show()</p>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ 派生类 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 位运算</title>
      <link href="/2024/05/25/AcWing%20%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2024/05/25/AcWing%20%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="801-二进制中1的个数"><a href="#801-二进制中1的个数" class="headerlink" title="801.二进制中1的个数"></a><a href="https://www.acwing.com/problem/content/803/">801.二进制中1的个数</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>给定一个长度为n的数列，求出数列中每个数的二进制表示中1的个数</p><h3 id="如何得知n的二进制表示中第k位是几"><a href="#如何得知n的二进制表示中第k位是几" class="headerlink" title="如何得知n的二进制表示中第k位是几"></a>如何得知n的二进制表示中第k位是几</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261625069.jpg" alt="IMG_20240526_161842.jpg"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x,res=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            res+=(x&amp;<span class="number">1</span>);</span><br><span class="line">            x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lowbit-返回x的最后一位1"><a href="#lowbit-返回x的最后一位1" class="headerlink" title="lowbit():返回x的最后一位1"></a>lowbit():返回x的最后一位1</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261625070.jpg" alt="IMG_20240526_162338.jpg"></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x,res=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(x) x-=<span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 前缀和与差分</title>
      <link href="/2024/05/24/AcWing%20%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/"/>
      <url>/2024/05/24/AcWing%20%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="795-一维前缀和"><a href="#795-一维前缀和" class="headerlink" title="795.一维前缀和"></a><a href="https://www.acwing.com/problem/content/797/">795.一维前缀和</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>输入一个长度为n的整数序列，每个询问，输出原序列中从l个数到第r个数的和</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261607873.jpg" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)s[i]=s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="796-二维前缀和"><a href="#796-二维前缀和" class="headerlink" title="796.二维前缀和"></a><a href="https://www.acwing.com/activity/content/problem/content/830/">796.二维前缀和</a></h2><h3 id="题目重述-1"><a href="#题目重述-1" class="headerlink" title="题目重述"></a>题目重述</h3><p>输入一个n行m列的整数矩阵，每个询问包含四个整数x1，y1，x2，y2，表示一个子矩阵的左上角坐标和右下角坐标，输出子矩阵中所有数的和</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261607874.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261607875.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261607876.png" alt=""></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            s[i][j]=s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        cout&lt;&lt;s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="797-差分"><a href="#797-差分" class="headerlink" title="797.差分"></a><a href="https://www.acwing.com/problem/content/799/">797.差分</a></h2><h3 id="题目重述-2"><a href="#题目重述-2" class="headerlink" title="题目重述"></a>题目重述</h3><p>输入一个长度为n的整数序列，输入m个操作，每个操作包含三个整数l,r,c，表示将序列中[l,r]之间的每个数加上c</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261607877.jpg" alt=""></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=a[i<span class="number">-1</span>]+b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="798-差分矩阵"><a href="#798-差分矩阵" class="headerlink" title="798.差分矩阵"></a><a href="https://www.acwing.com/problem/content/800/">798.差分矩阵</a></h2><h3 id="题目重述-3"><a href="#题目重述-3" class="headerlink" title="题目重述"></a>题目重述</h3><p>输入一个n行m列的整数矩阵,再输入q个操作，每个操作包含五个整数，x1,y1,x2,y2.c，其中(x1,y1)和(x2,y2)表示一个子矩阵的左上角坐标和右下角坐标，将子矩阵的每个元素的值都加上c，输出操作后的矩阵</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261607878.png" alt="image.png"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1]+=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1]-=c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>]-=c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c;</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            a[i][j]=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 前缀和 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 高精度</title>
      <link href="/2024/05/23/AcWing%20%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2024/05/23/AcWing%20%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="大整数存储的思路"><a href="#大整数存储的思路" class="headerlink" title="大整数存储的思路"></a>大整数存储的思路</h2><p>将大整数的每一位存入数组中<br>a[0]存个位，a[1]存十位,数组末尾存高位<br>因为如果发生进位，直接在数组的末尾加一位。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261543760.jpg" alt=""></p><h2 id="791-高精度加法"><a href="#791-高精度加法" class="headerlink" title="791.高精度加法"></a><a href="https://www.acwing.com/problem/content/793/">791.高精度加法</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>给定两个正整数(不含前导0)，计算它们的和，整数的长度&lt;=100000</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>高精度模拟的是手动加法，大于10进位，小于10不进位。<br>每一次计算，都是Ai,Bi，ti(上一位的进位)<br>例如百位A2,B2,t2，十位上的进位<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261543761.jpg" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">add</span>(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||i&lt;B.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>())t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>())t+=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t=t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t)C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="792-高精度减法"><a href="#792-高精度减法" class="headerlink" title="792.高精度减法"></a><a href="https://www.acwing.com/problem/content/794/">792.高精度减法</a></h2><h3 id="题目重述-1"><a href="#题目重述-1" class="headerlink" title="题目重述"></a>题目重述</h3><p>给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。正整数长度&lt;=1e5</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261543762.jpg" alt=""><br>大整数是不能直接通过相减来判断大小的，要通过大整数存储数组一位一位判断。<br>大整数长度越长，值越大。长度相等情况下，判断每一位的大小</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>())<span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">sub</span>(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,t=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=A[i]-t;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>())t-=B[i];</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            C.<span class="built_in">push_back</span>(t+<span class="number">10</span>);</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            C.<span class="built_in">push_back</span>(t);</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))&#123;</span><br><span class="line">        C=<span class="built_in">sub</span>(A,B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        C=<span class="built_in">sub</span>(B,A);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="793-高精度乘法"><a href="#793-高精度乘法" class="headerlink" title="793.高精度乘法"></a><a href="https://www.acwing.com/problem/content/795/">793.高精度乘法</a></h2><h3 id="题目重述-2"><a href="#题目重述-2" class="headerlink" title="题目重述"></a>题目重述</h3><p>给定两个非负整数（不含前导0）,A和B， 计算A*B的值，A的长度&lt;=1e5,B&lt;=10000</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261543763.jpg" alt="">  </p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">mul</span>(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b)&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||t;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>())t+=A[i]*b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t=t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="794-高精度除法"><a href="#794-高精度除法" class="headerlink" title="794.高精度除法"></a><a href="https://www.acwing.com/problem/content/796/">794.高精度除法</a></h2><h3 id="题目重述-3"><a href="#题目重述-3" class="headerlink" title="题目重述"></a>题目重述</h3><p>给定两个非负整数(不含前导0)A,B，计算A/B的商和余数</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261543764.png" alt="image.png"></p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">div</span>(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r=r*<span class="number">10</span>+A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">div</span>(A,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)cout&lt;&lt;C[i];</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;r;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 高精度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 二分</title>
      <link href="/2024/05/22/AcWing%20%E4%BA%8C%E5%88%86/"/>
      <url>/2024/05/22/AcWing%20%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="789-数的范围"><a href="#789-数的范围" class="headerlink" title="789.数的范围"></a><a href="https://www.acwing.com/problem/content/description/791/">789.数的范围</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>有个升序排列的整数数组，返回一个元素k的起始位置和终止位置。</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>整数二分。<br>二分的本质不是单调性，假如存在一个分界点，在分界点的右边所有数都满足一个性质，但是分界点的左边都不满足这个性质。二分的作用就是找到分界点。<br>每一次二分都保证整个区间都包含分界点，当区间长度等于1，这个数就是分界点。二分法一定有解，但是不一定是题目的解<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261444770.jpg" alt=""><br>所以当一个序列有相等的数时，第一个模版可以求出x出现的最左端，第二个模版可以求出x出现的最右端。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">100010</span>;</span><br><span class="line">int q[N];</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        int l=<span class="number">0</span>,r=n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            int mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid]&gt;=x)r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l]!=x) cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout&lt;&lt;l&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            int l=<span class="number">0</span>,r=n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                int mid=l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid]&lt;=x)l=mid;</span><br><span class="line">                <span class="keyword">else</span> r=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;l&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="790-数的三次方根"><a href="#790-数的三次方根" class="headerlink" title="790.数的三次方根"></a><a href="https://www.acwing.com/problem/content/792/">790.数的三次方根</a></h2><h3 id="题目重述-1"><a href="#题目重述-1" class="headerlink" title="题目重述"></a>题目重述</h3><p>给定一个浮点数n，求它的三次方根</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    double x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    double l=-<span class="number">10000</span>,r=<span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-8</span>)&#123;</span><br><span class="line">        double mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid&gt;=x)r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 类和对象</title>
      <link href="/2024/05/22/C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/05/22/C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-类和对象"><a href="#第三章-类和对象" class="headerlink" title="第三章 类和对象"></a>第三章 类和对象</h2><h3 id="类与对象的基本概念"><a href="#类与对象的基本概念" class="headerlink" title="类与对象的基本概念"></a>类与对象的基本概念</h3><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>:  (可缺省)</span><br><span class="line">私有数据成员和函数成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">保护数据成员和函数成员</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">公有数据成员和函数成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说明<br>1 类内函数能访问private、protected、public三类成员<br>2 类外函数只能访问public成员<br>3 protected成员：类外不能访问，但是派生类的函数成员可以访问<br>4 private、protected、public不一定要全有，但至少要有一个<br>5 private、protected、public三者顺序随意<br>6 缺省时，默认为private</p><h4 id="成员函数的定义"><a href="#成员函数的定义" class="headerlink" title="成员函数的定义"></a>成员函数的定义</h4><h5 id="第一种-类内声明，类外定义"><a href="#第一种-类内声明，类外定义" class="headerlink" title="第一种 类内声明，类外定义"></a>第一种 类内声明，类外定义</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部定义的一般形式</span></span><br><span class="line">返回类型  类名::函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> point:: <span class="built_in">gety</span>()     <span class="comment">//类point的成员函数gety具体定义</span></span><br><span class="line">&#123;<span class="keyword">return</span>  y; &#125;</span><br></pre></td></tr></table></figure><p>说明：<br>1 函数名前记得加     类名::<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">point::gety</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>2 在定义成员函数时，对函数所带的参数，不但要说明它的类型，还要指出其参数名。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle::draw</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><br>3 在定义成员函数时，其返回类型一定要与函数原型中声明的返回类型匹配<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gety</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">point::gety</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="第二种-类内定义"><a href="#第二种-类内定义" class="headerlink" title="第二种 类内定义"></a>第二种 类内定义</h5><h6 id="隐式定义"><a href="#隐式定义" class="headerlink" title="隐式定义"></a>隐式定义</h6><p>函数的原型和定义都在类的内部完成<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getx</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> x&#125;</span><br></pre></td></tr></table></figure></p><h6 id="显式定义"><a href="#显式定义" class="headerlink" title="显式定义"></a>显式定义</h6><p>类内声明，类外定义，但是函数前用inline，显示的说明为内置函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span>;  <span class="comment">//类内声明</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> 类名::<span class="built_in">getx</span>()&#123;<span class="keyword">return</span> x&#125;   类外显式定义</span><br></pre></td></tr></table></figure><br>显示定义格式上=类外定义+加前缀inline，但是属于类内定义<br>可提高程序的执行效率，较长成员函数不设置为内置。</p><h4 id="对象的定义与引用"><a href="#对象的定义与引用" class="headerlink" title="对象的定义与引用"></a>对象的定义与引用</h4><h5 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h5><p>在声明类的同时，直接定义对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;op1,op2;</span><br></pre></td></tr></table></figure><br>声明类之后,使用时再定义对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point op1,op2;</span><br></pre></td></tr></table></figure></p><p>特点：<br>1声明一个类便声明了一种类型，，声明类的时候不分配存储空间，定义类的对象的时候再分配存储空间。<br>2 声明类同时定义的对象是一种全局对象，所有函数都可以使用他。</p><h5 id="对象中成员的访问"><a href="#对象中成员的访问" class="headerlink" title="对象中成员的访问"></a>对象中成员的访问</h5><p>对象名.数据成员名或对象名.成员函数名(实参表)<br>若是对象指针，则用”-&gt;”操作符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">point  *op;</span><br><span class="line">op-&gt;<span class="built_in">setpoint</span>(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p><h3 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h3><h4 id="如何给数据成员赋值"><a href="#如何给数据成员赋值" class="headerlink" title="如何给数据成员赋值"></a>如何给数据成员赋值</h4><p>定义类的时候不能给数据成员赋值。<br>使用成员函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p1;</span><br><span class="line">p1.<span class="built_in">set</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><p>1 构造函数的名字和类名相同<br>2 构造函数可以有任意类型的参数，但是不能有返回参数，也不能写void<br>3 定义对象时，编译系统会自动调用构造函数<br>如果没有定义构造函数，系统自动生成一个缺省的构造函数 Point(){}<br>4 可以类内定义，也可以（类内声明，类外定义，加类名：：）<br>5 构造函数被声明为公有函数，但他不能被显示调用，是在定义对象的同时被调用的。<br>当构造函数被定义为私有函数的时候，在创建对象的时候，构造函数被调用，程序会报错。<br>6 构造函数可以不带参数 Point(){}<br>7构造函数的类内声明类外定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span>  real,  imag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>(<span class="type">double</span>  r=<span class="number">0.0</span>,  <span class="type">double</span>  i=<span class="number">0.0</span>); </span><br><span class="line">&#125;;</span><br><span class="line">complex::<span class="built_in">complex</span>(<span class="type">double</span>  r,  <span class="type">double</span>  i) </span><br><span class="line">&#123; real=r;  imag=i; &#125;</span><br></pre></td></tr></table></figure></p><p>8 构造函数可以进行重载,但是可能引起二义性<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">x</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">   <span class="built_in">x</span>( );                      <span class="comment">//无参数构造函数</span></span><br><span class="line">   <span class="built_in">x</span>(<span class="type">int</span>  i=<span class="number">0</span>);          <span class="comment">//带默认参数的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">      <span class="function">x   <span class="title">one</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">//正确，调用x(int  i=0)</span></span><br><span class="line">      x   two;           <span class="comment">// 存在二义性，不知调用那一个构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>用构造函数直接创建对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名 对象名(实参表）    </span></span><br><span class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure><br>用new动态分配对象空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类名*对象指针= new 类名（实参表）</span></span><br><span class="line">Point *p=<span class="keyword">new</span> <span class="built_in">Point</span>(a,b)</span><br><span class="line">p-&gt;<span class="built_in">draw</span>()</span><br></pre></td></tr></table></figure></p><h4 id="初始化列表对数据成员进行初始化"><a href="#初始化列表对数据成员进行初始化" class="headerlink" title="初始化列表对数据成员进行初始化"></a>初始化列表对数据成员进行初始化</h4><p>类名::构造函数（参数表）：成员初始化表<br>成员初始化表格式：<br>成员1（初值1），成员2（初值2），…<br>成员按在类声明中的顺序初始化，与初始化表中的顺序无关<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">A</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">float</span>  f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> I, <span class="type">int</span>  J, <span class="type">float</span>  F):<span class="built_in">i</span>(I),<span class="built_in">j</span>(J),<span class="built_in">f</span>(F)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>初始化列表在继承中多次出现<br>构造函数用初始化列表  ：之后无需写参数类型</p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>1 析构函数名与类名不完全相同，前面必须加一个波浪号(~)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Point</span>()&#123;&#125;</span><br></pre></td></tr></table></figure><br>2 析构函数没有参数,没有返回值，而且不能重载，在一个类中只能由一个析构函数。<br>3.当撤销对象时，编译系统自动调用析构函数<br>对象被定义函数体中，当函数运行结束后会自动撤销所有的局部变量，也会自动撤销对象，析构函数自动调用。<br>new动态创建，delete释放时会调用析构函数<br>不用delete释放是不会调用析构函数的<br>4.每一个类必有一个析构函数，但没有定义析构函数的时候，编译系统自动地生成一个默认地析构函数。<br>5析构函数的类外定义<br>A::~A（）{}</p><h3 id="对象数组和对象指针"><a href="#对象数组和对象指针" class="headerlink" title="对象数组和对象指针"></a>对象数组和对象指针</h3><h4 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;Point ob[<span class="number">4</span>];</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)  </span><br><span class="line">    ob[i].<span class="built_in">set_x</span>(i);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) </span><br><span class="line">   cout&lt;&lt;ob[i].<span class="built_in">get_x</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象数组的初始化</span></span><br><span class="line">Point p[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">Point p[<span class="number">4</span>]=&#123;<span class="built_in">Point</span>(<span class="number">1</span>),<span class="built_in">Point</span>(<span class="number">2</span>),<span class="built_in">Point</span>(<span class="number">3</span>),<span class="built_in">Point</span>(<span class="number">4</span>)&#125;</span><br></pre></td></tr></table></figure><h4 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h4><p>1 指针引用单个对象成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p1,*p</span><br><span class="line">p=&amp;p1;</span><br><span class="line">p1-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><br>2 对象指针引用对象数组<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point p[<span class="number">2</span>]，*p0</span><br><span class="line">p0=p  <span class="comment">//p指向ob[0]</span></span><br><span class="line">p0++;  p指向ob[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><h4 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h4><p>当一个成员函数被调用时，C++自动产生一个参数，这个参数是一个类指针this ，可以指向该类的一个对象，这个对象就是接受函数调用的对象。<br>c++中同一个类的不同对象有着相同的成员函数和数据，编译系统给这个成员函数开辟了内存空间，同时有this指针指向不同的对象地址从而调用不同的对象的函数指令<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Void area（*<span class="keyword">this</span>）</span><br><span class="line"><span class="keyword">this</span>-&gt;x</span><br><span class="line">A.<span class="built_in">area</span>(&amp;a)</span><br></pre></td></tr></table></figure></p><h3 id="向函数传递对象"><a href="#向函数传递对象" class="headerlink" title="向函数传递对象"></a>向函数传递对象</h3><h4 id="对象作为函数的参数"><a href="#对象作为函数的参数" class="headerlink" title="对象作为函数的参数"></a>对象作为函数的参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sqr_it</span><span class="params">(tr ob)</span></span></span><br><span class="line"><span class="function"></span>&#123; ob.<span class="built_in">set_i</span>(ob.<span class="built_in">get_i</span>( )*ob.<span class="built_in">get_i</span>( ));       <span class="comment">//形参对象i=i*i</span></span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;形参对象 i 的值为 &quot;</span>&lt;&lt;ob.<span class="built_in">get_i</span>( )&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">tr  <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line"><span class="built_in">sqr_it</span>(obj); </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="对象指针作为函数的参数"><a href="#对象指针作为函数的参数" class="headerlink" title="对象指针作为函数的参数"></a>对象指针作为函数的参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sqr_it</span><span class="params">(tr *ob)</span></span></span><br><span class="line"><span class="function"></span>&#123;  ob-&gt;<span class="built_in">set_i</span>(ob-&gt;<span class="built_in">get_i</span>()*ob-&gt;<span class="built_in">get_i</span>());  </span><br><span class="line">    cout &lt;&lt; “形参对象指针ob-&gt; i 的值为 <span class="string">&quot;&lt;&lt;ob-&gt;get_i()&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">tr  obj(10); </span></span><br><span class="line"><span class="string">sqr_it(&amp;obj); </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="对象引用作为函数的参数"><a href="#对象引用作为函数的参数" class="headerlink" title="对象引用作为函数的参数"></a>对象引用作为函数的参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sqr_it</span><span class="params">(tr  &amp;ob)</span></span></span><br><span class="line"><span class="function"></span>&#123;  ob-&gt;<span class="built_in">set_i</span>(ob.<span class="built_in">get_i</span>()*ob.<span class="built_in">get_i</span>());  </span><br><span class="line">    cout &lt;&lt; “形参ob对象 i 的值为 <span class="string">&quot;&lt;&lt;ob.get_i()&lt;&lt;endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">tr  obj(10);  </span></span><br><span class="line"><span class="string">sqr_it(obj); </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h3 id="对象赋值与赋值"><a href="#对象赋值与赋值" class="headerlink" title="对象赋值与赋值"></a>对象赋值与赋值</h3><h4 id="对象赋值语句"><a href="#对象赋值语句" class="headerlink" title="对象赋值语句"></a>对象赋值语句</h4><p>同类型对象可以进行赋值。赋值时，数据成员逐位复制<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myclass  o1, o2;</span><br><span class="line">o1.<span class="built_in">set</span>(<span class="number">20</span>,<span class="number">5</span>);</span><br><span class="line">o2=o1;               </span><br></pre></td></tr></table></figure></p><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><p>1 特殊的构造函数，用于对象赋值和赋值<br>2 函数名与类名相同，没有返回值类型<br>3 系统提供了默认拷贝构造函数，也可以自己定义<br>4 函数只有一个参数，是同类对象的引用<br>自定义拷贝函数的格式<br>类名(const  类名 &amp;对象名){<br>//函数体<br>}<br>调用拷贝构造函数的情况<br>1 函数的形参是对象，在将实参和形参相互结合的过程中会调用析构函数<br>2函数的返回值是对象，函数调用完毕，返回对象<br>3 用对象去初始化同类的另一个对象<br>o2(o1)    o2=o1<br>4 当程序中含有拷贝构造函数时，系统不会有默认构造函数</p><h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">5</span>]=<span class="string">&quot;abcd&quot;</span> ;</span><br><span class="line"><span class="type">char</span> str2[]=<span class="string">&quot;efgh&quot;</span> ;</span><br><span class="line">cout&lt;&lt;<span class="built_in">strcat</span>(str1,str2);    <span class="comment">//调用strcat函数,C语言</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">string str1,str2;  </span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(“China”)</span></span>; 或者string st3=<span class="string">&quot;China&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405221958534.png" alt="image.png"></p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><h4 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h4><p>用static说明的成员称为静态成员，有静态数据成员和静态函数成员，静态成员由同一类的多个对象共享，即无论一个类定义多少个对象，都共用一个静态数据成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> count； <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="comment">//类外进行初始化</span></span><br><span class="line"><span class="type">int</span> A::count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//静态数据成员可以在其他函数内进行赋值</span></span><br><span class="line">A：：count=<span class="number">200</span>  <span class="comment">//不用写int</span></span><br><span class="line"><span class="comment">//静态数据成员可在程序中访问</span></span><br></pre></td></tr></table></figure><p>1 静态数据成员属于类(不属于某个对象)，在编译时分配空间，在对象被建立之前就存在，公有的静态数据成员可以在对象定义之前被访问。<br>访问方式：类名::静态数据成员名<br>也可以对象定义之后进行访问，公有的静态数据成员，也可通过对象进行访问。<br>访问格式：<br>对象名.静态数据成员名<br>对象指针-&gt;静态数据成员名<br>2静态数据承成员必须在类外进行初始化（main函数之前）<br>数据类型 类名::静态数据成员名=初始值<br>类外进行初始化的时候不用写static<br>3.静态数据成员是多个对象公有的数据，可以避免采用全局变量.<br>4私有静态数据成员不能被类外函数进行访问，同时也不能通过对象进行访问。</p><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><p>静态成员函数:被static修饰的成员函数<br>1.静态成员函数在类外进行定义时，不要用static<br>2.静态成员函数一般只访问静态数据成员，两者结合达成同类对象共享数据目的<br>3.私有静态成员函数不能被外部函数和对象进行访问。<br>4.静态成员函数可在定义对象之前处理静态数据成员<br>5 编译系统将静态成员函数定为内联<br>6 静态成员函数没有this指针，调用格式:<br>类名::静态成员函数名<br>7 静态成员函数不访问类中的非静态成员,只能访问静态成员.如果实在需要访问，用对象引用做函数参数，再通过对象访问。</p><h3 id="类组合"><a href="#类组合" class="headerlink" title="类组合"></a>类组合</h3><p>一个类的对象可以作为另一个类的数据成员，即对象成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">类名<span class="number">1</span> 对象<span class="number">1</span>；</span><br><span class="line">类名<span class="number">2</span> 对象<span class="number">2</span>；</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//类组合的构造函数可以用初始化表</span></span><br><span class="line">X::X（参数表<span class="number">0</span>):对象<span class="number">1</span>(参数表<span class="number">1</span>),对象<span class="number">2</span>(参数表<span class="number">2</span>)...</span><br><span class="line">&#123;</span><br><span class="line">...构造函数体；</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>用关键字friend可以将普通函数、别类的成员函数或者别类定义为某类的友元。这些友元可以访问该类的私有成员。友元分友元普通函数、友元函数成员、友元类。<br>友元函数作用之一是提高程序的效率，而不是加强类的封装性和隐蔽性，<br>友元函数可以直接访问不同类的私有成员。（数据成员和函数成员）<br>友元函数是独立于当前类的外部函数<br>友元普通函数，友元成员函数，友元类<br>关键词friend</p><h4 id="普通函数为友元函数"><a href="#普通函数为友元函数" class="headerlink" title="普通函数为友元函数"></a>普通函数为友元函数</h4><p>在类定义时，在类内定义一个函数，该函数前加上 friend表示该函数不是成员函数，而是本类的友元函数。友元函数可以内嵌或外部定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span> &#123;</span><br><span class="line">       <span class="type">char</span> *name;</span><br><span class="line">       <span class="type">int</span> age;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">girl</span>(<span class="type">char</span> *n, <span class="type">int</span> d);                <span class="comment">//构造函数</span></span><br><span class="line">       &#123; name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>]; <span class="built_in">strcpy</span>(name,n); age=d; &#125;           </span><br><span class="line">       <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">disp</span><span class="params">(girl &amp; x)</span></span>;                <span class="comment">//声明disp友元函数</span></span><br><span class="line">        ~<span class="built_in">girl</span>() &#123; <span class="keyword">delete</span> name; &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">(girl &amp;x)</span>                     <span class="comment">//定义友元函数</span></span></span><br><span class="line"><span class="function"></span>&#123; cout &lt;&lt;<span class="string">&quot;女孩名字: &quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,年龄: &quot;</span>&lt;&lt;x.age&lt;&lt;endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="function">girl <span class="title">e</span><span class="params">(<span class="string">&quot;Chen Xingwei&quot;</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">   <span class="built_in">disp</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>友元函数不是类的成员函数，在类外定义定义友元函数时，不需要添加类名::,也不需要friend<br>友元函数不是类的成员，不能直接访问类的私有数据。需要通过对象，对象引用，对象指针来访问本类的私有成员</p><p>友元的作用：<br>1友元可以让函数访问多个类，共享数据<br>2.友元用于运算符重载<br>3.封装机制的补充，开了一个小口子，不会彻底丧失数据安全性，不会大幅降低可维护性</p><h4 id="成员函数为友元函数"><a href="#成员函数为友元函数" class="headerlink" title="成员函数为友元函数"></a>成员函数为友元函数</h4><p>一个函数既是某个类(类1)的成员函数，又在另一个类（类2）中声明为友元函数。该函数称为友元成员函数。它能访问类1和类2私有成员。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">girl</span>(<span class="type">char</span> *n, <span class="type">int</span> d) </span><br><span class="line">    &#123;  name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>]; <span class="built_in">strcpy</span>(name,n); age=d;&#125;</span><br><span class="line">    <span class="comment">//声明boy类的成员函数disp()是本类girl的友元函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span></span>;  </span><br><span class="line">    ~<span class="built_in">girl</span>() &#123; <span class="keyword">delete</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;男孩名字: &quot;</span>&lt;&lt;name</span><br><span class="line">    &lt;&lt;<span class="string">&quot;,年龄: &quot;</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;女孩名字: &quot;</span> &lt;&lt;x.name</span><br><span class="line">    &lt;&lt; <span class="string">&quot;,年龄: &quot;</span>&lt;&lt;x.age&lt;&lt;endl;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>在一个类1中可以说明另一个类2，前面加friend，则类2为类1的友元类。类2的函数成员可以访问类1的私有成员和类2的私有成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">girl</span> &#123;</span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">friend</span> boy;         <span class="comment">//声明 boy 类是 girl 类的友元类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">girl</span>(<span class="type">char</span> *n, <span class="type">int</span> d) </span><br><span class="line">  &#123; name=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(n)+<span class="number">1</span>]; <span class="built_in">strcpy</span>(name,n); age=d;&#125;</span><br><span class="line">  ~<span class="built_in">girl</span>() &#123; <span class="keyword">delete</span> name; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">boy::disp</span><span class="params">(girl &amp;x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//访问本类对象成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;男孩名字: &quot;</span>&lt;&lt;name&lt;&lt;<span class="string">&quot;,年龄: &quot;</span>&lt;&lt;age&lt;&lt;endl; </span><br><span class="line">    <span class="comment">//访问友类对象成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;女孩名字: &quot;</span>&lt;&lt;x.name&lt;&lt;<span class="string">&quot;,年龄: &quot;</span>&lt;&lt;x.age&lt;&lt;endl;                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常类型"><a href="#常类型" class="headerlink" title="常类型"></a>常类型</h3><p>常类型：被关键字const修饰的类型就是常类型。常类型变量不可改变。</p><h4 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h4><p>const 类型&amp;引用名<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span>  <span class="type">int</span>  &amp;i,  <span class="type">const</span>  <span class="type">int</span>  &amp;j)</span></span>;   <span class="comment">//常引用</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="type">int</span> a=<span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">30</span>;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;<span class="built_in">add</span>(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">const</span>  <span class="type">int</span>  &amp;i,  <span class="type">const</span>  <span class="type">int</span>  &amp;j)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">      <span class="comment">//i=i+20;       错误，i值不可改变</span></span><br><span class="line">      <span class="keyword">return</span>  i+j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h4><p>值无法修改，初始化只能通过初始化表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"> <span class="keyword">class</span>  <span class="title class_">Date</span>&#123;                   </span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">         <span class="type">const</span>  <span class="type">int</span>  year;                      <span class="comment">//常数据成员</span></span><br><span class="line">         <span class="type">const</span>  <span class="type">int</span>  month;</span><br><span class="line">         <span class="type">const</span>  <span class="type">int</span>  day;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d);</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">showDate</span><span class="params">( )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Date::<span class="built_in">Date</span>(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d):<span class="built_in">year</span>(y),<span class="built_in">month</span>(m),<span class="built_in">day</span>(d)</span><br><span class="line">&#123;    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><p>const A a(1,2)<br>常对象只能调用常成员函数</p><h4 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h4><p> int function(int x) const ；<br>常成员函数可以使用数据成员，但是不能进行修改</p><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><p>构造函数和析构函数的主要重用和特性<br>构造函数的作用：为对象分配内存空间，进行初始化。<br>特性：<br>1函数名与类名相同。<br>2.构造函数没有返回值<br>3一般被定义为公有成员，私有成员会导致定义对象时发生错误<br>4.在定义对象的同时被自动调用，而且只执行一次<br>5每个类都有构造函数，如果自己没定义，系统自动生成构造函数</p><p>析构函数的作用： 释放为对象分配的内存空间<br>特性：<br>1析构函数名与类名不完全相同，前面得加~<br>2，无返回任何值<br>3.析构函数没有参数，因此不能被重载<br>4.撤销对象时，系统自动调用析构函数。</p><p>什么是对象数组<br>对象数组的元素是对象，不仅具有数据成员，还有函数成员</p><p>什么是this指针<br>c++为成员函数提供了this指针，是自引用指针，每当创建一个对象时，this就指向该对象，this指针的值是被调用成员函数所在对象的起始地址<br>每当调用一个成员函数时，系统就将this指针作为一个隐含的参数传递给该函数。</p><p>友元函数的作用<br>运算符重载，当一个函数需要访问多个类的时候需要用到友元函数，<br>友元函数不是当前类的成员函数，而是当前类的外部函数，但是访问该类的所有数据成员和成员函数。</p>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章_栈与队列_part03</title>
      <link href="/2024/05/22/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part03/"/>
      <url>/2024/05/22/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part03/</url>
      
        <content type="html"><![CDATA[<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239.滑动窗口最大值</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述"></a>题目重述</h3><p>有一个整数数组nums，大小为k的滑动窗口从最左侧移动到数组最右侧，每次滑动窗口都有一个最大值，返回由最大值组成的数组</p><h3 id="看到题目的第一想法"><a href="#看到题目的第一想法" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>两层循环，时间复杂度o(n*k)，超出时间限制41/51<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n-k;i++)&#123;</span><br><span class="line">            <span class="type">int</span> count=nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;i+k;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;count)count=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>整个滑动窗口移动的过程，与队列的pop掉移除元素，push移进元素。并且每次获得最大值的时候都是front()，这样就好了。<br>我们用到了单调队列，本体中的单调递减的，我们使用双端队列deque实现，front存当前滑动窗口的最大值。每次push时，将dq中元素小于等于nums[i]的元素都删掉(小于nums[i]的值是不可能添加到res的，删除就可以了)，双端队列size不超过k。<br>双端队列存的是元素的下标，当dq.front()==i-k时，说明当前最大值是滑动窗口要移除的值。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405221650010.jpg" alt="IMG_20240522_152722.jpg"><br>代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt;dq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>()&amp;&amp;dq.<span class="built_in">front</span>()==i-k)&#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>()&amp;&amp;nums[dq.<span class="built_in">back</span>()]&lt;=nums[i])&#123;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347.前k个高频元素"></a>347.前k个高频元素</h2><h3 id="题目重述-1"><a href="#题目重述-1" class="headerlink" title="题目重述"></a>题目重述</h3><p>有一个整数数组nums，和一个整数k，返回频率前k高的元素</p><h3 id="看到题目的第一想法-1"><a href="#看到题目的第一想法-1" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>unordered_map将值与频率映射，然后返回前k高的元素，遍历一次nums，然后在while(k—)再遍历k次unordered_map,时间复杂度o(k*n)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            umap[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> iter=umap.<span class="built_in">begin</span>();iter!=umap.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">                <span class="type">int</span> num=iter-&gt;second;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;count)&#123;</span><br><span class="line">                    count=num;</span><br><span class="line">                    index=iter-&gt;first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            umap[index]=<span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">push_back</span>(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>使用了最小堆和最大堆的方式，最小堆和最大堆的底层实现都是优先队列，特征就是自动排序，我们按照umap的value进行排序，使用最小堆，如果当前元素&gt;k，就pop，即将当前出现频率最小的弹出去了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            umap[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;min_heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=umap.<span class="built_in">begin</span>();iter!=umap.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            min_heap.<span class="built_in">push</span>(&#123;iter-&gt;second,iter-&gt;first&#125;);</span><br><span class="line">            <span class="keyword">if</span>(min_heap.<span class="built_in">size</span>()&gt;k)min_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!min_heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(min_heap.<span class="built_in">top</span>().second);</span><br><span class="line">            min_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 归并排序</title>
      <link href="/2024/05/21/AcWing%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/05/21/AcWing%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="787-归并排序"><a href="#787-归并排序" class="headerlink" title="787.归并排序"></a><a href="https://www.acwing.com/problem/content/789/">787.归并排序</a></h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>1确定分界点，mid=(l+r)/2;<br>注意：归并排序的分界点是数组中点下标，就是将数组一分为二。<br>而快速排序的分界点是数组的值。<br>2递归排序左部分和右部分数组，使两个数组都是有序的<br>3归并排序，将两个数组合二为一，将两个有序数组合成排好序的最终数组</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>如何将两个数组合二为一？<br>新建一个数组temp，通过比较left数组和right数组的最左端的值，将较小的值放入temp。如果left数组或者right数组遍历完了，将另外一个数组剩余元素加到temp里。之后将temp数组元素的值赋给q<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[i]&lt;=q[j])temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">else</span> temp[k++]=q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r)temp[k++]=q[j++];</span><br><span class="line"><span class="keyword">for</span>(int i=l,k=<span class="number">0</span>;i&lt;=r;i++,k++)&#123;</span><br><span class="line">    q[i]=temp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">1000010</span>;</span><br><span class="line">int q[N],temp[N];</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge_sort</span>(<span class="params">int q[],int l,int r</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    int mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="title function_">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="title function_">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    int k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j])temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)temp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(int i=l,k=<span class="number">0</span>;i&lt;=r;i++,k++)&#123;</span><br><span class="line">        q[i]=temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="title function_">merge_sort</span>(q,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)<span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="788-逆序对的数量"><a href="#788-逆序对的数量" class="headerlink" title="788.逆序对的数量"></a><a href="https://www.acwing.com/problem/content/790/">788.逆序对的数量</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于数列的第 𝑖 个和第 𝑗 个元素，如果满足 𝑖&lt;𝑗 且 𝑎[𝑖]&gt;𝑎[𝑗]，则其为一个逆序对；否则不是。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用归并排序来计算逆序对的数量<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405261436463.jpg" alt=""></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">100010</span>;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line">int n;</span><br><span class="line">int q[N],temp[N];</span><br><span class="line"></span><br><span class="line">ll <span class="title function_">merge_sort</span>(<span class="params">int l,int r</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    int mid =l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="title function_">merge_sort</span>(l,mid);</span><br><span class="line">    <span class="title function_">merge_sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    int i=l,j=mid+<span class="number">1</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++]=q[j++];</span><br><span class="line">            res+=mid-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)temp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">0</span>,i=l;i&lt;=r;i++,k++)&#123;</span><br><span class="line">        q[i]=temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    cout&lt;&lt;<span class="title function_">merge_sort</span>(<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 快排与快速选择</title>
      <link href="/2024/05/21/AcWing%20%E5%BF%AB%E6%8E%92%E4%B8%8E%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"/>
      <url>/2024/05/21/AcWing%20%E5%BF%AB%E6%8E%92%E4%B8%8E%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序模版"><a href="#快速排序模版" class="headerlink" title="快速排序模版"></a><a href="https://www.acwing.com/problem/content/787/">快速排序模版</a></h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>快排的基本思想的基于分而治之<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br></pre></td></tr></table></figure><br>1 确定分界点x，分界点x=q<a href="左端点">l</a>，q<a href="右端点">r</a>，q[l+r&gt;&gt;1]中点，随机点<br>注意：分界点原位置上的数不一定是x，例如选择中点为x，一轮快排后的q[l+r&gt;&gt;1]不一定等于x。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405211715942.jpg" alt=""><br>2 调整区间<br>左区间所有的数都小于等于x，<br>右区间所有的数都大于等于x<br>3递归处理左右两端</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>难点：如何调整区间<br>1 开辟两个额外空间，数组a[],b[]<br>遍历原数组q，对于q[i]&gt;x,放入a[]中<br>  对于q[i]<x,放入b[]中2设置左右指针，i指针从left-1开始遍历，如果q[i]<x,i指针右移，j 指针从right+1开始遍历，如果q[i]>x,指针左移,对于一个i,j移动的时候，可以多次重复操作，直到两者交叉<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int  i=l-<span class="number">1</span>,j=r+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">  <span class="keyword">while</span>(q[++i]&lt;x);</span><br><span class="line">  <span class="keyword">while</span>(q[--j]&gt;x);</span><br><span class="line">  <span class="keyword">if</span>(i&lt;j)<span class="title function_">swap</span>(q[i],q[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">100010</span>;</span><br><span class="line">int q[N];</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">quick_sort</span>(<span class="params">int q[],int l,int r</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    int i=l-<span class="number">1</span>,j=r+<span class="number">1</span>,x=q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="title function_">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="title function_">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    int n;</span><br><span class="line">    <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) <span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="title function_">quick_sort</span>(q,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++) <span class="title function_">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405211715944.jpg" alt=""></p><h2 id="786-第k个数"><a href="#786-第k个数" class="headerlink" title="786.第k个数"></a><a href="https://www.acwing.com/problem/content/788/">786.第k个数</a></h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>使用快速选择算法求出数列从小到大排序后的第k个数。<br>当然可以先将数组进行快排，然后q[k-1]，但是也可以使用快速选择算法。<br>快速选择算法是在快排模版的基础上进行修改的<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405211715945.jpg" alt=""><br>当k=3时，第3个数肯定在快排后数组的右边及SR那部分，那完全没必要对左边进行快排<br>quick_sort(j+1,r,k-sl)</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="keyword">const</span> int N=<span class="number">100010</span>;</span><br><span class="line">int q[N];</span><br><span class="line">int n,k;</span><br><span class="line">int <span class="title function_">quick_sort</span>(<span class="params">int l,int r,int k</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> q[l];</span><br><span class="line">    int i=l-<span class="number">1</span>,j=r+<span class="number">1</span>,x=q[l+r&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++i]&lt;x);</span><br><span class="line">        <span class="keyword">while</span>(q[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="title function_">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    int sl=j-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;sl) <span class="keyword">return</span> <span class="title function_">quick_sort</span>(j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="title function_">quick_sort</span>(l,j,k);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;n;i++)<span class="title function_">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    cout&lt;&lt;<span class="title function_">quick_sort</span>(<span class="number">0</span>,n-<span class="number">1</span>,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟-1"><a href="#模拟-1" class="headerlink" title="模拟"></a>模拟</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405211715946.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 快排 快速选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 概论</title>
      <link href="/2024/05/21/C++%20%E6%A6%82%E8%AE%BA/"/>
      <url>/2024/05/21/C++%20%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-面向对象方法概述"><a href="#第一章-面向对象方法概述" class="headerlink" title="第一章 面向对象方法概述"></a>第一章 面向对象方法概述</h2><h3 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a>面向过程和面向对象的区别</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>面向过程关注要解决什么问题，以及解决问题的实现步骤<br>面向对象关注解决问题的对象，以及解决这个问题时各个对象之间的交互</p><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><p>面向过程使用函数组织代码<br>面向对象使用类和对象组织代码</p><h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><p>面向过程适合简单任务和快速开发<br>面向对象更易于维护和扩展。</p><h3 id="面向对象的基本概念"><a href="#面向对象的基本概念" class="headerlink" title="面向对象的基本概念"></a>面向对象的基本概念</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><p>对象：现实世界的任何事物，具有属性和行为<br>类：对一组具有共同的属性和行为的对象的抽象<br>类是对象的抽象<br>对象是类的实例</p><h4 id="消息和方法"><a href="#消息和方法" class="headerlink" title="消息和方法"></a>消息和方法</h4><p>消息：一个对象对于另一个对象发出的请求，称为“消息”，对象之间的交互<br>方法：对象所能实现的行为，通过成员函数来实现<br>对象接受消息，实现相应的方法<br>有了方法，才能响应响应的消息</p><h3 id="面向对象程序设计的基本特征"><a href="#面向对象程序设计的基本特征" class="headerlink" title="面向对象程序设计的基本特征"></a>面向对象程序设计的基本特征</h3><p>抽象：将有关事物的共性归纳，集中。<br>封装：封装是指把数据和实现操作的代码都集中的放在对象内部，尽可能隐蔽对象的内部细节。<br>继承：后者继承前者的基本特征，同时增加一些新的特征。<br>多态：不同对象收到相同消息时，执行不同的操作。<br>编译时的多态性：通过函数重载和运算符重载来实现。<br>运行时的多态性：通过虚函数来实现。</p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>C++是面向对象语言吗？<br>C++是一门面向对象和面向过程相结合的语言，而不是纯面向对象语言。<br>什么是面向对象程序设计？<br>什么是对象？</p><h2 id="第二章-C-概述"><a href="#第二章-C-概述" class="headerlink" title="第二章 C++概述"></a>第二章 C++概述</h2><h3 id="C-起源和特点"><a href="#C-起源和特点" class="headerlink" title="C++起源和特点"></a>C++起源和特点</h3><p>1.是C的拓展，兼容c<br>2.保持C的简洁，高效，增加了可重用性，可扩展性，，可靠性，可维护性。<br>3.增加面向对象的机制：<br>抽象<br>封装<br>继承<br>多态：函数重载，运算符重载，虚函数。</p><h3 id="C-源程序构成"><a href="#C-源程序构成" class="headerlink" title="C++源程序构成"></a>C++源程序构成</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line"><span class="comment">//类的声明部分</span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">A</span>  &#123;</span><br><span class="line">   int  x,y,z;        <span class="comment">//类A的数据成员声明</span></span><br><span class="line">   <span class="title function_">fun</span>(<span class="params"> </span>)   &#123;</span><br><span class="line">        …</span><br><span class="line">   &#125;                      <span class="comment">//类A的成员函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类的使用部分</span></span><br><span class="line"><span class="keyword">void</span>  <span class="title function_">main</span>(<span class="params"> </span>) </span><br><span class="line">&#123;   A  a;              <span class="comment">//创建一个类A的对象a</span></span><br><span class="line">    a.<span class="title function_">fun</span>( );         <span class="comment">//给对象a发消息，调用成员函数fun( )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-在非面向对象方面扩充"><a href="#C-在非面向对象方面扩充" class="headerlink" title="C++在非面向对象方面扩充"></a>C++在非面向对象方面扩充</h3><h4 id="注释行"><a href="#注释行" class="headerlink" title="注释行"></a>注释行</h4><p>/<em>    </em>/     C的注释<br>//         C++的注释</p><h4 id="新的I-O流"><a href="#新的I-O流" class="headerlink" title="新的I/O流"></a>新的I/O流</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line">cin&gt;&gt;</span><br><span class="line">cout&lt;&lt;</span><br></pre></td></tr></table></figure><h4 id="灵活的局部变量说明"><a href="#灵活的局部变量说明" class="headerlink" title="灵活的局部变量说明"></a>灵活的局部变量说明</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">f</span>(<span class="params">  </span>)</span><br><span class="line">&#123; </span><br><span class="line">    int  i;</span><br><span class="line">    i=<span class="number">10</span>;</span><br><span class="line">    int  j;</span><br><span class="line">    j=<span class="number">25</span>;</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">5</span>;k&gt;=<span class="number">0</span>;k--) …..</span><br><span class="line">    …….</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言中，变量必须在块的开头声明，不能在其他地方声明。C++没这个要求</span></span><br></pre></td></tr></table></figure><h4 id="结构、联合和枚举名可直接作为类型名"><a href="#结构、联合和枚举名可直接作为类型名" class="headerlink" title="结构、联合和枚举名可直接作为类型名"></a>结构、联合和枚举名可直接作为类型名</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*定义枚举类型名*/</span></span><br><span class="line">enum bool &#123;<span class="variable constant_">FALSE</span>,  <span class="variable constant_">TRUE</span>&#125;;</span><br><span class="line"><span class="comment">/*定义结构枚举类型名*/</span></span><br><span class="line"><span class="title class_">Struct</span>  student  &#123;</span><br><span class="line">         int    sno;</span><br><span class="line">         char *sneme;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">C定义枚举类型变量：  enum  bool   done;</span><br><span class="line">定义结构类型变量： struct  student  s1, s2;</span><br><span class="line"></span><br><span class="line">C++定义枚举类型变量： bool   done;</span><br><span class="line">定义结构类型变量： student  s1, s2;</span><br></pre></td></tr></table></figure><h4 id="const-修饰符"><a href="#const-修饰符" class="headerlink" title="const 修饰符"></a>const 修饰符</h4><p>常量一旦建立，就不能更改<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#define  <span class="variable constant_">LIMIT</span>   <span class="number">100</span>                 C</span><br><span class="line"><span class="keyword">const</span>  int  <span class="variable constant_">LIMIT</span>=<span class="number">100</span>;               C++</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.<span class="property">h</span>&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">int a=<span class="number">1</span>;</span><br><span class="line">#define <span class="variable constant_">T1</span> a+a</span><br><span class="line">#define <span class="variable constant_">T2</span> <span class="variable constant_">T1</span>-<span class="variable constant_">T1</span></span><br><span class="line">cout&lt;&lt;<span class="variable constant_">T2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-2 &lt;&lt;a+a-a+a&lt;&lt;1+1-1+1</span></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)&#123;</span><br><span class="line">int a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> int <span class="variable constant_">T1</span>=a+a</span><br><span class="line"><span class="keyword">const</span> int <span class="variable constant_">T2</span>=<span class="variable constant_">T1</span>-<span class="variable constant_">T1</span></span><br><span class="line">cout&lt;&lt;<span class="variable constant_">T2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针常量</span></span><br><span class="line">char* name=<span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="keyword">const</span> char* name =<span class="string">&quot;jack&quot;</span>  <span class="comment">//指针常量</span></span><br><span class="line"><span class="comment">//不可以改变数据，即不可给name[1]=&#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">//但是可以改变地址，即可以name=&quot;alice&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常指针</span></span><br><span class="line"><span class="keyword">const</span> name=<span class="string">&quot;jack&quot;</span></span><br><span class="line">char* <span class="keyword">const</span> name=<span class="string">&quot;jack&quot;</span> <span class="comment">//常指针</span></span><br><span class="line"><span class="comment">//name的地址恒定不可改变，即不允许name=&quot;alice&quot;;</span></span><br><span class="line"><span class="comment">//但是可以改变数据，即name[1]=&#x27;a&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指向常量的常指针</span></span><br><span class="line"><span class="keyword">const</span> char* <span class="keyword">const</span> name=<span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="comment">//地址和数据都不可以改变</span></span><br></pre></td></tr></table></figure><br>函数的形参用const说明，保证形参在该函数内部不被改动<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">i_Max</span>(<span class="keyword">const</span> int*ptr);<span class="comment">//寻找整型数组a[200]中的最大值</span></span><br><span class="line"><span class="title function_">i_Max</span>(a);</span><br></pre></td></tr></table></figure></p><h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405212242357.png" alt="image.png"></p><p>1 在内联函数体内不要有for语句和switch语句等较为复杂的控制语句。<br>2 若内联函数较长(1-5条语句最佳),且调用太频繁时,程序将加长很多<br>3 内置函数与#define相同的作用和相似的机理，但消除了#define的不安全因素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="title function_">doub</span>(x)  x*<span class="number">2</span></span><br><span class="line">cout&lt;&lt;<span class="title function_">doub</span>(<span class="number">1</span>+<span class="number">2</span>)   <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">inline int <span class="title function_">doub</span>(<span class="params">int x</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> x*<span class="number">2</span>; &#125;</span><br><span class="line">cout&lt;&lt;<span class="title function_">doub</span>(<span class="number">1</span>+<span class="number">2</span>) <span class="comment">//9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数表)</span><br><span class="line">#include &lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span>(char *s);         <span class="comment">//函数原型、函数声明</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"> </span>)                        </span><br><span class="line">&#123;<span class="title function_">write</span>(<span class="string">&quot;Hello, world!&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">write</span>(char *s)无分号</span><br><span class="line">&#123; cout&lt;&lt;s&lt;&lt;endl;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用在前，定义在后，要先声明</span></span><br></pre></td></tr></table></figure><p>函数原型：<br>Int area(int,int);和我之前理解的函数声明一致，叫函数原型，有‘’ ；‘’号<br>函数原型中的参数名是可以进行省略的<br>函数的第一行必须包括参数名，无；有{}</p><h4 id="带有缺省参数的函数"><a href="#带有缺省参数的函数" class="headerlink" title="带有缺省参数的函数"></a>带有缺省参数的函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int  <span class="title function_">special</span>(int x=<span class="number">5</span>, float y=<span class="number">5.3</span>);</span><br><span class="line"><span class="comment">//调用；</span></span><br><span class="line"><span class="title function_">special</span>( );                  <span class="comment">//合法</span></span><br><span class="line"><span class="title function_">special</span>(<span class="number">25</span>);                 <span class="comment">//合法</span></span><br><span class="line"><span class="title function_">special</span>(<span class="number">100</span>,<span class="number">79.8</span>);           <span class="comment">//合法</span></span><br><span class="line"><span class="title function_">special</span>(,<span class="number">21.5</span>);              <span class="comment">//不合法</span></span><br></pre></td></tr></table></figure><p>所有取缺省值参数都必须出现在不取缺省值参数的右边<br>说白了，参数有赋值的都先写在左边，没写的都取默认值在右边<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">fun</span>(int i,int j=<span class="number">5</span>, int k)          <span class="comment">//错误</span></span><br><span class="line">int <span class="title function_">fun</span>(int i, int k,int j=<span class="number">5</span>)          <span class="comment">//正确</span></span><br></pre></td></tr></table></figure><br>函数原型和定义都可以指定参数的默认值。</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>定义：函数的参数类型不同，或者参数个数不同，或者二者兼有，但是有相同的函数名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">square</span>(<span class="params">int i</span>)</span><br><span class="line">&#123;  <span class="keyword">return</span> i*i; &#125;</span><br><span class="line">float <span class="title function_">square</span>(<span class="params">float f</span>)</span><br><span class="line">&#123;  <span class="keyword">return</span> f*f; &#125;</span><br><span class="line">double <span class="title function_">square</span>(<span class="params">double d</span>)</span><br><span class="line">&#123;  <span class="keyword">return</span> d*d; &#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">mul</span>(<span class="params">int x, int y</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> x*y; &#125;</span><br><span class="line"></span><br><span class="line">int <span class="title function_">mul</span>(<span class="params">int x, int y, int z</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> x*y*z; &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>仅仅返回类型不同不是重载函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int <span class="title function_">mul</span>(int x, int y) ;</span><br><span class="line">double <span class="title function_">mul</span>(int x, int y); </span><br></pre></td></tr></table></figure><br>重载函数应对不同的参数情况执行相同的功能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>(int x); </span><br><span class="line"><span class="title function_">abs</span>(float x);</span><br></pre></td></tr></table></figure><br>函数的重载与带默认值的函数一起使用时，可能引起二义性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>   <span class="title class_">Drawcircle</span>(int  r=<span class="number">0</span>; int x=<span class="number">0</span>;  int y=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">void</span>   <span class="title class_">Drawcircle</span>(int   r);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Drawcircle</span>(<span class="number">20</span>)<span class="comment">//无法确定使用哪一个函数</span></span><br></pre></td></tr></table></figure></p><h4 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="作用域运算符::"></a>作用域运算符::</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a=<span class="number">25</span>    <span class="comment">//全局变量</span></span><br><span class="line">int <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">  int a=<span class="number">10</span>     <span class="comment">//局部变量</span></span><br><span class="line">  ::a  <span class="comment">//全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无名联合"><a href="#无名联合" class="headerlink" title="无名联合"></a>无名联合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言的共用体</span></span><br><span class="line">union data </span><br><span class="line">&#123;  int   i;</span><br><span class="line">    char  ch;</span><br><span class="line">    float  f;</span><br><span class="line">&#125;</span><br><span class="line">union data a,b,c;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++的无名联合</span></span><br><span class="line">union </span><br><span class="line">&#123; int i;</span><br><span class="line">  char  ch;</span><br><span class="line">  float  f;</span><br><span class="line">&#125; a; <span class="comment">//引用:a.i,a.ch a.f                                 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言的强制类型转换：</span></span><br><span class="line">int  i=<span class="number">10</span>;</span><br><span class="line">float  x=(float)i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++的强制类型转换：</span></span><br><span class="line">int  i=<span class="number">10</span>;</span><br><span class="line">float  x=<span class="title function_">float</span>(i);</span><br><span class="line">float  y=(float)i;</span><br></pre></td></tr></table></figure><h4 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C动态分配内存与释放：malloc()  free()</span></span><br><span class="line">int *p =(int * ) <span class="title function_">malloc</span>(<span class="title function_">sizeof</span>(int));</span><br><span class="line">*p=<span class="number">10</span>;</span><br><span class="line"><span class="title function_">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++动态分配内存与释放：                        </span></span><br><span class="line">int *p;             </span><br><span class="line">p=<span class="keyword">new</span> int;      </span><br><span class="line">*p=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> p;          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>new 动态分配优点：<br>1 new自动计算所要分配内存大小，不必要sizeof()<br>2 new不必进行指针类型转换。</p><p>1，new可以动态分配数组内存空间<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p=<span class="keyword">new</span> int[<span class="number">10</span>]</span><br><span class="line">int *p=<span class="keyword">new</span> int[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure><br>2.new可以在动态分配数组内存空间的同时，进行初始化<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p=<span class="keyword">new</span> <span class="title function_">int</span>(<span class="number">99</span>)</span><br><span class="line"><span class="keyword">delete</span> p  <span class="comment">//注意没有*号</span></span><br></pre></td></tr></table></figure></p><p>3 有new必有delete<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *p=<span class="keyword">new</span> <span class="title function_">int</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">int *p=<span class="keyword">new</span> int[<span class="number">10</span>]</span><br><span class="line"><span class="keyword">delete</span> []p</span><br></pre></td></tr></table></figure><br>4.动态分配内存失败后，将返回空指针（Null）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line"><span class="keyword">void</span>  <span class="title function_">main</span>(<span class="params"> </span>)                        </span><br><span class="line">&#123; int *p;</span><br><span class="line">  p=<span class="keyword">new</span> int;      </span><br><span class="line">  <span class="keyword">if</span>(!p)              <span class="comment">//若分配内存失败</span></span><br><span class="line">  &#123; cout&lt;&lt;<span class="string">&quot;allocation failure\n&quot;</span>;</span><br><span class="line">     <span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  *p=<span class="number">20</span>;</span><br><span class="line">  cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5使用new创建对象时会调用构造函数<br>使用delete删除对象时会调用析构函数<br>6对一个指针只能使用一次delete</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用就是别名，就是一种隐式指针可以少用*</p><h5 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h5><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405212242358.png" alt="image.png"><br>定义引用需要立即进行初始化，以后不能再赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int  i;    int  &amp;j;   j=i;      <span class="comment">//错误 </span></span><br><span class="line">int i; int &amp;j=i;</span><br></pre></td></tr></table></figure><br>i，j共用一个地址<br>当i的值改变时，j的值也改变；<br>j的值改变时，i的值也改变。<br>引用可以用于初始化另外一个引用，但是不存在二级引用<br>不存在指针引用，二级引用，数组引用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i</span><br><span class="line">int &amp;j=i</span><br><span class="line">int &amp;k=j </span><br><span class="line"><span class="comment">//ijk三者共用一个地址，当一个值改变另外2个值也发生改变。</span></span><br></pre></td></tr></table></figure><br>地址与引用运算符的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  num=<span class="number">50</span>;</span><br><span class="line">int  &amp;ref=num;</span><br><span class="line">int  *p=&amp;ref;</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"> </span>)                        </span><br><span class="line">&#123; int i=<span class="number">15</span>;                                 <span class="comment">//整型变量i</span></span><br><span class="line">  int *iptr=&amp;i;                            <span class="comment">//iptr指向i</span></span><br><span class="line">  int &amp;rptr=i;                             <span class="comment">//rptr引用i</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;i is &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;*iptr is &quot;</span>&lt;&lt;*iptr&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;rptr is &quot;</span>&lt;&lt;rptr&lt;&lt;endl;</span><br><span class="line">  i=<span class="number">29</span>;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot; After changing i to 29&quot;</span>&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;i is &quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;*iptr is &quot;</span>&lt;&lt;*iptr&lt;&lt;endl;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;rptr is &quot;</span>&lt;&lt;rptr&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i   is  <span class="number">15</span>              i    is  <span class="number">29</span></span><br><span class="line">*iptr is <span class="number">15</span>             *iptr  is  <span class="number">29</span></span><br><span class="line">rptr  is <span class="number">15</span>              rptr  is <span class="number">29</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span>(<span class="params">int *m, int *n</span>)</span><br><span class="line">&#123; int temp;</span><br><span class="line">   temp=*m;</span><br><span class="line">  *m=*n;</span><br><span class="line">  *n=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">swap</span>(&amp;a,&amp;b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span>(<span class="params">int &amp;m, int &amp;n</span>)</span><br><span class="line">&#123; int temp;</span><br><span class="line">  temp=m;</span><br><span class="line">  m=n;</span><br><span class="line">  n=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">swap</span>(a,b);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="引用作为函数返回值"><a href="#引用作为函数返回值" class="headerlink" title="引用作为函数返回值"></a>引用作为函数返回值</h5><p>函数可返回一个引用，当在函数定义时加上&amp;，那么就可以将函数写在赋值运算符的左边。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line">int a[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line">int &amp;<span class="title function_">index</span>(int);                     <span class="comment">//声明返回引用的函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"> </span>)</span><br><span class="line">&#123; <span class="title function_">index</span>(<span class="number">2</span>)=<span class="number">25</span>;                       <span class="comment">//将a[2]重新赋值为25</span></span><br><span class="line">  cout&lt;&lt;<span class="title function_">index</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int &amp; <span class="title function_">index</span>(<span class="params">int i</span>)</span><br><span class="line">&#123; <span class="keyword">return</span> a[i]; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>注意引用函数与内联函数的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Inline</span> int area（）</span><br><span class="line"><span class="title class_">Int</span> &amp;area（）</span><br></pre></td></tr></table></figure></p><h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h4><p>void 指针是通用型指针，可指任何类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>  pa;   <span class="comment">//错误，不能声明void类型的变量</span></span><br><span class="line"><span class="keyword">void</span>  *pa;  <span class="comment">//正确，可以声明void类型的指针</span></span><br><span class="line">int  i=<span class="number">456</span>;         </span><br><span class="line">pa=&amp;i;     </span><br><span class="line">char  c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">pa=&amp;c</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream.<span class="property">h</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">main</span>(<span class="params"></span>)</span><br><span class="line">&#123;   <span class="keyword">void</span>  *pc; </span><br><span class="line">     int  i=<span class="number">456</span>;</span><br><span class="line">     char  c=‘a’;</span><br><span class="line">     pc=&amp;i;</span><br><span class="line">     cout&lt;&lt;*(int*)pc&lt;&lt;endl;</span><br><span class="line">     pc=&amp;c;</span><br><span class="line">    cout&lt;&lt;*(char*)pc&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 生活趣闻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章_栈与队列_part01</title>
      <link href="/2024/05/19/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part01/"/>
      <url>/2024/05/19/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part01/</url>
      
        <content type="html"><![CDATA[<h2 id="栈与队列的理论基础"><a href="#栈与队列的理论基础" class="headerlink" title="栈与队列的理论基础"></a>栈与队列的理论基础</h2><p>栈不提供迭代器(iterator)，不像是set或者map提供迭代器iterator遍历所有元素<br>栈提供top，push，pop等接口<br>栈是以底层容器完成其所有工作，对外提供统一的接口，我们可以控制选择哪种底层容器来实现栈的功能<br>STL中栈不归为容器，而是容器适配器，<br>栈的底层容器一般是数组和链表，或者deque(双向队列)封住其中一段。<br>队列同理。</p><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">232.用栈实现队列</a></h2><h3 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h3><p>使用两个栈实现先入先出队列。实现push，pop，peek，empty方法<br>push(x)—将一个元素放入队列的尾部<br>pop()—从队列首部移除元素<br>peek()—返回队列首部的元素<br>empty()—返回队列是否为空</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>两次进栈实现先进先出</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;In;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;Out;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        In.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Out.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!In.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> res=In.<span class="built_in">top</span>();</span><br><span class="line">                In.<span class="built_in">pop</span>();</span><br><span class="line">                Out.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=Out.<span class="built_in">top</span>();</span><br><span class="line">        Out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        Out.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> In.<span class="built_in">empty</span>()&amp;&amp;Out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/description/">225.用队列实现栈</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述:"></a>题目重述:</h3><p>使用两个队列实现一个后入先出的栈，实现栈的四种操作<br>push(x)，将元素x压入栈顶元素<br>pop() 移除并返回栈顶元素。<br>top() 返回栈顶元素<br>empty() 如果栈为空，返回true。否则返回false</p><h3 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h3><p>将队列q2作为q1的备份队列</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q2;</span><br><span class="line">    <span class="built_in">MyStack</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size=q1.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        q1=q2;</span><br><span class="line">        <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章_栈与队列_part02</title>
      <link href="/2024/05/19/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part02/"/>
      <url>/2024/05/19/%E7%AC%AC%E4%BA%94%E7%AB%A0_%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97_part02/</url>
      
        <content type="html"><![CDATA[<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/description/">20.有效的括号</a></h2><h3 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><h3 id="看到题目的第一想法："><a href="#看到题目的第一想法：" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>遇到左括号就入栈，遇到右括号，就将栈顶元素取出进行比较，然后出栈<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;[&#x27;</span>||s[i]==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">char</span> c;</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>) c=<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>) c=<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">top</span>()==<span class="string">&#x27;&#123;&#x27;</span>) c=<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(s[i]==c)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录:"></a>代码随想录:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()||st.<span class="built_in">top</span>()!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047.删除字符串中的所有相邻重复项</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述:"></a>题目重述:</h3><p>有一个字符串s，删除操作会选择两个相邻且相同的字母，然后删除。重复删除操作。</p><h3 id="看到题目的第一想法：-1"><a href="#看到题目的第一想法：-1" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>创建stack<char>st,如果栈空就push<br>每遇到一个字符就比较st.top，如果相等就st.pop()，不相等就push<br>输出栈元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">empty</span>())st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==st.<span class="built_in">top</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res+=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录："><a href="#代码随想录：" class="headerlink" title="代码随想录："></a>代码随想录：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">empty</span>()||res.<span class="built_in">back</span>()!=c) res.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">else</span> res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">150.逆波兰表达式求值</a></h2><h3 id="题目重述：-1"><a href="#题目重述：-1" class="headerlink" title="题目重述："></a>题目重述：</h3><p>有个字符串数组tokens，表示逆波兰表示法表示的算术表达式。计算该表达式，返回结果。<br>注意：</p><ul><li>有效的算符为 ‘+’、’-‘、’*’ 和 ‘/‘ 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 向零截断 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 32 位 整数表示。<h3 id="看到题目的第一想法：-2"><a href="#看到题目的第一想法：-2" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3>创建栈stack<char>st;<br>st.push(tokens[0]);st.push(tokens[1]);<br>如果tokens[]是算符，取出栈顶的两个元素进行计算，将结果返回栈。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tokens.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>||tokens[i]==<span class="string">&quot;-&quot;</span>||tokens[i]==<span class="string">&quot;*&quot;</span>||tokens[i]==<span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> a= st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> b = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> res;</span><br><span class="line">                <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;+&quot;</span>) res=b+a;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;-&quot;</span>)res=b-a;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;*&quot;</span>)res=b*a;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i]==<span class="string">&quot;/&quot;</span>)res=b/a;</span><br><span class="line">                st.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(tokens[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 栈与队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章_字符串_part02</title>
      <link href="/2024/05/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E5%AD%97%E7%AC%A6%E4%B8%B2_part02/"/>
      <url>/2024/05/19/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E5%AD%97%E7%AC%A6%E4%B8%B2_part02/</url>
      
        <content type="html"><![CDATA[<h2 id="28-找出字符串中第一个匹配项的下标"><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28.找出字符串中第一个匹配项的下标</a></h2><h3 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h3><p>有两个字符串s1，s2，在s1字符串中找出s2字符串的第一个匹配项的下标（下标从0开始）。<br>如果s2不是s1的一部分，返回-1</p><h3 id="看到题目的想法："><a href="#看到题目的想法：" class="headerlink" title="看到题目的想法："></a>看到题目的想法：</h3><p>创造一个s2.size()大小的移动窗口。然后遍历s1，slow=0,fast=s2.size()-1.<br>如果[slow,fast]==s1,则返回slow，否则返回-1；<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639424.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">cmp1</span><span class="params">(string s1,string s2,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==s2[count++])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(needle.<span class="built_in">size</span>()&gt;haystack.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>()-n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="built_in">cmp1</span>(haystack,needle,i,i+n<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录："><a href="#代码随想录：" class="headerlink" title="代码随想录："></a>代码随想录：</h3><p>使用了KMP方法</p><h4 id="我自己的KMP理解"><a href="#我自己的KMP理解" class="headerlink" title="我自己的KMP理解"></a>我自己的KMP理解</h4><h5 id="KMP有什么用？"><a href="#KMP有什么用？" class="headerlink" title="KMP有什么用？"></a>KMP有什么用？</h5><p>当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639425.jpg" alt=""></p><h5 id="为什么可以这么做？"><a href="#为什么可以这么做？" class="headerlink" title="为什么可以这么做？"></a>为什么可以这么做？</h5><p>即aabaabf中f匹配错误时，从aab开始匹配<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639426.jpg" alt=""></p><h5 id="如何构造next数组"><a href="#如何构造next数组" class="headerlink" title="如何构造next数组"></a>如何构造next数组</h5><p>next[i]存的就是s2[0]~s2[i]这个字符串头尾对称元素的长度<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639427.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=i;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left]==s[right])count++;</span><br><span class="line">        left++,right--;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i]=count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样有点复杂，我们可以从next数组定义出发<br>next[i-1]时0-i-1中头尾对称元素的长度，而next[i]只是在末尾上加一个字符s[i];<br>还有就是为什么构建了next数组，数组的值不仅是头尾对称元素的长度，还是当我们不匹配时，不从头开始匹配，而是从s2中下标next[i]的元素开始匹配</p><p>我们把新添加的字符s[i+1]想成aabaaf中的f,<br>如果aabaaf的f匹配失败，从aab开始匹配，b匹配失败，继续前移<br>写出代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j])&#123;</span><br><span class="line">    j=next[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中j是头尾对称元素的长度，匹配失败。不从头开始匹配，从该元素开始匹配<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br><span class="line">next[i]=j;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j])&#123;</span><br><span class="line">        j=next[j<span class="number">-1</span>];</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639428.jpg" alt=""><br>其实可以把0-j看做模版字符串，0-i看做原字符串<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[j]!=s[i])&#123;</span><br><span class="line">        j=next[j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[j]==s[i])&#123;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i]=j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="从前缀表的角度进行"><a href="#从前缀表的角度进行" class="headerlink" title="从前缀表的角度进行"></a>从前缀表的角度进行</h4><h5 id="前缀表的作用？"><a href="#前缀表的作用？" class="headerlink" title="前缀表的作用？"></a>前缀表的作用？</h5><p>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配<br>前缀表中记录着：记录下标i之前(包括i)的字符串中，有多大长度的相同前缀后缀</p><h5 id="前缀和后缀"><a href="#前缀和后缀" class="headerlink" title="前缀和后缀"></a>前缀和后缀</h5><p>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。<br>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。<br>以aabaaf为例子：<br>前缀:a,aa,aab,aaba,aabaa.<br>后缀:f,af,aaf,baaf,abaaf<br>前缀表要求的就是相同前后缀的长度<br>next{0,1,0,1,2,0}<br>next[4]=2<br>aabaa的前缀a,aa,aab,aaba<br>aabaa的后缀a,aa,baa,abaa<br>相同前后缀的长度。</p><h5 id="为什么一定要用前缀表"><a href="#为什么一定要用前缀表" class="headerlink" title="为什么一定要用前缀表"></a>为什么一定要用前缀表</h5><p>因为前缀表可以告诉我们匹配失败之后跳到哪里重新匹配<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639429.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639430.png" alt=""><br>下标5之前这部分字符串(aabaa)的最长相等的前缀和后缀字符串是aa.<br>因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么找到与其相同的前缀的后面重新匹配就可以了</p><h5 id="构造next数组也就是前缀表"><a href="#构造next数组也就是前缀表" class="headerlink" title="构造next数组也就是前缀表"></a>构造next数组也就是前缀表</h5><p>定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置(0-i子字符串的最后一个字符,aa的a,aabaa的a)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,string&amp; s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j])&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(needle.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">getNext</span>(&amp;next[<span class="number">0</span>],needle);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;haystack[i]!=needle[j])&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a><a href="https://leetcode.cn/problems/repeated-substring-pattern/description/">459.重复的子字符串</a></h2><h3 id="题目重述"><a href="#题目重述" class="headerlink" title="题目重述:"></a>题目重述:</h3><p>给定一个非空的字符串s，检查是否可以通过由它的一个子串重复多次构成</p><h3 id="看到题目的第一想法"><a href="#看到题目的第一想法" class="headerlink" title="看到题目的第一想法:"></a>看到题目的第一想法:</h3><p>for一层循环为s1子字符串的长度i从1,n/2;<br>s1=s.substr(0,1),<br>s1=s.substr(0,2);<br>s1=s.substr(0,3);<br>第二层循环判断s是否由s1组成,j<br>从s.substr(j,i)==s1<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n =s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i)<span class="keyword">continue</span>;</span><br><span class="line">            string s1=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;n&amp;&amp;s.<span class="built_in">substr</span>(j,i)==s1)&#123;</span><br><span class="line">                j+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录:"></a>代码随想录:</h3><h4 id="移动匹配"><a href="#移动匹配" class="headerlink" title="移动匹配"></a>移动匹配</h4><p>让两个s拼接在一起，为t，如果里面还出现一个s的话，就说明由重复子串组成，其中t要去头去尾<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639431.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string t = s+s;</span><br><span class="line">        t.<span class="built_in">erase</span>(t.<span class="built_in">begin</span>());</span><br><span class="line">        t.<span class="built_in">erase</span>(t.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(t.<span class="built_in">find</span>(s)!=string::npos)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="KMP解法"><a href="#KMP解法" class="headerlink" title="KMP解法"></a>KMP解法</h4><p>首先明确一点，s最长相等前后缀不包含的子串就是最小重复单元<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639432.jpg" alt=""><br>ab就是重复单元<br>为什么ab就是最小重复单元<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201639433.jpg" alt=""><br>如果s.size()能整出最小重复单元则返回true。同时next[n-1]!=0，没有最小重复单元<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next,string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j])&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> next[n];</span><br><span class="line">        <span class="built_in">getNext</span>(next,s);</span><br><span class="line">        <span class="keyword">if</span>(next[n<span class="number">-1</span>]!=<span class="number">0</span>&amp;&amp;n%(n-next[n<span class="number">-1</span>])==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章_字符串_part01</title>
      <link href="/2024/05/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E5%AD%97%E7%AC%A6%E4%B8%B2_part01/"/>
      <url>/2024/05/15/%E7%AC%AC%E5%9B%9B%E7%AB%A0_%E5%AD%97%E7%AC%A6%E4%B8%B2_part01/</url>
      
        <content type="html"><![CDATA[<h2 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/description/">344.反转字符串</a></h2><h3 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h3><p>不利用额外的空间，原地修改字符串数组，使字符串反转过来</p><h3 id="看到题目的第一想法："><a href="#看到题目的第一想法：" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>遍历字符串数组，两两交换字符的值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[n-i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录："><a href="#代码随想录：" class="headerlink" title="代码随想录："></a>代码随想录：</h3><p>也是两两交换字符的思路，我是通过数组的下标进行交换的。<br>Carl是通过双指针进行交换的<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201637969.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n =s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>,right=n<span class="number">-1</span>;left&lt;n/<span class="number">2</span>;left++,right--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="541-反转字符串II"><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/description/">541.反转字符串II</a></h2><h3 id="题目重述：-1"><a href="#题目重述：-1" class="headerlink" title="题目重述："></a>题目重述：</h3><p>给你一个字符串s和一个整数k，<br>每2k个字符，反转这个2k个字符中的前k个字符<br>如果剩余字符少于k个，则将剩余字符全部反转<br>如果剩余字符少于2k但大于或等于k个，则反转前k个字符。</p><h3 id="看到题目的第一想法：-1"><a href="#看到题目的第一想法：-1" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p> 当s.size()&lt;=k时，和反转整个字符串<br>之后就是每2*k个进行分析<br>翻转前k个字符串即[0,k-1],[0+2k,k-1+2k],[0+4k,k-1+4k]<br>当恰好2k个字符串时left+2k==s.size()，break<br>如果剩余的字符串小于k时，right&gt;=s.size()，交换剩余的left,size()-1;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=k)&#123;</span><br><span class="line">            <span class="type">int</span> left=<span class="number">0</span>,right=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> left=<span class="number">0</span>,right=k<span class="number">-1</span>;left&lt;=s.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;right&lt;=s.<span class="built_in">size</span>()<span class="number">-1</span>;)&#123;</span><br><span class="line">            <span class="type">int</span> a=left,b=right;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            left=a+<span class="number">2</span>*k;</span><br><span class="line">            right=b+<span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span>(left==s.<span class="built_in">size</span>())<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(right&gt;=s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> i=left,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">                    i++;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录：-1"><a href="#代码随想录：-1" class="headerlink" title="代码随想录："></a>代码随想录：</h3><p>可以直接使用reverse库函数，或者使用swap手写reverse函数<br>另外重要的一点是，完全没必要使用right，我们可以发现right=left+k-1，完全可以成为一个变量指针移动为i<br>下面的代码完全可以删除，下面的代码是防止right=k-1不存在<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;=k)&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=s.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[left],s[right]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[start],s[end]);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n= s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=(<span class="number">2</span>*k))&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k<span class="number">-1</span>&lt;n)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,i,i+k<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,i,n<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="卡码网：54-替换数字"><a href="#卡码网：54-替换数字" class="headerlink" title="卡码网：54.替换数字"></a>卡码网：54.替换数字</h2><h3 id="题目重述：-2"><a href="#题目重述：-2" class="headerlink" title="题目重述："></a>题目重述：</h3><p>给定字符串s，包含小写字母和数字字符，替换s中的所有数字为number，</p><h3 id="看到题目的第一想法：-2"><a href="#看到题目的第一想法：-2" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>考虑使用额外空间<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    string s1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;z&#x27;</span>&amp;&amp;s[i]&gt;=<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">            s1+=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s1+=<span class="string">&quot;number&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>不使用额外空间，<br>我的想法，先统计数字出现的个数，计算需要拓充的空间<br>每遇到一个数字，将数字之后的内容全部向后移动5个单位，然后插入number。时间复杂度(n^2)</p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录:"></a>代码随想录:</h3><p>采用从后向前填充，并设置i，j指针，j指针指向拓充后的数组的末尾。i指针指向原数组的末尾。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201637970.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;s[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>()+count*<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;j;i--,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;=<span class="string">&#x27;9&#x27;</span>&amp;&amp;s[i]&gt;=<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            s[j]=<span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">            s[j<span class="number">-1</span>]=<span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            s[j<span class="number">-2</span>]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            s[j<span class="number">-3</span>]=<span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">            s[j<span class="number">-4</span>]=<span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">            s[j<span class="number">-5</span>]=<span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">            j=j<span class="number">-5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[j]=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151.翻转字符串里的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151.翻转字符串里的单词</a></h2><h3 id="题目重述：-3"><a href="#题目重述：-3" class="headerlink" title="题目重述："></a>题目重述：</h3><p>反转字符串s中单词顺序。返回单词顺序颠倒且单词之间用单个空格连接的结果字符串<br>s可能存在前导空格，尾随空格或者单词间含有多个空格。</p><h3 id="看到题目的第一想法：-3"><a href="#看到题目的第一想法：-3" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>首先去除多余空格，<br>如果s[0]==’ ‘,s.erase(s.begin());<br>如果s[s.size()-1]=’ ‘.s.erase(s.end());<br>中间含有多个空格<br>遍历s，如果有两个连续的空格，则删除一个<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201637971.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEntraSpaces</span><span class="params">(string&amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>&amp;&amp;s[i<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">&#x27; &#x27;</span>) s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;s[s.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeEntraSpaces</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> end=<span class="number">0</span>;end&lt;=s.<span class="built_in">size</span>();end++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end==s.<span class="built_in">size</span>()||s[end]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,start,end<span class="number">-1</span>);</span><br><span class="line">                start=end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录：-2"><a href="#代码随想录：-2" class="headerlink" title="代码随想录："></a>代码随想录：</h3><p>在removeEntraSpaces中没有使用erase，而是使用了双指针，fastIndex是原字符串s的非空字符位置，slowIndex为修改后的字符串s的非空字符位置<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201637972.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeEntraSpaces</span><span class="params">(string&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fastIndex=<span class="number">0</span>,slowIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>()&gt;<span class="number">0</span>&amp;&amp;fastIndex&lt;s.<span class="built_in">size</span>()&amp;&amp;s[fastIndex]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        fastIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;fastIndex&lt;s.<span class="built_in">size</span>();fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fastIndex<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;s[fastIndex]==s[fastIndex<span class="number">-1</span>]&amp;&amp;s[fastIndex]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[slowIndex++]=s[fastIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(slowIndex&gt;<span class="number">0</span>&amp;&amp;s[slowIndex<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        s.<span class="built_in">resize</span>(slowIndex);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 简化代码，每遇到一个新单词，手动添加空格<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201637973.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeEntraSpaces</span><span class="params">(string&amp;s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> slowIndex=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> fastIndex=<span class="number">0</span>;fastIndex&lt;s.<span class="built_in">size</span>();fastIndex++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[fastIndex]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slowIndex!=<span class="number">0</span>)s[slowIndex++]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(fastIndex&lt;s.<span class="built_in">size</span>()&amp;&amp;s[fastIndex]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[slowIndex++]=s[fastIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.<span class="built_in">resize</span>(slowIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="卡码网：55-右旋转字符串"><a href="#卡码网：55-右旋转字符串" class="headerlink" title="卡码网：55.右旋转字符串"></a><a href="https://kamacoder.com/problempage.php?pid=1065">卡码网：55.右旋转字符串</a></h2><h3 id="题目重述：-4"><a href="#题目重述：-4" class="headerlink" title="题目重述："></a>题目重述：</h3><p>给定字符串s和正整数k，将字符串尾部的k个字符移到字符串的前面</p><h3 id="看到题目的第一想法：-4"><a href="#看到题目的第一想法：-4" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>首先将整个字符串旋转一次，然后分别0，k-1和k到s,size()旋转一次。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="built_in">reverse</span>(s,<span class="number">0</span>,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(s,<span class="number">0</span>,k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(s,k,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>代码随想录：<br>想法基本一致</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章_哈希表_part02</title>
      <link href="/2024/05/14/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%93%88%E5%B8%8C%E8%A1%A8_part02/"/>
      <url>/2024/05/14/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%93%88%E5%B8%8C%E8%A1%A8_part02/</url>
      
        <content type="html"><![CDATA[<h2 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454.四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/description/">454.四数相加 II</a></h2><h3 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h3><p>四个整数数组nums1,nums2,nums3,nums4，长度都为n，计算有多少个元组(i,j,k,l)满足<br>$nums1[i]+nums2[j]+nums3[k]+nums4[l]==0$</p><h3 id="看到题目的第一想法"><a href="#看到题目的第一想法" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>四层循环，时间复杂度n^4。<br>nums1,nums2进行两层循环，将计算结果放入map1，关键码为两数之和，值为两数之和的次数，，然后nums3,nums4进行两层循环，同理，形成map2<br>之后，遍历map1的元素x，对map2进行查找-x，然后sum+=map1[x]*map2[-x],<br>最后输出sum。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map1;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map2;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> temp = nums1[i]+nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(map1.<span class="built_in">find</span>(temp)!=map1.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    map1[temp]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    map1[temp]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> temp = nums3[i]+nums4[j];</span><br><span class="line">                <span class="keyword">if</span>(map2.<span class="built_in">find</span>(temp)!=map2.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    map2[temp]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    map2[temp]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=map1.<span class="built_in">begin</span>();iter!=map1.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            <span class="type">int</span> num = iter-&gt;first;</span><br><span class="line">            <span class="keyword">if</span>(map2.<span class="built_in">find</span>(-num)!=map2.<span class="built_in">end</span>())&#123;</span><br><span class="line">                sum+=map1[num]*map2[-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录："><a href="#代码随想录：" class="headerlink" title="代码随想录："></a>代码随想录：</h3><p>思路大体一致，但是Carl的只用到了一个unordered_map，且将省去了多个步骤。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map1;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                map1[nums1[i]+nums2[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> temp=nums3[i]+nums4[j];</span><br><span class="line">                <span class="keyword">if</span>(map1.<span class="built_in">find</span>(-temp)!=map1.<span class="built_in">end</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    sum+=map1[-temp];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a><a href="https://leetcode.cn/problems/ransom-note/description/">383.赎金信</a></h2><h3 id="题目重述：-1"><a href="#题目重述：-1" class="headerlink" title="题目重述："></a>题目重述：</h3><p>判断字符串ransomNote能由magazine组成，magazine中的字符每个只能使用一次</p><h3 id="看到题目的第一想法："><a href="#看到题目的第一想法：" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>将magazine中转化为unordered_map,关键码是字符，值为出现的次数<br>遍历字符串ransomNote，对于magazine中find，如果没找到或者magazine等于0，return false<br>想了想，直接用数组就行了。因为字符刚好可以通过ASCII码转化为int<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;magazine.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            a[magazine[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ransomNote.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[ransomNote[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> a[ransomNote[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>代码随想录：<br>想法基本一致</p><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a><a href="https://leetcode.cn/problems/3sum/description/">15.三数之和</a></h2><h3 id="题目重述：-2"><a href="#题目重述：-2" class="headerlink" title="题目重述："></a>题目重述：</h3><p>给你一个整数数组nums<br>求满足<br>$nums[i]+nums[j]+nums[k]=0,其中i,j,k不相同$<br>返回不含重复的三元组<br>$[nums[i],nums[j],nums[k]]$</p><h3 id="看到题目的第一想法-1"><a href="#看到题目的第一想法-1" class="headerlink" title="看到题目的第一想法:"></a>看到题目的第一想法:</h3><p>三个for循环.时间复杂度n^3，因为是不含重复的三元组，考虑使用unordered_set<br>在实践中，set如何设置，我不太明白,unordered<vector<int>&gt;res,报错了<br>错误代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">set1</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]==<span class="number">0</span>)&#123;</span><br><span class="line">                        res.<span class="built_in">insert</span>(&#123;i,j,k&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上面的思路找到满足三数之和为0的三个数，然后通过unordered_set<vector<int>&gt;res，<br>res.insert({i,j,k});进行去重，但是unordered_set<vector<int>&gt;res结构是有问题的。<br>不通过unordered_set进行重合</p><p>看到GPT算法后：<br>首先将nums进行排序，这样每次遍历，如果三个数的nums[i]&gt;0，完全没必要进行下去了<br>此外还有一个好处就是，如果nums[i]=nums[i-1]了，即重复数排在一起了，可以快速进行跳过重复元素</p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt;set;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">2</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]&amp;&amp;nums[j<span class="number">-1</span>]==nums[j<span class="number">-2</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - (nums[i]+nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(set.<span class="built_in">find</span>(c)!=set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],c,nums[j]&#125;);</span><br><span class="line">                    set.<span class="built_in">erase</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在不考虑重复的的基础代码应该如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt;set;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - (nums[i]+nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(set.<span class="built_in">find</span>(c)!=set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],c,nums[j]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201635943.jpg" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201635944.jpg" alt=""></p><p>gpt的代码：<br>Carl 是添加两段代码来处理，Y,Z处重复<br>GPT 在处理Y,Z处重复时，添加如下代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(set.<span class="built_in">find</span>(c)!=set.<span class="built_in">end</span>())&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(&#123;nums[i],c,nums[j]&#125;);</span><br><span class="line">    <span class="keyword">while</span>(j+<span class="number">1</span>&lt;n&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt;set;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span> - (nums[i]+nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(set.<span class="built_in">find</span>(c)!=set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],c,nums[j]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(j+<span class="number">1</span>&lt;n&amp;&amp;nums[j]==nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                            ++j;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    set.<span class="built_in">insert</span>(nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>双指针法<br>一层for循环遍历nums，设置left指针为i+1，right = nums.size()-1;<br>当nums[i]时，left与right同时向中间收缩<br>收缩的原则是：<br>如果nums[i]+nums[left]+nums[right]<0,left指针右移如果nums[i]+nums[left]+nums[right]>0,right指针左移<br>如果nums[i]+nums[left]+nums[right]=0,res.push_back</p><p>找到一组之后，还要进行收缩，直到left==right，找到其他等于满足条件的三元组<br>left++,right—</p><p>接下来考虑去重的步骤<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line"><span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right--] right--;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&lt;<span class="number">0</span>)left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[left]+nums[right]&gt;<span class="number">0</span>)right--;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])right--;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a><a href="https://leetcode.cn/problems/4sum/description/">18.四数之和</a></h2><h3 id="题目重述：-3"><a href="#题目重述：-3" class="headerlink" title="题目重述："></a>题目重述：</h3><p>和三数之和一样，给你一个nums和target，返回不重复的四元组，其中i,j,k,l不相等。同时<br>nums[i]+nums[j]+nums[k]+nums[l]==0</p><h3 id="看到题目的第一想法：-1"><a href="#看到题目的第一想法：-1" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>做过三数之和和，优先考虑使用双指针法。<br>left指针和right指针分别代码了第三个和第四个数<br>使两层for循环来表示前两个数<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201635945.jpg" alt=""><br>考虑去重的方法，想法和三数之和相同。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]+nums[j]+nums[left]+nums[right]&lt;target)left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]+nums[j]+nums[left]+nums[right]&gt;target)right--;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>上面的代码通过了283/294测试用例</p><h3 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>想法基本一致<br>使用了对于第二层for也做了减枝<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[j] + nums[i] &gt; target &amp;&amp; nums[j] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而且对于int越界问题，改用了long<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&lt;target)left++;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n<span class="number">-2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((nums[i]+nums[j])&gt;target&amp;&amp;(nums[i]+nums[j])&gt;=<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=n<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&lt;target)left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right]&gt;target)right--;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="number">-1</span>])right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章_哈希表_part01</title>
      <link href="/2024/05/13/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%93%88%E5%B8%8C%E8%A1%A8_part01/"/>
      <url>/2024/05/13/%E7%AC%AC%E4%B8%89%E7%AB%A0_%E5%93%88%E5%B8%8C%E8%A1%A8_part01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-哈希表的理论基础"><a href="#1-哈希表的理论基础" class="headerlink" title="1 哈希表的理论基础"></a>1 哈希表的理论基础</h2><p>哈希表（Hash Table）：根据关键码的值而直接进行访问的数据结构<br>例如：数组是一张哈希表，通过数组的索引(关键码)来访问数组中的元素</p><p>哈希表用来解决的问题？<br>用来快速判断一个元素是否出现在集合中，核心是牺牲了空间换取了时间</p><p>哈希函数：<br>将元素值与哈希表中的关键码进行映射<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201633699.png" alt=""></p><p>哈希碰撞<br>产生原因：不同的元素通过哈希函数，映射到同一关键码<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201633724.png" alt=""><br>解决方法：拉链法和线性探测法<br>拉链法：<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201633759.png" alt=""><br>线性探测法：<br>使用线性探测法，一定要保证tableSize大于dataSize。<br>例如：冲突的位置放了小李，那么就向下找一个空位放置小王的信息。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201633795.png" alt=""></p><p>常见的三种哈希结构<br>1 数组<br>2 set(集合)<br>3 map(映射)<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201633826.png" alt=""><br>使用来解决哈希问题时。<br>无特殊情况，优先使用unordered_set，查询和增删效率是最优的<br>要求集合是有序的，使用set<br>不仅要求有序还要有重复数据，使用multiset<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201633859.png" alt=""></p><h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/description/">242.有效的字母异位词</a></h2><h3 id="题目重述："><a href="#题目重述：" class="headerlink" title="题目重述："></a>题目重述：</h3><p>判断两个字符串中(s与t)，每个字母出现的次数是否相同</p><h3 id="看到题目的第一想法"><a href="#看到题目的第一想法" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>创建unordered_map容器mapS,mapT，遍历字符串s与t，如果这个字母在容器中出现过，就将map的value加1，如果没有，将该字母插入到容器中<br>最后判断两个容器是否完全相同<br>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mapS;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mapT;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=t.<span class="built_in">size</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mapS.<span class="built_in">find</span>(s[i])!=mapS.<span class="built_in">end</span>())&#123;</span><br><span class="line">                mapS[s[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mapS.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(s[i],<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mapT.<span class="built_in">find</span>(t[i])!=mapT.<span class="built_in">end</span>())&#123;</span><br><span class="line">                mapT[t[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                mapT.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(t[i],<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mapS==mapT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>也是用哈希表。但仅使用了数组，且只使用了一个数组，在选取关键码时，我是直接将字符char作为关键码，而carl是将字母根据ASCII，将int作为关键码。刚好可以使用数组这种简单的哈希表<br>同时先遍历s，每个关键码的元素值++，再遍历t，每个关键码的元素值—，最后判断是否有非零元素，还是很巧妙的。<br>代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()!=t.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            record[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            record[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i]!=<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/description/">349.两个数组的交集</a></h2><h3 id="题目重述：-1"><a href="#题目重述：-1" class="headerlink" title="题目重述："></a>题目重述：</h3><p>返回两个数组的交集，输出结果vector<int>num中每个元素一定是唯一的，不考虑输出结果的顺序。</p><h3 id="看到题目的第一想法："><a href="#看到题目的第一想法：" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>分别遍历nums1和nums2，将两者的元素放入到set_nums1和set_nums2中，然后比较对于set_nums1元素，在set_nums查找，如果找到了到push_back到num中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;set_nums1;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;set_nums2;</span><br><span class="line">        set_nums1.<span class="built_in">insert</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        set_nums2.<span class="built_in">insert</span>(nums2.<span class="built_in">begin</span>(),nums2.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=set_nums1.<span class="built_in">begin</span>();iter!=set_nums2.<span class="built_in">end</span>();iter++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set_nums2.<span class="built_in">find</span>(*iter)!=set_nums2.<span class="built_in">end</span>())&#123;</span><br><span class="line">                nums.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录-1"><a href="#代码随想录-1" class="headerlink" title="代码随想录"></a>代码随想录</h3><p>只将一个vect<int>转化了unordered_set<int>set_nums1，另外创建一个unordered_set<int>res用来存放结果，遍历nums2,如果nums2的元素在set_nums1找到了，存放到res中，最后将unordered_set转化为vector<int>输出。<br>能使用数组就是用数组，unordered_set不仅占用空间比数组大，速度也比数组慢<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">set_nums1</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(set_nums1.<span class="built_in">find</span>(num)!=set_nums1.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[num]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[num]==<span class="number">1</span>)res.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a><a href="https://leetcode.cn/problems/happy-number/description/">202.快乐数</a></h2><h3 id="题目重述：-2"><a href="#题目重述：-2" class="headerlink" title="题目重述："></a>题目重述：</h3><p>给你一个数，每次将该数替换成每个位置数字的平方和，如果最终这个数字为1，返回true，如果不能变不到1，返回false；</p><h3 id="看到题目第一想法："><a href="#看到题目第一想法：" class="headerlink" title="看到题目第一想法："></a>看到题目第一想法：</h3><p>首先对于任意一个整数，进行各位数的分割，然后计算出新的数<br>然后进行while（n!=1)，一直进行操作，但是有个问题，如果最终数字不是1，就会进行死循环，不知道咋办</p><p>现在我的想法，将每个数字都放入集合，如果新的值在集合中已经有了，那么就会死循环了，也就是可以返回false。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newVal</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            res+=(n%<span class="number">10</span>)*(n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;set_n;</span><br><span class="line">        set_n.<span class="built_in">insert</span>(n);</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;</span><br><span class="line">            n = <span class="built_in">newVal</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(set_n.<span class="built_in">find</span>(n)!=set_n.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            set_n.<span class="built_in">insert</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>代码随想录：<br>想法基本一致</p><p><a href="https://leetcode.cn/problems/two-sum/description/">1.两数之和</a></p><h3 id="题目复述"><a href="#题目复述" class="headerlink" title="题目复述:"></a>题目复述:</h3><p>给你一个数组nums和一个整数target，返回在数组中和为target的两个整数的下标。</p><h3 id="看到题目的第一想法-1"><a href="#看到题目的第一想法-1" class="headerlink" title="看到题目的第一想法:"></a>看到题目的第一想法:</h3><p>将nums转化为以数组元素的值为unordered_map中的关键码。元素的下标作为unordered_map的值，<br>然后对于nums的每一个数遍历，在umap中find(target-nums[i])，如果结果!umap.end(),返回<br>i和umap[nums[i]]<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            umap[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> count=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(umap.<span class="built_in">find</span>(count)!=umap.<span class="built_in">end</span>()&amp;&amp;umap[count]!=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,umap[count]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录："><a href="#代码随想录：" class="headerlink" title="代码随想录："></a>代码随想录：</h3><p>我的方法是分成两个for循环进行操作，carl是将两者结合<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;umap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> count=target-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(umap.<span class="built_in">find</span>(count)!=umap.<span class="built_in">end</span>()&amp;&amp;umap[count]!=i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,umap[count]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                umap[nums[i]]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习 朴素贝叶斯</title>
      <link href="/2024/05/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
      <url>/2024/05/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="贝叶斯方法"><a href="#贝叶斯方法" class="headerlink" title="贝叶斯方法"></a>贝叶斯方法</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="了解贝叶斯决策论"><a href="#了解贝叶斯决策论" class="headerlink" title="了解贝叶斯决策论"></a>了解贝叶斯决策论</h4><p>贝叶斯决策论更多地从观察者的角度出发, 事件的随机性是由观察者掌握的信息不够充分造成的, 观察者所掌握的信息充分程度将影响观察者对于事件的认知<br>贝叶斯决策理论的核心思想是 ：选择具有最高发生概率的事件作为最优决策，新的数据点被归类到了概率较高的那一个类别</p><h4 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h4><p>以贝叶斯定理为基础的分类算法</p><h4 id="先验概率：𝑃-𝑌"><a href="#先验概率：𝑃-𝑌" class="headerlink" title="先验概率：𝑃(𝑌)"></a>先验概率：𝑃(𝑌)</h4><p>根据以往经验和分析得到的概率。我们用𝑃(𝑌)来代表在没有训练数据前假设𝑌拥有的初始概率 </p><h4 id="后验概率：𝑃-𝑌-𝑋"><a href="#后验概率：𝑃-𝑌-𝑋" class="headerlink" title="后验概率：𝑃(𝑌|𝑋)"></a>后验概率：𝑃(𝑌|𝑋)</h4><p>根据已经发生的事件来分析得到的概率。反映了在看到训练数据𝑋后𝑌成立的置信度 </p><h4 id="联合概率：𝑃-𝑋-𝑌"><a href="#联合概率：𝑃-𝑋-𝑌" class="headerlink" title="联合概率：𝑃(𝑋,𝑌)"></a>联合概率：𝑃(𝑋,𝑌)</h4><p>联合概率是指多元的概率分布中多个随机变量分别满足各自条件的概率。<br>𝑋与𝑌的联合概率表示为𝑃(𝑋,𝑌) 、𝑃(𝑋𝑌) 或𝑃(𝑋 ∩ 𝑌)<br> 假设𝑋和𝑌都服从正态分布，那么𝑃(𝑋 &lt; 5, 𝑌 &lt; 0)就是一个联合概率，表示 𝑋 &lt; 5, 𝑌 &lt; 0两个条件同时成立的概率。表示两个事件共同发生的概率。 </p><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007702.png" alt=""></p><h2 id="朴素贝叶斯原理"><a href="#朴素贝叶斯原理" class="headerlink" title="朴素贝叶斯原理"></a>朴素贝叶斯原理</h2><h3 id="判别模型和生成模型"><a href="#判别模型和生成模型" class="headerlink" title="判别模型和生成模型"></a>判别模型和生成模型</h3><p>监督学习方法又分：生成方法（Generative approach）和判别方法（Discriminative approach）<br>所学到的模型分别称为：生成模型（Generative Model）和判别模型（Discriminative Model)<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007703.png" alt=""></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>  朴素贝叶斯法是典型的生成学习方法<br>:::info<br> 朴素贝叶斯方法在传统的贝叶斯方法上作出基本假设:条件独立性<br>:::<br>条件独立性假设：<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007704.png" alt=""><br> 优点：高效、且易于实现，缺点：对于属性特征之间作出相互独立的假设，导致分类性能不一定很高<br>:::info<br> 朴素贝叶斯法利用贝叶斯定理与学到的联合概率模型进行分类预测<br>:::<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007705.png" alt=""><br>贝叶斯公式：<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007706.png" alt=""><br>根据全概率公式，以下公式对于所有贝叶斯定理都成立，包括朴素贝叶斯<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007707.png" alt=""><br>根据条件独立假设：以下公式只对朴素贝叶斯成立<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007708.png" alt=""></p><h2 id="朴素贝叶斯案例"><a href="#朴素贝叶斯案例" class="headerlink" title="朴素贝叶斯案例"></a>朴素贝叶斯案例</h2><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007709.png" alt=""><br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007710.png" alt=""><br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007711.png" alt=""><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007712.png" alt=""><br>采用拉普拉斯平滑方法：为每个计数加1，因此它永远不会为零。为了平衡这一点，我们将可能单词的数量添加到除数中，因此计算结果永远不会大于1<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007713.png" alt=""><br>拉普拉斯平滑方法：<br>是一种用于平滑分类数据的技术。引入拉普拉斯平滑法来解决零概率问题,通过应用此方法,先验概率和条件概率可以写为 ：<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007714.png" alt=""><br>加入拉普拉斯平滑之后，避免了出现概率为0的情况，又保证了每个值都在0到1的范围内，又保证了最终和为1的概率性质。<br> <img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405271007715.png" alt=""></p><h2 id="朴素贝叶斯代码实现"><a href="#朴素贝叶斯代码实现" class="headerlink" title="朴素贝叶斯代码实现"></a>朴素贝叶斯代码实现</h2><p>最常用的GaussianNB是高斯朴素贝叶斯分类器。它假设特征的条件概率分布满足高斯分布：<br>$P\big(X^{(j)}\big|y=c_k\big)=\frac{1}{\sqrt{2\pi\sigma_k^2}}\exp\left(-\frac{(X^{(j)}-\mu_k)^2}{2\sigma_k^2}\right)$<br>MultinonmialNB是多项式朴素贝叶斯分类器，假设特征的条件概率分布满足多项式分布<br>BernoulliNB是伯努利朴素贝叶斯分类，假设特征的条件概率分布满足二项式分布</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 朴素贝叶斯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章_链表_part02</title>
      <link href="/2024/05/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E9%93%BE%E8%A1%A8_part02/"/>
      <url>/2024/05/10/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E9%93%BE%E8%A1%A8_part02/</url>
      
        <content type="html"><![CDATA[<h2 id="24-两两交换链表中的节点链接"><a href="#24-两两交换链表中的节点链接" class="headerlink" title="24.两两交换链表中的节点链接"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">24.两两交换链表中的节点</a><a href="">链接</a></h2><h3 id="题目复述："><a href="#题目复述：" class="headerlink" title="题目复述："></a>题目复述：</h3><p>对于一个链表中元素，从链表的头到链表的尾两个一组，交换他们的位置，不是值<br>例如 A-&gt;B 变为B-&gt;A</p><h3 id="看到题目的第一想法"><a href="#看到题目的第一想法" class="headerlink" title="看到题目的第一想法"></a>看到题目的第一想法</h3><p>遍历原链表，如果元素的次序为奇数，添加到奇链表的尾部。如果元素的次序为偶数，添加到偶链表的尾部。<br>这样，题目中的原链表就相当于先从奇链表取一个，偶链表取一个，重复步骤。<br>而题目中要求的新链表就是先从偶链表取一个，再从奇链表取一个，重复步骤<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201630415.jpg" alt=""><br>代码如下，花了我快一个半小时，主要是忘记不同的链表起始是共用一个元素节点了，且共用一个next了，还是就是不能对nullptr的进行操作，这种边界问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode*headA=head;</span><br><span class="line">    ListNode*headB=head-&gt;next;</span><br><span class="line">    ListNode* tempA = headA,*tempB = headB,*temp;</span><br><span class="line">    ListNode*res,*temp_res; </span><br><span class="line">    <span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            tempA-&gt;next=head-&gt;next;</span><br><span class="line">            tempA=tempA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            tempB-&gt;next=head-&gt;next;</span><br><span class="line">            tempB=tempB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tempA!=<span class="literal">nullptr</span>)tempA=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(tempB!=<span class="literal">nullptr</span>)tempB=<span class="literal">nullptr</span>;</span><br><span class="line">    res = headB;</span><br><span class="line"></span><br><span class="line">    temp_res =res;</span><br><span class="line">    count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(headA!=<span class="literal">nullptr</span>&amp;&amp;headB!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(headB-&gt;next!=<span class="literal">nullptr</span>) headB= headB-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> headB =<span class="literal">nullptr</span>;</span><br><span class="line">            temp_res-&gt;next = headA;</span><br><span class="line">            temp_res=temp_res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(headA-&gt;next!=<span class="literal">nullptr</span>) headA= headA-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> headA =<span class="literal">nullptr</span>;</span><br><span class="line">            temp_res-&gt;next = headB;</span><br><span class="line">            temp_res=temp_res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201630438.jpg" alt=""><br>遗留问题：加不加下面的代码，用时有很大不同，有空继续探究，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tempA!=nullptr)tempA=nullptr;</span><br><span class="line"><span class="keyword">if</span>(tempB!=nullptr)tempB=nullptr;</span><br></pre></td></tr></table></figure><br>因为我在分割奇偶链表的时候，有一个尾部节点没有设置为nullptr,修改代码如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(head-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">        tempA-&gt;next=head-&gt;next;</span><br><span class="line">        tempA=tempA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        tempB-&gt;next=head-&gt;next;</span><br><span class="line">        tempB=tempB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">tempA-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">tempB-&gt;next=<span class="literal">nullptr</span></span><br></pre></td></tr></table></figure></p><h3 id="代码随想录的思路"><a href="#代码随想录的思路" class="headerlink" title="代码随想录的思路"></a>代码随想录的思路</h3><p>直接模拟：<br>思路如下：<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201630473.jpg" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    vhead -&gt;next = head;</span><br><span class="line">    ListNode* cur = vhead;</span><br><span class="line">    ListNode*t1,*t2;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = cur-&gt;next;</span><br><span class="line">            t2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">            cur -&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = t1;</span><br><span class="line">            t1 -&gt;next = t2;</span><br><span class="line"></span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19.删除链表的倒数第N个节点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">19.删除链表的倒数第N个节点</a></h2><h3 id="题目复述：-1"><a href="#题目复述：-1" class="headerlink" title="题目复述："></a>题目复述：</h3><p>给你一个链表和n，返回删除倒数第n个节点后的连链表</p><h3 id="看到题目的第一想法："><a href="#看到题目的第一想法：" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>先遍历链表，求出链表的元素总个数，然后求出删除结点前的节点个数，<br>第二次遍历链表，定位到删除节点的前一个位置，删除节点，在不是使用虚拟头节点的时候，删除头节点，p不能等于head，使用vhead时，代码如下ac<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    vhead-&gt;next=head;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode*p=head;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = count-n;</span><br><span class="line">    p = vhead;</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>carl说可以用双指针，我没看详细分析步骤，我自己想的双指针的算法，front，rear初始等于head节点，先让front指针先走n步，然后front，rear指针同步向前移动，当front的next的为nullnptr时，rear指针的位置就是要删除的前一个节点位置，<br>考虑到当n等于链表的长度时，代码会有问题，所以使用带虚拟节点的链表。<br>思路如下：<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201630504.jpg" alt=""><br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *vhead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    vhead-&gt;next=head;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>||head-&gt;next==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *front=vhead,*rear=vhead;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        front=front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        front=front-&gt;next;</span><br><span class="line">        rear= rear-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next= rear-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>和代码随想录，思路大致相同</p><h2 id="面试题-链表相交"><a href="#面试题-链表相交" class="headerlink" title="面试题.链表相交"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">面试题.链表相交</a></h2><h3 id="题目复述：-2"><a href="#题目复述：-2" class="headerlink" title="题目复述："></a>题目复述：</h3><p>给你两个链表，找到他们指向同一个节点位置，返回这个节点，如果没有，返回NULL</p><h3 id="看到题目的第一想法：-1"><a href="#看到题目的第一想法：-1" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>遍历两个链表，求出他们的列表元素的个数，然后长链表指针先走两者差值，之后，长短链表同步移动，当他们节点地址是相同的，则返回该节点<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(headA==<span class="literal">NULL</span>||headB==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> lenA=<span class="number">0</span>,lenB=<span class="number">0</span>;</span><br><span class="line">    ListNode *pA = headA,*pB= headB;</span><br><span class="line">    <span class="keyword">while</span>(pA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        pA=pA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pB!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        pB=pB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pA = headA,pB = headB;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">abs</span>(lenA-lenB);</span><br><span class="line">    <span class="keyword">if</span>(lenA&gt;lenB)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            pA = pA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pA!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pA==pB) <span class="keyword">return</span> pA;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pA= pA-&gt;next;</span><br><span class="line">  -          pB = pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>和代码随想录，思路大致相同</p><h2 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">142.环形链表II</a></h2><h3 id="题目复述：-3"><a href="#题目复述：-3" class="headerlink" title="题目复述："></a>题目复述：</h3><p>给你一个链表，返回链表开始开始入环到的第一个节点。如果链表无环，则返回null</p><h3 id="看到题目的第一想法：-2"><a href="#看到题目的第一想法：-2" class="headerlink" title="看到题目的第一想法："></a>看到题目的第一想法：</h3><p>遍历链表，将链表节点存到unordered_set中，每次遍历，查找unordered_set是否含有相同节点，如果有返回该节点，如果没有将节点添加到集合set中.<br>自己的想法ac了，真的很开心！<br>代码如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode*&gt;mySet;</span><br><span class="line">        ListNode*p = head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mySet.<span class="built_in">find</span>(p)!=mySet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            mySet.<span class="built_in">insert</span>(p);</span><br><span class="line">            p= p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录:"></a>代码随想录:</h3><h4 id="判断是否有环："><a href="#判断是否有环：" class="headerlink" title="判断是否有环："></a>判断是否有环：</h4><p>使用快慢指针法，fast指针从头节点出发，每次移动两个节点，<br>slow指针从头节点出发，每次移动一个节点，如果fast和slow指针相遇，则链表中有环。</p><h4 id="如果有环且能相遇，则一定能相遇在环中？"><a href="#如果有环且能相遇，则一定能相遇在环中？" class="headerlink" title="如果有环且能相遇，则一定能相遇在环中？"></a>如果有环且能相遇，则一定能相遇在环中？</h4><p>fast先进环，一直在环里走动，等待slow进环，然后相遇。</p><h4 id="为什么fast指针，slow指针能相遇？"><a href="#为什么fast指针，slow指针能相遇？" class="headerlink" title="为什么fast指针，slow指针能相遇？"></a>为什么fast指针，slow指针能相遇？</h4><p>注意当slow指针和fast指针都在环里时，fast相对slow指针的相对速度为1节点/s，而环的总长为整数，则必定能相遇</p><h4 id="为什么当slow指针，fast指针相遇时。slow仅仅只在第一圈相遇？"><a href="#为什么当slow指针，fast指针相遇时。slow仅仅只在第一圈相遇？" class="headerlink" title="为什么当slow指针，fast指针相遇时。slow仅仅只在第一圈相遇？"></a>为什么当slow指针，fast指针相遇时。slow仅仅只在第一圈相遇？</h4><p>设环的长度为l<br>假设某时刻，slow指针在环入口，fast指针可以在环的任意位置。此次fast距离环口w,<br>则slow指针完成第一圈的时间为l秒<br>注意我们求过两者的相对速度为1节点/s，把fast追上slow的时间为w秒,w秒小于l秒。<br>所以在fast指针追上slow指针时，slow仅仅在第一圈。<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405201630533.png" alt=""><br>$(x + y) * 2 = x + y + n (y + z)$<br>$x = (n - 1) (y + z) + z$<br>即指针slow指针从相遇节点出发，与p指针(步长也为1节点每秒)两者一定会相遇<br>相遇时，p即为环的入口<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head,*fast = head;</span><br><span class="line">        <span class="comment">// fast-&gt;next!=NULL，防止对NULL指针就行操作</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">                ListNode*p = head;</span><br><span class="line">                <span class="keyword">while</span>(p!=slow)&#123;</span><br><span class="line">                    p=p-&gt;next;</span><br><span class="line">                    slow=slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django 学习</title>
      <link href="/2024/04/13/Django%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/13/Django%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="项目的创建与启动"><a href="#项目的创建与启动" class="headerlink" title="项目的创建与启动"></a>项目的创建与启动</h2><p>cmd输入命令创建项目(包含基本的项目框架),类似于vue<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject demo1</span><br></pre></td></tr></table></figure><br>创建后的项目结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">demo1/</span><br><span class="line">    manage.py             </span><br><span class="line">    bysms/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><br>运行服务器<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver 8080</span><br></pre></td></tr></table></figure></p><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>定义：django ORM（Object Relational Mapping，简称 ORM ）对象关系模型<br>作用：将python代码转化成为SQL语句，对各种数据库都提供很好的支持，MySQL、SQLite、Oracle，实现相同python代码，不同数据库操作语言，实现相同功能<br><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405281049596.png" alt="image.png"><br>django 的ORM</p><ul><li>定义一张数据库的表 就是定义一个继承自 django.db.models.Model 的类</li><li>定义该表中的字段（列）， 就是定义该类里面的一些属性</li><li>类的方法就是对该表中数据的处理方法，包括 数据的增删改查</li></ul><p>好处：<br>将底层的sql语句，变成面向对象语言<br>更换数据库后，不需要更换数据库语言，更换项目下setting.py中的配置</p><h2 id="数据库的配置与迁移"><a href="#数据库的配置与迁移" class="headerlink" title="数据库的配置与迁移"></a>数据库的配置与迁移</h2><h3 id="配置默认的数据库形式-db-sqlite3"><a href="#配置默认的数据库形式-db-sqlite3" class="headerlink" title="配置默认的数据库形式 db.sqlite3"></a>配置默认的数据库形式 db.sqlite3</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建数据库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><br>在 项目的根目录下面 生成一个配置文件中指定的数据库文件 db.sqlite3<br>db.sqlite3 是数据库文件，内容包括基本表，和app下model.py定义的类<br>sqlite数据库工具sqlitestudio <a href="https://sqlitestudio.pl/">https://sqlitestudio.pl/</a></p><h3 id="配置mysql数据库"><a href="#配置mysql数据库" class="headerlink" title="配置mysql数据库"></a>配置mysql数据库</h3><p>在项目的settings.py中找到DATABASES配置项，配置mysql<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123; </span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,    <span class="comment"># 数据库引擎</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;tangwan16&#x27;</span>, <span class="comment"># 数据库名称</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment"># 数据库地址，本机 ip 地址 127.0.0.1 </span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="number">3306</span>, <span class="comment"># 端口 </span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,  <span class="comment"># 数据库用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;1234&#x27;</span>, <span class="comment"># 数据库密码</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在与 settings.py 同级目录下的 __init__.py 中引入模块和进行配置 </span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></p><h2 id="创建app"><a href="#创建app" class="headerlink" title="创建app"></a>创建app</h2><p>什么是项目app<br>一个项目app可以理解为一个功能模块，一个项目可以含有多个app，每个app相互独立<br>创建app目录命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startapp 功能模块名</span><br></pre></td></tr></table></figure></p><h2 id="路由表与路由子表"><a href="#路由表与路由子表" class="headerlink" title="路由表与路由子表"></a>路由表与路由子表</h2><h3 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><p>同时设置url路由，项目目录下的url.py，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="comment"># 别忘了导入 listorders 函数</span></span><br><span class="line"><span class="keyword">from</span> sales.views <span class="keyword">import</span> listorders</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># 添加如下的路由记录</span></span><br><span class="line">    path(<span class="string">&#x27;sales/orders/&#x27;</span>, listorders),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>就是说当前端过来的请求 url地址 是 /sales/orders/ (注意：最后的一个斜杠不能省略) , 就由 views.py 里面的函数 listorders 来处理。</p><h3 id="路由子表"><a href="#路由子表" class="headerlink" title="路由子表"></a>路由子表</h3><p>当项目目录下的url.py中访问url条目过多时，将不同的路由记录按照功能分拆到不同的 <strong>url路由子表</strong> 文件中。<br>比如，这里我们可以把 访问 的 url 凡是 以 sales 开头的全部都 由 sales app目录下面的 子路由文件 urls.py 处理<br>app中的url.py  sales\urls.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;orders/&#x27;</span>, views.listorders),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>项目中的url.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="comment"># 导入一个include函数</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"><span class="keyword">from</span> sales.views <span class="keyword">import</span> listorders</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    <span class="comment"># 凡是 url 以 sales/  开头的，</span></span><br><span class="line">    <span class="comment"># 都根据 sales.urls 里面的 子路由表进行路由</span></span><br><span class="line">    path(<span class="string">&#x27;sales/&#x27;</span>, include(<span class="string">&#x27;sales.urls&#x27;</span>)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>注意这时，会从请求url中去掉 前面主路由文件 已经匹配上的部分（这里是 sales/ ）, 将剩余的部分 （这里是 orders/ ）去子路由文件中查看是否有匹配的路由项。</p><h2 id="定义数据库"><a href="#定义数据库" class="headerlink" title="定义数据库"></a>定义数据库</h2><p>创建一个名为common的应用目录， 里面存放我们项目需要的一些公共的表的定义。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp common</span><br></pre></td></tr></table></figure><br>在app下model.py中定义我们需要的表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    num = models.FloatField(null=<span class="literal">True</span>)</span><br><span class="line">job_number = models.IntegerField(null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 包含年月日时分秒</span></span><br><span class="line">createtime = models.DateTimeField(null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 包含年月日</span></span><br><span class="line">createdate = models.DateField(null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>创建数据库表<br>首先我们需要告诉Django： 我们的 common 应用中 需要你关注， 因为其中包含了 数据库Model的定义。<br>配置项目下的settings.py下  INSTALLED_APPS 配置项<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="comment"># 加入下面这行</span></span><br><span class="line">    <span class="string">&#x27;common.apps.CommonConfig&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>‘common.apps.CommonConfig’ 告诉 Django ， CommonConfig 是 common/apps.py 文件中定义的一个应用配置的类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommonConfig</span>(<span class="title class_ inherited__">AppConfig</span>):</span><br><span class="line">    name = <span class="string">&#x27;common&#x27;</span></span><br></pre></td></tr></table></figure><br>更新数据库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations common</span><br><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><br>自此数据库文件中添加Customer表<br>注意：我们创建的表默认的逐渐是id（即使类中没有id属性）<br>当我们在已经创建表之后,修改model.py添加属性，执行上述步骤，可能会要求指定默认值，或者允许为空</p><h2 id="Django-Admin-管理数据"><a href="#Django-Admin-管理数据" class="headerlink" title="Django Admin 管理数据"></a>Django Admin 管理数据</h2><p>Django提供了一个管理员操作界面可以方便的 添加、修改、删除你定义的 model 表数据。<br>首先，我们需要创建 一个超级管理员账号。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><br>要求输入用户名和密码,密码至少八位<br>现在就可以访问 <a href="http://127.0.0.1/admin/">http://127.0.0.1/admin/</a> ，输入刚才注册的用户密码登录。<br>提供ui界面来定义model表数据<br>如果你是中文的操作系统，想使用中文的admin界面，应该在配置文件 settings.py 中 MIDDLEWARE 最后加入如下配置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># admin界面语言本地化</span></span><br><span class="line">    <span class="string">&#x27;django.middleware.locale.LocaleMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="添加处理请求模块和url路由"><a href="#添加处理请求模块和url路由" class="headerlink" title="添加处理请求模块和url路由"></a>添加处理请求模块和url路由</h2><p>不同的操作请求，使用不同的 HTTP 请求方法 ，比如 添加是POST， 查询是 GET， 修改是 PUT， 删除是 DELETE。<br>但是注意：Django 的 url路由功能 <strong>不支持</strong> 根据 HTTP 请求的方法 和请求体里面的参数 进行路由。<br>以下是错误代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">&#x27;customers/&#x27;</span>, <span class="string">&#x27;app.views.list_customer&#x27;</span>, method=<span class="string">&#x27;get&#x27;</span>),</span><br><span class="line">path(<span class="string">&#x27;customers/&#x27;</span>, <span class="string">&#x27;app.views.add_customer&#x27;</span>,  method=<span class="string">&#x27;post&#x27;</span>),</span><br></pre></td></tr></table></figure></p><h3 id="使用dispatcher分发函数进行处理"><a href="#使用dispatcher分发函数进行处理" class="headerlink" title="使用dispatcher分发函数进行处理"></a>使用dispatcher分发函数进行处理</h3><p>自己编写一个函数， 来 根据 http请求的类型 和请求体里面的参数 分发（或者说路由）给 不同的函数进行处理。<br>可以 在 customer.py 中定义如下 dispatcher 函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dispatcher</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 将请求参数统一放入request 的 params 属性中，方便后续处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># GET请求 参数在url中，同过request 对象的 GET属性获取</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        request.params = request.GET</span><br><span class="line"></span><br><span class="line">    <span class="comment"># POST/PUT/DELETE 请求 参数 从 request 对象的 body 属性中获取</span></span><br><span class="line">    <span class="keyword">elif</span> request.method <span class="keyword">in</span> [<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;PUT&#x27;</span>,<span class="string">&#x27;DELETE&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 根据接口，POST/PUT/DELETE 请求的消息体都是 json格式</span></span><br><span class="line">        request.params = json.loads(request.body)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据不同的action分派给不同的函数进行处理</span></span><br><span class="line">    action = request.params[<span class="string">&#x27;action&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">&#x27;list_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> listcustomers(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;add_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> addcustomer(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;modify_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> modifycustomer(request)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">&#x27;del_customer&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> deletecustomer(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;不支持该类型http请求&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><br>该函数 把 请求消息中的参数统一放入到 request请求对象的params 属性中。<br>params 属性 被 做成一个 dict 类型 ， 方便后面的处理函数来获取消息中的参数。<br>比如 action 参数 为 ‘add_customer’ 的 请求 就由 addcustomer 函数 进行处理<br>app下的url.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> mgr <span class="keyword">import</span> customer</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;customers&#x27;</span>, customer.dispatcher),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>凡是 API 请求url为 /api/mgr/customers 的，都交由 我们上面定义的dispatch函数进行分派处理</p><h3 id="使用类中的参数方法"><a href="#使用类中的参数方法" class="headerlink" title="使用类中的参数方法"></a>使用类中的参数方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> = [</span><br><span class="line">    path(<span class="string">&quot;recognize/&quot;</span>, dvadmin.face.views.face_recognize_url.as_view()),  <span class="comment"># 人脸识别接口</span></span><br><span class="line">    path(<span class="string">&quot;entry/&quot;</span>, dvadmin.face.views.face_entry_url.as_view()),  <span class="comment"># 人脸录入接口</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人脸录入接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">face_entry_url</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self,request</span>):</span><br><span class="line"><span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line"><span class="string">&#x27;code&#x27;</span>: <span class="number">2000</span>,</span><br><span class="line"><span class="string">&#x27;msg&#x27;</span>: <span class="string">&quot;模型训练失败&quot;</span>,</span><br><span class="line"><span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self, request</span>):</span><br><span class="line">        <span class="comment"># 人脸姓名</span></span><br><span class="line">        name = request.data.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> JsonResponse(&#123;</span><br><span class="line"><span class="string">&#x27;code&#x27;</span>: <span class="number">2000</span>,</span><br><span class="line"><span class="string">&#x27;msg&#x27;</span>: <span class="string">&quot;模型训练失败&quot;</span>,</span><br><span class="line"><span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="临时取消CSRF校验"><a href="#临时取消CSRF校验" class="headerlink" title="临时取消CSRF校验"></a>临时取消CSRF校验</h2><p>项目/settings.py 中 MIDDLEWARE 配置项 里 注释掉’django.middleware.csrf.CsrfViewMiddleware’ 即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="返回特定的数据格式"><a href="#返回特定的数据格式" class="headerlink" title="返回特定的数据格式"></a>返回特定的数据格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: <span class="string">&quot;江苏省常州武进市白云街44号&quot;</span>,</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;武进市 袁腾飞&quot;</span>,</span><br><span class="line">            <span class="string">&quot;phonenumber&quot;</span>: <span class="string">&quot;13886666666&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;address&quot;</span>: <span class="string">&quot;北京海淀区&quot;</span>,</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;北京海淀区代理 蔡国庆&quot;</span>,</span><br><span class="line">            <span class="string">&quot;phonenumber&quot;</span>: <span class="string">&quot;13990123456&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 Customer </span></span><br><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> Customer</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Customer.objects.values()</span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    <span class="comment"># 否则不能 被 转化为 JSON 字符串</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;data&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure><p>实现功能：浏览器访问 sales/customers/ ，我们的服务端就返回系统中所有的客户记录给浏览器。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入 Customer 对象定义</span></span><br><span class="line"><span class="keyword">from</span>  common.models <span class="keyword">import</span>  Customer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listcustomers</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    <span class="comment"># 每条表记录都是是一个dict对象，</span></span><br><span class="line">    <span class="comment"># key 是字段名，value 是 字段值</span></span><br><span class="line"><span class="comment"># 通过objects这个模型管理器的all()获得所有数据行，相当于SQL中的SELECT * FROM</span></span><br><span class="line">    res = Customer.objects.values()</span><br><span class="line"></span><br><span class="line"><span class="comment"># filter相当于SQL中的WHERE，可设置条件过滤结果</span></span><br><span class="line">    res = Customer.objects.<span class="built_in">filter</span>(name=<span class="string">&quot;tangwan&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤条件可以有多个</span></span><br><span class="line">res = Customer.objects.<span class="built_in">filter</span>(phonenumber=ph,address=<span class="string">&#x27;安徽芜湖&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取单个对象</span></span><br><span class="line">    res = Test.objects.get(<span class="built_in">id</span>=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">    <span class="comment">#数据排序,默认升序</span></span><br><span class="line">    res =Customer.objects.order_by(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限制返回的数据，返回以id升序的前两条数据</span></span><br><span class="line">    res =Customer.objects.order_by(<span class="string">&#x27;id&#x27;</span>)[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(<span class="string">&#x27;data&#x27;</span>:res)</span><br></pre></td></tr></table></figure></p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>前端提供的客户数据格式如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;action&quot;</span>:<span class="string">&quot;add_customer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;data&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:<span class="string">&quot;武汉市桥西医院&quot;</span>,</span><br><span class="line">        <span class="string">&quot;phonenumber&quot;</span>:<span class="string">&quot;13345679934&quot;</span>,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>:<span class="string">&quot;武汉市桥西医院北路&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">addcustomer</span>(<span class="params">request</span>):</span><br><span class="line">    info    = request.params[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    <span class="comment"># 从请求消息中 获取要添加客户的信息</span></span><br><span class="line">    <span class="comment"># 并且插入到数据库中</span></span><br><span class="line">    <span class="comment"># 返回值 就是对应插入记录的对象 </span></span><br><span class="line">    record = Customer.objects.create(name=info[<span class="string">&#x27;name&#x27;</span>] ,</span><br><span class="line">                            phonenumber=info[<span class="string">&#x27;phonenumber&#x27;</span>] ,</span><br><span class="line">                            address=info[<span class="string">&#x27;address&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;data&#x27;</span>:record.<span class="built_in">id</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>前端提供的数据格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;action&quot;</span>:<span class="string">&quot;modify_customer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">&quot;newdata&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>:<span class="string">&quot;武汉市桥北医院&quot;</span>,</span><br><span class="line">        <span class="string">&quot;phonenumber&quot;</span>:<span class="string">&quot;13345678888&quot;</span>,</span><br><span class="line">        <span class="string">&quot;address&quot;</span>:<span class="string">&quot;武汉市桥北医院北路&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>修改数据可以使用 save() 或 update():<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modifycustomer</span>(<span class="params">request</span>):</span><br><span class="line"><span class="comment"># 修改其中一个id=1的name字段，再save，相当于SQL中的UPDATE</span></span><br><span class="line">    test1 = Customer.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">    test1.name = <span class="string">&#x27;Google&#x27;</span></span><br><span class="line">    test1.save()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另外一种方式</span></span><br><span class="line">    Customer.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">1</span>).update(name=<span class="string">&#x27;Google&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改所有的列</span></span><br><span class="line">    Test.objects.<span class="built_in">all</span>().update(name=<span class="string">&#x27;Google&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取修改客户的信息</span></span><br><span class="line">    <span class="comment"># 找到该客户，并且进行修改操作</span></span><br><span class="line"></span><br><span class="line">    customerid = request.params[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    newdata    = request.params[<span class="string">&#x27;newdata&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 根据 id 从数据库中找到相应的客户记录</span></span><br><span class="line">        customer = Customer.objects.get(<span class="built_in">id</span>=customerid)</span><br><span class="line">    <span class="keyword">except</span> Customer.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span>  &#123;</span><br><span class="line">                <span class="string">&#x27;code&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;id 为`<span class="subst">&#123;customerid&#125;</span>`的客户不存在&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        customer.name = newdata[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;phonenumber&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        customer.phonenumber = newdata[<span class="string">&#x27;phonenumber&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;address&#x27;</span> <span class="keyword">in</span>  newdata:</span><br><span class="line">        customer.address = newdata[<span class="string">&#x27;address&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注意，一定要执行save才能将修改信息保存到数据库</span></span><br><span class="line">    customer.save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;msg&#x27;</span>: <span class="string">&quot;更新数据成功&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>前段提供的数据格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;action&quot;</span>:<span class="string">&quot;del_customer&quot;</span>,</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">deletecustomer</span>(<span class="params">request</span>):</span><br><span class="line">    customerid = request.params[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line"><span class="comment"># 根据 id 从数据库中找到相应的客户记录</span></span><br><span class="line">customer = Customer.objects.get(<span class="built_in">id</span>=customerid)</span><br><span class="line">    <span class="comment"># delete 方法就将该记录从数据库中删除了</span></span><br><span class="line">    customer.delete()</span><br><span class="line"><span class="comment"># 另外一种方式</span></span><br><span class="line">    Customer.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=customerid).delete()</span><br><span class="line"><span class="comment"># 删除所有数据</span></span><br><span class="line">    Customer.objects.<span class="built_in">all</span>().delete()</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;msg&#x27;</span>: <span class="string">&quot;删除成功&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="数据库表的关联"><a href="#数据库表的关联" class="headerlink" title="数据库表的关联"></a>数据库表的关联</h2><p>常见的3种关联关系：一对多，一对一，多对多</p><h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>表之间 一对多 的关系，就是 外键 关联关系<br>如果一个表中 的 某个字段是外键，那就意味着这外键字段的记录的取值，只能是它关联表的某个记录的主键的值。<br>我们定义表的 Model类的时候，如果没有指定主键字段，migrate 的时候 Django 会为该Model对应的数据库表自动生成一个id字段，作为主键。<br>Django中定义外键 的方法就是 Model类的该属性字段 值为 ForeignKey 对象，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(models.Model):</span><br><span class="line">    <span class="comment"># 订单名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 创建日期</span></span><br><span class="line">    create_date = models.DateTimeField(default=datetime.datetime.now)</span><br><span class="line">    <span class="comment"># 客户</span></span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)</span><br></pre></td></tr></table></figure><br> customer 字段 是外键， 指向 Customer 类。 意思就是告诉Django： Order表的 customer 字段 指向 Customer表的主键 的一个外键。<br>另外一个参数 <strong>on_delete</strong> 指定了 当我们想 删除 外键指向的主键 记录时， 系统的行为。<br>比如 我们要删除客户记录， 那么 Order表中 对应这个客户的订单记录 该如何处理呢？</p><ul><li>CASCADE</li></ul><p>删除主键记录和 相应的外键表记录。<br>比如，我们要删除客户张三，在删除了客户表中张三记录同时，也删除Order表中所有这个张三的订单记录</p><ul><li>PROTECT</li></ul><p>禁止删除记录。<br>比如，我们要删除客户张三，如果Order表中有张三的订单记录，Django系统 就会抛出ProtectedError类型的异常，当然也就禁止删除 客户记录和相关的订单记录了。<br>除非我们将Order表中所有张三的订单记录都先删除掉，才能删除该客户表中的张三记录。</p><ul><li>SET_NULL</li></ul><p>删除主键记录，并且将外键记录中外键字段的值置为null。 当然前提是外键字段要设置为值允许是null。<br>比如，我们要删除客户张三时，在删除了客户张三记录同时，会将Order表里面所有的 张三记录里面的customer字段值置为 null。 但是上面我们并没有设置 customer 字段有 null=True 的参数设置，所以，是不能取值为 SET_NULL的。<br>注意： 外键字段，实际在数据库表中的 字段名， 是 Django ForeignKey 定义 字段名加上后缀 _id 。<br>比如这里，在执行了 migrate 命令更新数据库后， customer 这个外键字段实际上在 数据库表中的字段名 是 customer_id</p><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>Django 中 用 OneToOneField 对象 实现 一对一 的关系，如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    <span class="comment"># 姓名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 班级</span></span><br><span class="line">    classname = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 描述</span></span><br><span class="line">    desc = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ContactAddress</span>(models.Model):</span><br><span class="line">    <span class="comment"># 一对一 对应学生 </span></span><br><span class="line">    student = models.OneToOneField(Student, on_delete=models.PROTECT)</span><br><span class="line">    <span class="comment"># 家庭</span></span><br><span class="line">    homeaddress = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    <span class="comment"># 电话号码</span></span><br><span class="line">    phone = models.CharField(max_length=<span class="number">200</span>)</span><br></pre></td></tr></table></figure><br>Django发现这样一对一定义，它会在migrate的时候，在数据库中定义该字段为外键的同时， 加上 unique=True 约束，表示在此表中，所有记录的该字段 取值必须唯一，不能重复。</p><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>Django是通过 ManyToManyField 对象 表示 多对多的关系的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(models.Model):</span><br><span class="line">    <span class="comment"># 订单名</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建日期</span></span><br><span class="line">    create_date = models.DateTimeField(default=datetime.datetime.now)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 客户</span></span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订单购买的药品，和Medicine表是多对多 的关系</span></span><br><span class="line">    medicines = models.ManyToManyField(Medicine, through=<span class="string">&#x27;OrderMedicine&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderMedicine</span>(models.Model):</span><br><span class="line">    order = models.ForeignKey(Order, on_delete=models.PROTECT)</span><br><span class="line">    medicine = models.ForeignKey(Medicine, on_delete=models.PROTECT)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订单中药品的数量</span></span><br><span class="line">    amount = models.PositiveIntegerField()</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medicines = models.ManyToManyField(Medicine, through=<span class="string">&#x27;OrderMedicine&#x27;</span>)</span><br></pre></td></tr></table></figure><br>指定Order表和 Medicine 表 的多对多关系， 其实Order表中并不会产生一个 叫 medicines 的字段。<br>Order表和 Medicine 表 的多对多关系 是 <strong>通过另外一张表</strong>， 也就是 through 参数 指定的 OrderMedicine 表 来确定的。</p><h2 id="ORM关联表、事务"><a href="#ORM关联表、事务" class="headerlink" title="ORM关联表、事务"></a>ORM关联表、事务</h2><p>Django ORM 如何操作外键关联关系<br>models.py中定义这样的两个Model，对应两张表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国家表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 学生表， country 字段是国家表的外键，形成一对多的关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name    = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    grade   = models.PositiveSmallIntegerField()</span><br><span class="line">    country = models.ForeignKey(Country,</span><br><span class="line">                                on_delete=models.PROTECT)</span><br></pre></td></tr></table></figure><br>命令行为数据库添加数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure><br>直接启动Django命令行，输入代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> common.models <span class="keyword">import</span> *</span><br><span class="line">c1 = Country.objects.create(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">Student.objects.create(name=<span class="string">&#x27;白月&#x27;</span>, grade=<span class="number">1</span>, country=c1)</span><br></pre></td></tr></table></figure></p><h3 id="外键表字段访问"><a href="#外键表字段访问" class="headerlink" title="外键表字段访问"></a>外键表字段访问</h3><p>如果你已经获取了一个student对象，要得到他的国家名称只需这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = Student.objects.get(name=<span class="string">&#x27;白月&#x27;</span>)</span><br><span class="line">s1.country.name</span><br></pre></td></tr></table></figure></p><h3 id="外键表字段过滤"><a href="#外键表字段过滤" class="headerlink" title="外键表字段过滤"></a>外键表字段过滤</h3><p>如果，我们要查找Student表中所有 一年级 学生<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>).values()</span><br></pre></td></tr></table></figure><br>如果现在，我们要查找Student表中所有 一年级中国 学生，该怎么写呢？<br>不能这么写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country=<span class="string">&#x27;中国&#x27;</span>)</span><br></pre></td></tr></table></figure><br>Student表中 country 并不是国家名称字符串字段，而是一个外键字段，其实是对应 Country 表中 id 字段 。<br>正确写法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country_id=cn.<span class="built_in">id</span>).values()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country=cn).values()</span><br></pre></td></tr></table></figure><br>简单写法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country__name=<span class="string">&#x27;中国&#x27;</span>).values()</span><br></pre></td></tr></table></figure><br>如果返回结果只需要 学生姓名 和 国家名两个字段，可以这样指定values内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>,country__name=<span class="string">&#x27;中国&#x27;</span>).values(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;country__name&#x27;</span>)</span><br></pre></td></tr></table></figure><br>使用 annotate 方法将获取的字段值进行重命名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="comment"># annotate 可以将表字段进行别名处理</span></span><br><span class="line">Student.objects.annotate(</span><br><span class="line">    countryname=F(<span class="string">&#x27;country__name&#x27;</span>),</span><br><span class="line">    studentname=F(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">    )\</span><br><span class="line">    .<span class="built_in">filter</span>(grade=<span class="number">1</span>,countryname=<span class="string">&#x27;中国&#x27;</span>).values(<span class="string">&#x27;studentname&#x27;</span>,<span class="string">&#x27;countryname&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h3 id="外键表反向访问"><a href="#外键表反向访问" class="headerlink" title="外键表反向访问"></a>外键表反向访问</h3><p>Django ORM中，关联表 正向关系是通过表外键字段（或者多对多）表示， 比如前面例子中Student表的 country字段。<br>而反向关系，是通过 表Model名转化为小写 表示的。<br>比如，你已经获取了一个Country对象，如何获取到所有属于这个国家的学生呢？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">cn.student_set.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure><br>通过 表Model名转化为小写 ，后面加上一个 _set 来获取所有的反向外键关联对象</p><p>或者<br>在定义Model的时候，外键字段使用 related_name 参数，像这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国家表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Country</span>(models.Model):</span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># country 字段是国家表的外键，形成一对多的关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(models.Model):</span><br><span class="line">    name    = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    grade   = models.PositiveSmallIntegerField()</span><br><span class="line">    country = models.ForeignKey(Country,</span><br><span class="line">                on_delete = models.PROTECT,</span><br><span class="line">                <span class="comment"># 指定反向访问的名字</span></span><br><span class="line">                related_name=<span class="string">&#x27;students&#x27;</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cn = Country.objects.get(name=<span class="string">&#x27;中国&#x27;</span>)</span><br><span class="line">cn.students.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></p><h3 id="外键表反向过滤"><a href="#外键表反向过滤" class="headerlink" title="外键表反向过滤"></a>外键表反向过滤</h3><p>如果我们要获取所有 具有一年级学生 的国家名，该怎么写？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先获取所有的一年级学生id列表</span></span><br><span class="line">country_ids = Student.objects.<span class="built_in">filter</span>(grade=<span class="number">1</span>).values_list(<span class="string">&#x27;country&#x27;</span>, flat=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再通过id列表使用  id__in  过滤</span></span><br><span class="line">Country.objects.<span class="built_in">filter</span>(id__in=country_ids).values()</span><br></pre></td></tr></table></figure><br>但是这样同样存在 麻烦 和性能的问题。<br>Django ORM 可以这样写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Country.objects.<span class="built_in">filter</span>(students__grade=<span class="number">1</span>).values()</span><br></pre></td></tr></table></figure><br>注意， 因为，我们定义表的时候，用 related_name=’students’ 指定了反向关联名称 students ，所以这里是 students<strong>grade 。 使用了反向关联名字。<br>如果定义时，没有指定related_name， 则应该使用 表名转化为小写 ，就是这样<br>Country.objects.filter(student</strong>grade=1).values()<br>但是，我们发现，这种方式，会有重复的记录产生，可以使用 .distinct() 去重<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Country.objects.<span class="built_in">filter</span>(students__grade=<span class="number">1</span>).values().distinct()</span><br></pre></td></tr></table></figure></p><h2 id="事务、多对多记录添加"><a href="#事务、多对多记录添加" class="headerlink" title="事务、多对多记录添加"></a>事务、多对多记录添加</h2><p>添加一条订单记录，需要在2张表（Order 和 OrderMedicine ）中添加记录。这里就有个需要特别注意的地方， 两张表的插入，意味着我们要有两次数据库操作。<br>如果第一次插入成功， 而第二次插入失败， 就会出现 Order表中 把订单信息写了一部分，而OrderMedicine表中 该订单的信息 却没有写成功。<br>这是个大问题： 就会造成 这个处理 做了一半。<br>那么数据库中就会出现数据的不一致。术语叫 脏数据<br>熟悉数据库的同学就会知道， 我们应该用 数据库 的 事务 机制来解决这个问题。<br>把一批数据库操作放在 事务 中， 该事务中的任何一次数据库操作 失败了， 数据库系统就会让 整个事务就会发生回滚，撤销前面的操作， 数据库回滚到这事务操作之前的状态。<br>Django实现事务操作，可以使用 Django 的 with transaction.atomic()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">addorder</span>(<span class="params">request</span>):</span><br><span class="line">    info  = request.params[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">    <span class="comment"># 从请求消息中 获取要添加订单的信息</span></span><br><span class="line">    <span class="comment"># 并且插入到数据库中</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        new_order = Order.objects.create(name=info[<span class="string">&#x27;name&#x27;</span>] ,</span><br><span class="line">                                         customer_id=info[<span class="string">&#x27;customerid&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        batch = [OrderMedicine(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)  </span><br><span class="line">                    <span class="keyword">for</span> mid <span class="keyword">in</span> info[<span class="string">&#x27;medicineids&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#  在多对多关系表中 添加了 多条关联记录</span></span><br><span class="line">        OrderMedicine.objects.bulk_create(batch)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>,<span class="string">&#x27;id&#x27;</span>:new_order.<span class="built_in">id</span>&#125;)</span><br></pre></td></tr></table></figure><br>with transaction.atomic() 下面 缩进部分的代码，对数据库的操作，就都是在 一个事务 中进行了。如果其中有任何一步数据操作失败了， 前面的操作都会回滚。</p><p>如果其中有任何一步数据操作失败了， 前面的操作都会回滚。、<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrderMedicine.objects.create(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>，一个订单可能会关联多个药品，也就是需要 插入 OrderMedicine 表中的数据 可能有很多条， 如果我们循环用<br>可以把多条数据的插入，放在一个SQL语句中完成， 这样会大大提高性能。<br>方法就是使用 bulk_create， 参数是一个包含所有 该表的 Model 对象的 列表<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">batch = [OrderMedicine(order_id=new_order.<span class="built_in">id</span>,medicine_id=mid,amount=<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">for</span> mid <span class="keyword">in</span> info[<span class="string">&#x27;medicineids&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#  在多对多关系表中 添加了 多条关联记录</span></span><br><span class="line">OrderMedicine.objects.bulk_create(batch)</span><br></pre></td></tr></table></figure></p><h2 id="ORM外键关联"><a href="#ORM外键关联" class="headerlink" title="ORM外键关联"></a>ORM外键关联</h2><p>编写listorder 函数用来处理 列出订单请求<br>前端要求返回订单记录数据格式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">id</span>: <span class="number">1</span>, </span><br><span class="line">        name: <span class="string">&quot;华山医院订单001&quot;</span>, </span><br><span class="line">        create_date: <span class="string">&quot;2018-12-26T14:10:15.419Z&quot;</span>,</span><br><span class="line">        customer_name: <span class="string">&quot;华山医院&quot;</span>,</span><br><span class="line">        medicines_name: <span class="string">&quot;青霉素&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">id</span>: <span class="number">2</span>, </span><br><span class="line">        name: <span class="string">&quot;华山医院订单002&quot;</span>, </span><br><span class="line">        create_date: <span class="string">&quot;2018-12-27T14:10:37.208Z&quot;</span>,</span><br><span class="line">        customer_name: <span class="string">&quot;华山医院&quot;</span>,</span><br><span class="line">        medicines_name: <span class="string">&quot;青霉素 | 红霉素 &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><br>其中 ‘id’,’name’,’create_date’ 这些字段的内容获取很简单，order表中就有这些字段，’customer_name’ 和 ‘medicines_name’ 这两个字段的值怎么获取呢？ 因为 订单对应的客户名字 和 药品的名字 都不在 Order 表中啊。<br>Order 这个Model 中 有 ‘customer’ 字段 ， 它外键关联了 Customer 表中的一个 记录，这个记录里面 的 name字段 就是我们要取的字段。<br>取 外键关联的表记录的字段值，在Django中很简单，可以直接通过 外键字段 后面加 两个下划线 加 关联字段名的方式 来获取。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;customer__name&#x27;</span>,</span><br><span class="line">                <span class="comment"># 两个下划线，表示取medicines 关联的表中的name字段的值</span></span><br><span class="line">                <span class="comment"># 如果有多个，就会产生多条记录</span></span><br><span class="line">                <span class="string">&#x27;medicines__name&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure><br>首先，第一个问题， 接口文档需要的名字是 ‘customer_name’ 和 ‘medicines_name’。 里面只有一个下划线， 而我们这里却产生了 两个下划线。<br>使用 annotate 方法将获取的字段值进行重命名，像下面这样<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .annotate(</span><br><span class="line">                customer_name=F(<span class="string">&#x27;customer__name&#x27;</span>),</span><br><span class="line">                medicines_name=F(<span class="string">&#x27;medicines__name&#x27;</span>)</span><br><span class="line">            )\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;customer_name&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;medicines_name&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist&#125;)</span><br></pre></td></tr></table></figure><br>第二个问题，如果一个订单里面有多个药品，就会产生多条记录， 这不是我们要的。<br>根据接口，一个订单里面的多个药品， 用 竖线 隔开。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listorder</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">    qs = Order.objects\</span><br><span class="line">            .annotate(</span><br><span class="line">                customer_name=F(<span class="string">&#x27;customer__name&#x27;</span>),</span><br><span class="line">                medicines_name=F(<span class="string">&#x27;medicines__name&#x27;</span>)</span><br><span class="line">            )\</span><br><span class="line">            .values(</span><br><span class="line">                <span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;create_date&#x27;</span>,<span class="string">&#x27;customer_name&#x27;</span>,<span class="string">&#x27;medicines_name&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">    retlist = <span class="built_in">list</span>(qs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可能有 ID相同，药品不同的订单记录， 需要合并</span></span><br><span class="line">    newlist = []</span><br><span class="line">    id2order = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> one <span class="keyword">in</span> retlist:</span><br><span class="line">        orderid = one[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> orderid <span class="keyword">not</span> <span class="keyword">in</span> id2order:</span><br><span class="line">            newlist.append(one)</span><br><span class="line">            id2order[orderid] = one</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            id2order[orderid][<span class="string">&#x27;medicines_name&#x27;</span>] += <span class="string">&#x27; | &#x27;</span> + one[<span class="string">&#x27;medicines_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: newlist&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="分页与过滤"><a href="#分页与过滤" class="headerlink" title="分页与过滤"></a>分页与过滤</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加对分页的支持</span></span><br><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, EmptyPage</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listmedicine</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">        qs = Medicine.objects.values()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要获取的第几页</span></span><br><span class="line">        pagenum = request.params[<span class="string">&#x27;pagenum&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每页要显示多少条记录</span></span><br><span class="line">        pagesize = request.params[<span class="string">&#x27;pagesize&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回一个 QuerySet 对象 ，包含所有的表记录</span></span><br><span class="line">        qs = Medicine.objects.values()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用分页对象，设定每页多少条记录</span></span><br><span class="line">        pgnt = Paginator(qs, pagesize)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从数据库中读取数据，指定读取其中第几页</span></span><br><span class="line">        page = pgnt.page(pagenum)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将 QuerySet 对象 转化为 list 类型</span></span><br><span class="line">        retlist = <span class="built_in">list</span>(page)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># total指定了 一共有多少数据</span></span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: retlist,<span class="string">&#x27;total&#x27;</span>: pgnt.count&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;retlist&#x27;</span>: [], <span class="string">&#x27;total&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">2</span>,  <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;未知错误\n<span class="subst">&#123;traceback.format_exc()&#125;</span>&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><h3 id="多条件-且关系"><a href="#多条件-且关系" class="headerlink" title="多条件 且关系"></a>多条件 且关系</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qs.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;乳酸&#x27;</span>)</span><br><span class="line">转化为的sql条件</span><br><span class="line">WHERE name LIKE <span class="string">&#x27;%乳酸%&#x27;</span></span><br><span class="line"></span><br><span class="line">qs.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;乳酸&#x27;</span>,name__contains=<span class="string">&#x27;注射液&#x27;</span>)</span><br><span class="line">qs.<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;乳酸&#x27;</span>).<span class="built_in">filter</span>(name__contains=<span class="string">&#x27;注射液&#x27;</span>)</span><br><span class="line">WHERE name LIKE <span class="string">&#x27;%乳酸%&#x27;</span> AND name LIKE <span class="string">&#x27;%注射液%&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="多条件-或关系"><a href="#多条件-或关系" class="headerlink" title="多条件 或关系"></a>多条件 或关系</h3><p>可以使用 Django 里面提供 的 Q 对象 。<br>Q 对象 的初始化参数里面 携带 和 filter 语法一致的 条件，比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line">qs.<span class="built_in">filter</span>(Q(name__contains=<span class="string">&#x27;乳酸&#x27;</span>))</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qs.<span class="built_in">filter</span>( Q(name__contains=<span class="string">&#x27;乳酸&#x27;</span>) | Q(name__contains=<span class="string">&#x27;注射液&#x27;</span>))</span><br><span class="line"></span><br><span class="line">WHERE name LIKE <span class="string">&#x27;%乳酸%&#x27;</span> OR name LIKE <span class="string">&#x27;%注射液%&#x27;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qs.<span class="built_in">filter</span>( Q(name__contains=<span class="string">&#x27;乳酸&#x27;</span>) &amp; Q(name__contains=<span class="string">&#x27;注射液&#x27;</span>))</span><br><span class="line">WHERE name LIKE <span class="string">&#x27;%乳酸%&#x27;</span> AND name LIKE <span class="string">&#x27;%注射液%&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="自定义用户表"><a href="#自定义用户表" class="headerlink" title="自定义用户表"></a>自定义用户表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过 命令 python  manage.py createsuperuser 来创建超级管理员</span></span><br><span class="line"><span class="comment"># 就是在这User表中添加记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">AbstractUser</span>):</span><br><span class="line">    <span class="built_in">id</span> = models.BigAutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用户类型  </span></span><br><span class="line">    <span class="comment"># 1： 超管 | 1000： 普通管理员  | 2000：学生  |  3000： 老师 </span></span><br><span class="line">    usertype = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 真实姓名</span></span><br><span class="line">    realname = models.CharField(max_length=<span class="number">30</span>, db_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学号</span></span><br><span class="line">    studentno = models.CharField(</span><br><span class="line">        max_length=<span class="number">10</span>, </span><br><span class="line">        db_index=<span class="literal">True</span>, </span><br><span class="line">        null=<span class="literal">True</span>, blank=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 备注描述</span></span><br><span class="line">    desc = models.CharField(max_length=<span class="number">500</span>, null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    REQUIRED_FIELDS = [<span class="string">&#x27;usertype&#x27;</span>, <span class="string">&#x27;realname&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&quot;by_user&quot;</span></span><br></pre></td></tr></table></figure><p>一种推荐的方式是：通过继承 contrib.auth.models 里面的 AbstractUser 类的方式</p><p>然后，你需要告诉Django，使用这个表作为 系统的 user表。<br> 在 settings.py 中，添加如下设置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH_USER_MODEL = <span class="string">&#x27;myapp.User&#x27;</span></span><br></pre></td></tr></table></figure><br>其中 myapp 改为你的 User 定义 所在的 django app 名称<br>可能你会奇怪，我们为什么不能重新完全的重定义 User 表，一定要继承 contrib.auth.models 里面的 AbstractUser 类呢？<br>那是因为 Django内置的 认证 、权限 、 Session 机制 和 auth 模块深度绑定了，如果你需要使用 这些机制提供的方法，就不能抛弃 auth 里面的 user 表。<br>如果你不打算使用 Django内置的 认证 或者 Session 机制， 完全可以自己定义一张 User表。</p><p>用户表的password<br>Django 的密码不是明文存储的， 有好几种方式。可以使用 Django 库提供的方法 产生 password 字段值（通常是hash处理过）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> make_password,check_password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一条记录</span></span><br><span class="line">user = User.objects.create(</span><br><span class="line">    username  = username,</span><br><span class="line">    <span class="comment"># 使用 make_password 函数 产生password字段</span></span><br><span class="line">    password  = make_password(data[<span class="string">&#x27;password&#x27;</span>]),</span><br><span class="line">    <span class="comment"># 其他字段...)</span></span><br></pre></td></tr></table></figure><br>使用 Django auth 库里面的 authenticate 方法 就包含了 校验用户名、密码的过程，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login, logout</span><br><span class="line"><span class="comment"># 使用 Django auth 库里面的 方法校验用户名、密码</span></span><br><span class="line">user = authenticate(username=userName, password=passWord)</span><br></pre></td></tr></table></figure><p>数据操作移到models中<br>为了实现后端系统的功能合理划分，建议把业务逻辑放在 view 代码中，而把数据底层处理放在 models<br>这样， 处理HTTP请求的 view代码，只需要调用 models中的方法即可。<br>处理 添加用户的view<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adduser</span>(<span class="params">request</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求消息中 获取要添加客户的信息</span></span><br><span class="line">    <span class="comment"># 并且插入到数据库中</span></span><br><span class="line"></span><br><span class="line">    data = request.param_dict[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直接调用 models中的添加 用户 的代码    </span></span><br><span class="line">    ret = User.add(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  JsonResponse(ret)</span><br></pre></td></tr></table></figure><br>models中 真正实现添加功能<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">AbstractUser</span>):</span><br><span class="line">    <span class="built_in">id</span> = models.BigAutoField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    usertype = models.PositiveIntegerField()</span><br><span class="line">    realname = models.CharField(max_length=<span class="number">30</span>, db_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        db_table = <span class="string">&quot;cimp_user&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 直接在Model中用静态方法定义数据操作</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">data,usertype</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            username = data[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">            <span class="keyword">if</span> User.objects.<span class="built_in">filter</span>(username=username).exists():</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">f&#x27;登录名 <span class="subst">&#123;username&#125;</span> 已经存在&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">            user = User.objects.create(</span><br><span class="line">                    username  = username,</span><br><span class="line">                    password  = make_password(data[<span class="string">&#x27;password&#x27;</span>]),</span><br><span class="line">                    usertype  = usertype,</span><br><span class="line">                    realname  = data[<span class="string">&#x27;realname&#x27;</span>],</span><br><span class="line">                    studentno = data[<span class="string">&#x27;studentno&#x27;</span>],</span><br><span class="line">                    desc      = data[<span class="string">&#x27;desc&#x27;</span>]</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">&#x27;ret&#x27;</span>: <span class="number">0</span>,<span class="string">&#x27;id&#x27;</span>: user.<span class="built_in">id</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="函数定义的参数-request"><a href="#函数定义的参数-request" class="headerlink" title="函数定义的参数 request"></a>函数定义的参数 request</h2><p>Django 框架在 url 路由匹配到函数后， 调用函数时，会传入 一个 HttpRequest 对象给参数变量 request，该对象里面 包含了请求的数据信息。<br>HTTP 的 Get 请求url里面的参数（术语叫 querystring 里面的参数）， 可以通过 HttpRequest对象的 GET 属性获取。这是一个类似dict的对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph =  request.GET.get(<span class="string">&#x27;phonenumber&#x27;</span>,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><br>第二个参数传入 None 表示，如果没有 phonenumber 参数在 querystring中 ，就会返回 None。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy</title>
      <link href="/2024/04/13/Numpy/"/>
      <url>/2024/04/13/Numpy/</url>
      
        <content type="html"><![CDATA[<h2 id="1-numpy-基本操作"><a href="#1-numpy-基本操作" class="headerlink" title="1 numpy 基本操作"></a>1 numpy 基本操作</h2><h3 id="1-1-列表转换为矩阵"><a href="#1-1-列表转换为矩阵" class="headerlink" title="1.1 列表转换为矩阵"></a>1.1 列表转换为矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.array()</span></span><br><span class="line">array = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># [1 2 3]</span></span><br><span class="line"></span><br><span class="line">array2 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                   [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br></pre></td></tr></table></figure><h3 id="1-2-维度"><a href="#1-2-维度" class="headerlink" title="1.2 维度"></a>1.2 维度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># array.ndim,ndim是矩阵属性而不是方法</span></span><br><span class="line"><span class="built_in">print</span>(array.ndim)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(array2.ndim)</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h3 id="1-3-行数和列数"><a href="#1-3-行数和列数" class="headerlink" title="1.3 行数和列数"></a>1.3 行数和列数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># array.shape,shape是矩阵的属性而不是方法</span></span><br><span class="line"><span class="built_in">print</span>(array.shape)</span><br><span class="line"><span class="comment"># (3,) 一维数组只包含维度的长度</span></span><br><span class="line"><span class="built_in">print</span>(array2.shape)</span><br><span class="line"><span class="comment"># (2, 3) 二维，两行三列</span></span><br></pre></td></tr></table></figure><h3 id="1-4-元素个数"><a href="#1-4-元素个数" class="headerlink" title="1.4 元素个数"></a>1.4 元素个数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># array.size,size是矩阵的属性而不是方法</span></span><br><span class="line"><span class="built_in">print</span>(array.size)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="built_in">print</span>(array2.size)</span><br><span class="line"><span class="comment"># 6</span></span><br></pre></td></tr></table></figure><h2 id="2-numpy-创建array"><a href="#2-numpy-创建array" class="headerlink" title="2 numpy 创建array"></a>2 numpy 创建array</h2><h3 id="2-1-一维array的创建"><a href="#2-1-一维array的创建" class="headerlink" title="2.1 一维array的创建"></a>2.1 一维array的创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># [2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(array.dtype)</span><br><span class="line"><span class="comment"># int32</span></span><br></pre></td></tr></table></figure><h3 id="2-2-多维array创建"><a href="#2-2-多维array创建" class="headerlink" title="2.2 多维array创建"></a>2.2 多维array创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array2 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(array2)</span><br><span class="line"><span class="comment"># [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br></pre></td></tr></table></figure><h3 id="2-3-创建全零数组"><a href="#2-3-创建全零数组" class="headerlink" title="2.3 创建全零数组"></a>2.3 创建全零数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.zeros(),</span></span><br><span class="line">array0 = np.zeros((<span class="number">3</span>,<span class="number">4</span>),dtype=np.int32)</span><br><span class="line"><span class="built_in">print</span>(array0)</span><br><span class="line"><span class="comment"># [[0. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0. 0. 0.]]</span></span><br></pre></td></tr></table></figure><h3 id="2-4-创建全1数据"><a href="#2-4-创建全1数据" class="headerlink" title="2.4 创建全1数据"></a>2.4 创建全1数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.ones()</span></span><br><span class="line">array1 = np.ones((<span class="number">3</span>,<span class="number">4</span>),dtype=np.int32)</span><br><span class="line"><span class="built_in">print</span>(array1)</span><br><span class="line"><span class="comment"># [[1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1. 1.]]</span></span><br></pre></td></tr></table></figure><h3 id="2-5-创建全空数组"><a href="#2-5-创建全空数组" class="headerlink" title="2.5 创建全空数组"></a>2.5 创建全空数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其实每个值都是接近于零的数,np.empty()</span></span><br><span class="line">array = np.empty((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># [[6.23042070e-307 1.89146896e-307 1.37961302e-306 6.23053614e-307]</span></span><br><span class="line"><span class="comment">#  [6.23053954e-307 9.34609790e-307 8.45593934e-307 9.34600963e-307]</span></span><br><span class="line"><span class="comment">#  [1.86921143e-306 6.23061763e-307 8.90104239e-307 3.52937523e-317]]</span></span><br></pre></td></tr></table></figure><h3 id="2-6-创建连续数组"><a href="#2-6-创建连续数组" class="headerlink" title="2.6 创建连续数组"></a>2.6 创建连续数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10-20数组，步长为2,np.arange(begin,end+1,step)</span></span><br><span class="line">array = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># [0 1 2 3]</span></span><br><span class="line">array = np.arange(<span class="number">10</span>,<span class="number">21</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"><span class="comment"># [10 12 14 16 18 20]</span></span><br></pre></td></tr></table></figure><h3 id="2-7-数组的reshape方法"><a href="#2-7-数组的reshape方法" class="headerlink" title="2.7 数组的reshape方法"></a>2.7 数组的reshape方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = array.reshape((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># [[10 12 14]</span></span><br><span class="line"><span class="comment">#  [16 18 20]]</span></span><br></pre></td></tr></table></figure><h3 id="2-8-创建连续型数据"><a href="#2-8-创建连续型数据" class="headerlink" title="2.8 创建连续型数据"></a>2.8 创建连续型数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从10开始，20结束，分割成10个数据,np.linspace()</span></span><br><span class="line">a = np.linspace(<span class="number">10</span>,<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [10.         11.11111111 12.22222222 13.33333333 14.44444444 15.55555556</span></span><br><span class="line"><span class="comment">#  16.66666667 17.77777778 18.88888889 20.        ]</span></span><br></pre></td></tr></table></figure><h3 id="2-9-生成随机性数据"><a href="#2-9-生成随机性数据" class="headerlink" title="2.9 生成随机性数据"></a>2.9 生成随机性数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.random.random()</span></span><br><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [[0.88305579 0.1303509  0.62293829 0.30633028]</span></span><br><span class="line"><span class="comment">#  [0.3118289  0.20432204 0.46446014 0.22802355]]</span></span><br></pre></td></tr></table></figure><h2 id="3-numpy-基本运算"><a href="#3-numpy-基本运算" class="headerlink" title="3 numpy 基本运算"></a>3 numpy 基本运算</h2><h3 id="3-1一维矩阵运算"><a href="#3-1一维矩阵运算" class="headerlink" title="3.1一维矩阵运算"></a>3.1一维矩阵运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="comment"># [10 20 30 40] [0 1 2 3]</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="comment"># [10 21 32 43]</span></span><br><span class="line"><span class="built_in">print</span>(a*b)</span><br><span class="line"><span class="comment"># [  0  20  60 120]</span></span><br><span class="line"><span class="built_in">print</span>(a-b)</span><br><span class="line"><span class="comment"># [10 19 28 37]</span></span><br><span class="line">c = b**<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># [0 1 4 9]</span></span><br><span class="line"><span class="built_in">print</span>(np.sin(b))</span><br><span class="line"><span class="comment"># [0.         0.84147098 0.90929743 0.14112001]</span></span><br><span class="line"><span class="built_in">print</span>(b&lt;<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [ True  True False False]</span></span><br><span class="line"><span class="built_in">print</span>(a==b)</span><br><span class="line"><span class="comment"># [False False False False]</span></span><br></pre></td></tr></table></figure><h3 id="3-2-多维矩阵运算"><a href="#3-2-多维矩阵运算" class="headerlink" title="3.2 多维矩阵运算"></a>3.2 多维矩阵运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># [[1 1]</span></span><br><span class="line"><span class="comment">#  [0 1]]</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># [[0 1]</span></span><br><span class="line"><span class="comment">#  [2 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多维矩阵乘法 np.dot()</span></span><br><span class="line">c= np.dot(a,b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># [[2 4]</span></span><br><span class="line"><span class="comment">#  [2 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求列表中min和max,sum，使用min()和max()方法,sum()方法,或者np.min(),np.max()，np.sum()</span></span><br><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>())</span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>())</span><br><span class="line"><span class="comment"># 0.25716551969504853</span></span><br><span class="line"><span class="comment"># 0.6615216818233298</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行或列进行操作，当axis = 0，按列进行操作,当axis =1 ,对行进行操作</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">min</span>(a,axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [0.00665876 0.28804975 0.35533222 0.30061535]</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">max</span>(a,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [0.914875   0.51276219]</span></span><br></pre></td></tr></table></figure><h3 id="3-3-基本计算"><a href="#3-3-基本计算" class="headerlink" title="3.3 基本计算"></a>3.3 基本计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[ 2  3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 6  7  8  9]</span></span><br><span class="line"><span class="comment">#  [10 11 12 13]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小与最大元素索引,np.argmax(),np.argmin()</span></span><br><span class="line"><span class="built_in">print</span>(np.argmax(A),np.argmin(A))</span><br><span class="line"><span class="comment"># 11 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求矩阵的均值,np.mean(),np.average(),A.mean()</span></span><br><span class="line"><span class="built_in">print</span>(np.mean(A))</span><br><span class="line"><span class="built_in">print</span>(np.average(A))</span><br><span class="line"><span class="comment"># 7.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中位数,np.median(),有两个求均值</span></span><br><span class="line"><span class="built_in">print</span>(np.median(A))</span><br><span class="line"><span class="comment"># 7.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 累加,np.cumsum(A)</span></span><br><span class="line"><span class="built_in">print</span>(np.cumsum(A))</span><br><span class="line"><span class="comment"># [ 2  5  9 14 20 27 35 44 54 65 77 90]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 累差运算,np.diff()</span></span><br><span class="line">B = np.array([[<span class="number">3</span>,<span class="number">5</span>,<span class="number">9</span>],[<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.diff(B))</span><br><span class="line"><span class="comment"># [[2 4]</span></span><br><span class="line"><span class="comment">#  [4 2]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数组中非零元素的索引,np.nonzero()，输出是每个维度上非零元素的索引</span></span><br><span class="line">C = np.array([[<span class="number">0</span>,<span class="number">5</span>,<span class="number">9</span>],</span><br><span class="line">              [<span class="number">4</span>,<span class="number">0</span>,<span class="number">10</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.nonzero(C))</span><br><span class="line"><span class="comment"># (array([0, 0, 1, 1], dtype=int64), array([1, 2, 0, 2], dtype=int64))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵排序，np.sort()</span></span><br><span class="line">A  = np.arange(<span class="number">14</span>,<span class="number">2</span>,-<span class="number">1</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[14 13 12 11]</span></span><br><span class="line"><span class="comment">#  [10  9  8  7]</span></span><br><span class="line"><span class="comment">#  [ 6  5  4  3]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sort(A))</span><br><span class="line"><span class="comment"># [[11 12 13 14]</span></span><br><span class="line"><span class="comment">#  [ 7  8  9 10]</span></span><br><span class="line"><span class="comment">#  [ 3  4  5  6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵转置,np.transpose(),A.T</span></span><br><span class="line"><span class="built_in">print</span>(np.transpose(A))</span><br><span class="line"><span class="built_in">print</span>(A.T)</span><br><span class="line"><span class="comment"># [[14 10  6]</span></span><br><span class="line"><span class="comment">#  [13  9  5]</span></span><br><span class="line"><span class="comment">#  [12  8  4]</span></span><br><span class="line"><span class="comment">#  [11  7  3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将矩阵中值限定在一定的范围内，np.clip(array,min,max)</span></span><br><span class="line"><span class="built_in">print</span>(np.clip(A,<span class="number">5</span>,<span class="number">9</span>))</span><br><span class="line"><span class="comment"># [[9 9 9 9]</span></span><br><span class="line"><span class="comment">#  [9 9 8 7]</span></span><br><span class="line"><span class="comment">#  [6 5 5 5]]</span></span><br></pre></td></tr></table></figure><h2 id="4-numpy-索引与切片"><a href="#4-numpy-索引与切片" class="headerlink" title="4 numpy 索引与切片"></a>4 numpy 索引与切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [ 3  4  5  6  7  8  9 10 11 12 13 14]</span></span><br><span class="line"><span class="built_in">print</span>(A[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line">B = A.reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="comment"># [[ 3  4  5  6]</span></span><br><span class="line"><span class="comment">#  [ 7  8  9 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14]]</span></span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment"># [11 12 13 14]</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># list切片操作</span></span><br><span class="line"><span class="built_in">print</span>(B[<span class="number">1</span>,<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [8 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印矩阵的每一行</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> B:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"><span class="comment"># [3 4 5 6]</span></span><br><span class="line"><span class="comment"># [ 7  8  9 10]</span></span><br><span class="line"><span class="comment"># [11 12 13 14]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印矩阵的每个列</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> np.transpose(B):</span><br><span class="line">    <span class="built_in">print</span>(col)</span><br><span class="line"><span class="comment"># [ 3  7 11]</span></span><br><span class="line"><span class="comment"># [ 4  8 12]</span></span><br><span class="line"><span class="comment"># [ 5  9 13]</span></span><br><span class="line"><span class="comment"># [ 6 10 14]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#多维转一维</span></span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(A.flatten())</span><br><span class="line"><span class="comment"># [ 3  4  5  6  7  8  9 10 11 12 13 14]</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"><span class="comment"># 11</span></span><br><span class="line"><span class="comment"># 12</span></span><br><span class="line"><span class="comment"># 13</span></span><br><span class="line"><span class="comment"># 14</span></span><br></pre></td></tr></table></figure><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405281047541.png" alt=""></p><h2 id="5-Numpy-array合并"><a href="#5-Numpy-array合并" class="headerlink" title="5 Numpy array合并"></a>5 Numpy array合并</h2><h3 id="5-1-数组合并"><a href="#5-1-数组合并" class="headerlink" title="5.1 数组合并"></a>5.1 数组合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vertical stack 上下合并，对括号的两个整体操作</span></span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">C = np.vstack((A,B))</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="comment"># [[1 1 1]</span></span><br><span class="line"><span class="comment">#  [2 2 2]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A.shape,B.shape,C.shape)</span><br><span class="line"><span class="comment"># (3,) (3,) (2, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># horizontal stack 左右合并</span></span><br><span class="line">D = np.hstack((A,B))</span><br><span class="line"><span class="built_in">print</span>(D)</span><br><span class="line"><span class="comment"># [1 1 1 2 2 2]</span></span><br><span class="line"><span class="built_in">print</span>(A.shape,B.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,) (3,) (6,)</span></span><br></pre></td></tr></table></figure><h3 id="5-2-数组转置为矩阵"><a href="#5-2-数组转置为矩阵" class="headerlink" title="5.2 数组转置为矩阵"></a>5.2 数组转置为矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.newaxis,插入新维度,且这一维长度是1</span></span><br><span class="line"><span class="comment"># 将A,[1 1 1]转化为[[1 1 1]]</span></span><br><span class="line"><span class="built_in">print</span>(A[np.newaxis,:])</span><br><span class="line"><span class="built_in">print</span>(A[np.newaxis,:].shape)</span><br><span class="line"><span class="comment"># [[1 1 1]]</span></span><br><span class="line"><span class="comment"># (1, 3)</span></span><br><span class="line"><span class="comment"># 将A,[1 1 1]转化为[[1]</span></span><br><span class="line"><span class="comment">#                   [1]</span></span><br><span class="line"><span class="comment">#                   [1]]</span></span><br></pre></td></tr></table></figure><h3 id="5-3-多个矩阵合并"><a href="#5-3-多个矩阵合并" class="headerlink" title="5.3 多个矩阵合并"></a>5.3 多个矩阵合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.concatenate(),axis = 0,对列进行操作，纵向合并</span></span><br><span class="line">A = A[:,np.newaxis]</span><br><span class="line">B = B[:,np.newaxis]</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [1]]</span></span><br><span class="line"><span class="comment"># [[2]</span></span><br><span class="line"><span class="comment">#  [2]</span></span><br><span class="line"><span class="comment">#  [2]]</span></span><br><span class="line">C = np.concatenate((A,B),axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [1]</span></span><br><span class="line"><span class="comment">#  [2]</span></span><br><span class="line"><span class="comment">#  [2]</span></span><br><span class="line"><span class="comment">#  [2]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.concatenate.,axis = 1 对行进行操作，横向合并</span></span><br><span class="line">C = np.concatenate((A,B),axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [1 2]</span></span><br><span class="line"><span class="comment">#  [1 2]]</span></span><br></pre></td></tr></table></figure><h3 id="5-4合并例子2"><a href="#5-4合并例子2" class="headerlink" title="5.4合并例子2"></a>5.4合并例子2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">b = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># [[0 1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6 7]]</span></span><br><span class="line"><span class="comment"># [[0 1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6 7]]</span></span><br><span class="line">c = np.concatenate((a,b),axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># [[0 1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6 7]</span></span><br><span class="line"><span class="comment">#  [0 1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6 7]]</span></span><br><span class="line">c = np.concatenate((a,b),axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment"># [[0 1 2 3 0 1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6 7 4 5 6 7]]</span></span><br></pre></td></tr></table></figure><h2 id="6-Numpy-array分割"><a href="#6-Numpy-array分割" class="headerlink" title="6 Numpy array分割"></a>6 Numpy array分割</h2><h3 id="6-1-构造3行4列矩阵"><a href="#6-1-构造3行4列矩阵" class="headerlink" title="6.1 构造3行4列矩阵"></a>6.1 构造3行4列矩阵</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[ 0  1  2  3]</span></span><br><span class="line"><span class="comment">#  [ 4  5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 8  9 10 11]]</span></span><br></pre></td></tr></table></figure><h3 id="6-2-等量分割"><a href="#6-2-等量分割" class="headerlink" title="6.2 等量分割"></a>6.2 等量分割</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.split(A,n),对数组A进行操作，分成n部分，默认axis=0</span></span><br><span class="line"><span class="built_in">print</span>(np.split(A,<span class="number">2</span>,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [array([[0, 1],</span></span><br><span class="line"><span class="comment">#        [4, 5],</span></span><br><span class="line"><span class="comment">#        [8, 9]]),</span></span><br><span class="line"><span class="comment"># array([[ 2,  3],</span></span><br><span class="line"><span class="comment">#        [ 6,  7],</span></span><br><span class="line"><span class="comment">#        [10, 11]])]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.split(A,<span class="number">3</span>,axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br></pre></td></tr></table></figure><h3 id="6-3-不等量分割"><a href="#6-3-不等量分割" class="headerlink" title="6.3 不等量分割"></a>6.3 不等量分割</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># array_split,</span></span><br><span class="line"><span class="built_in">print</span>(np.array_split(A,<span class="number">3</span>,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 对行进行操作，4份分成3份为2,1,1</span></span><br><span class="line"><span class="comment"># [array([[0, 1],</span></span><br><span class="line"><span class="comment">#        [4, 5],</span></span><br><span class="line"><span class="comment">#        [8, 9]]), array([[ 2],</span></span><br><span class="line"><span class="comment">#        [ 6],</span></span><br><span class="line"><span class="comment">#        [10]]), array([[ 3],</span></span><br><span class="line"><span class="comment">#        [ 7],</span></span><br><span class="line"><span class="comment">#        [11]])]</span></span><br></pre></td></tr></table></figure><h3 id="6-4-其他分割方式"><a href="#6-4-其他分割方式" class="headerlink" title="6.4 其他分割方式"></a>6.4 其他分割方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 横向分割np.vsplit(),</span></span><br><span class="line"><span class="built_in">print</span>(np.vsplit(A,<span class="number">3</span>)) <span class="comment">#相当于np.split(A,3,axis = 0)</span></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"><span class="comment"># 纵向分割,np.hsplit()</span></span><br><span class="line"><span class="built_in">print</span>(np.hsplit(A,<span class="number">2</span>)) <span class="comment">#相当于np.split(A,2,axis = 1)</span></span><br><span class="line"><span class="comment"># [array([[0, 1],</span></span><br><span class="line"><span class="comment">#        [4, 5],</span></span><br><span class="line"><span class="comment">#        [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="comment">#        [ 6,  7],</span></span><br><span class="line"><span class="comment">#        [10, 11]])]</span></span><br></pre></td></tr></table></figure><h2 id="7-Numpy-copy与"><a href="#7-Numpy-copy与" class="headerlink" title="7 Numpy copy与="></a>7 Numpy copy与=</h2><h3 id="7-1-赋值方式会带有关联性"><a href="#7-1-赋值方式会带有关联性" class="headerlink" title="7.1 = 赋值方式会带有关联性"></a>7.1 = 赋值方式会带有关联性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = b</span><br><span class="line"><span class="built_in">print</span>(a,b,c,d)</span><br><span class="line"><span class="comment"># [0 1 2 3] [0 1 2 3] [0 1 2 3] [0 1 2 3]</span></span><br><span class="line">a[<span class="number">0</span>]= <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c,d)</span><br><span class="line"><span class="comment"># [11  1  2  3] [11  1  2  3] [11  1  2  3] [11  1  2  3]</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a,c <span class="keyword">is</span> a,d <span class="keyword">is</span> a)</span><br><span class="line"><span class="comment"># True True True</span></span><br><span class="line">b[<span class="number">1</span>:<span class="number">3</span>]=[<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="comment"># [11 22 33  3] [11 22 33  3]</span></span><br></pre></td></tr></table></figure><h3 id="7-2-copy-赋值方式没有关联性"><a href="#7-2-copy-赋值方式没有关联性" class="headerlink" title="7.2 copy()赋值方式没有关联性"></a>7.2 copy()赋值方式没有关联性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a =np.arange(<span class="number">4</span>)</span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="comment"># [0 1 2 3] [0 1 2 3]</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="comment"># [11  1  2  3] [0 1 2 3]</span></span><br></pre></td></tr></table></figure><h2 id="8-广播机制"><a href="#8-广播机制" class="headerlink" title="8 广播机制"></a>8 广播机制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># numpy数组的大小一致时，正常运算，当两者不一样的时候，就会自动触发广播机制</span></span><br><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">              [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">              [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="comment"># [[ 0  1  2]</span></span><br><span class="line"><span class="comment">#  [10 11 12]</span></span><br><span class="line"><span class="comment">#  [20 21 22]</span></span><br><span class="line"><span class="comment">#  [30 31 32]]</span></span><br></pre></td></tr></table></figure><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405281047542.png" alt=""><br>9 常用函数<br>9.1 np.bincount()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.bincount(a),返回一个数组，其长度等于a中元素最大值加1，每个元素值则是它当前索引值在a中出现的次数</span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.bincount(x))</span><br><span class="line"><span class="comment"># [1 2 1 2 1]</span></span><br><span class="line"><span class="comment"># 0出现1次，1出现2次，2出现1次，3出现2次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.bincount()的weights参数</span></span><br><span class="line">w = np.array([<span class="number">0.3</span>,<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">0.6</span>,<span class="number">0.1</span>,-<span class="number">0.9</span>,<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(np.bincount(x,weights=w))</span><br><span class="line"><span class="comment"># [ 0.1 -0.6  0.5  1.3  1. ]</span></span><br><span class="line"><span class="comment"># x[1,2,3,3,0,1,4]</span></span><br><span class="line"><span class="comment"># w[0.3,0.5,0.7,0.6,0.1,-0.9,1]</span></span><br><span class="line"><span class="comment"># 0出现x[4],w[4]=0.1</span></span><br><span class="line"><span class="comment"># 1出现在x[0],x[5],w[0]+w[5]=0.3+-0.9=-0.6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.bincount()的minlength参数,当所给的bin数量多于实际从x中得到的bin数量后，后面没有访问到的设置为0即可。</span></span><br><span class="line"><span class="built_in">print</span>(np.bincount(x,weights=w,minlength=<span class="number">7</span>))</span><br><span class="line"><span class="comment"># [ 0.1 -0.6  0.5  1.3  1.   0.   0. ]</span></span><br></pre></td></tr></table></figure></p><p>9.2 np.argmax()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回沿轴axis最大值的索引,若有有重复元素，返回第一个最大值索引</span></span><br><span class="line"><span class="comment"># 没指定axis=1,axis=0时，索引递增</span></span><br><span class="line">x = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],</span><br><span class="line">     [<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="built_in">print</span>(np.argmax(x))</span><br><span class="line"><span class="comment"># axis = 1，按行进行操作</span></span><br><span class="line"><span class="built_in">print</span>(np.argmax(x,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [1 0]</span></span><br><span class="line"><span class="comment"># axis = 0,按列进行操作</span></span><br><span class="line"><span class="built_in">print</span>(np.argmax(x,axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [1 1 0]</span></span><br></pre></td></tr></table></figure></p><p>9.3 合并实例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(np.argmax(np.bincount(x)))</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure><br>9.4 求取精度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.round(),decimals=0 取指定位置的精度,四舍五入</span></span><br><span class="line">A = [-<span class="number">0.6</span>,<span class="number">1.2798</span>,<span class="number">2.357</span>,<span class="number">9.67</span>,<span class="number">13</span>]</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(A,decimals=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [-1.  1.  2. 10. 13.]</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">round</span>(A,decimals=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [-0.6  1.3  2.4  9.7 13. ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.diff()计算沿指定轴第N维的离散插值</span></span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">16</span>).reshape((<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment"># [[ 1  2  3  4  5]</span></span><br><span class="line"><span class="comment">#  [ 6  7  8  9 10]</span></span><br><span class="line"><span class="comment">#  [11 12 13 14 15]]</span></span><br><span class="line"><span class="built_in">print</span>(np.diff(x,axis=<span class="number">1</span>))</span><br><span class="line"><span class="comment"># [[1 1 1 1]</span></span><br><span class="line"><span class="comment">#  [1 1 1 1]</span></span><br><span class="line"><span class="comment">#  [1 1 1 1]]</span></span><br><span class="line"><span class="built_in">print</span>(np.diff(x,axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [[5 5 5 5 5]</span></span><br><span class="line"><span class="comment">#  [5 5 5 5 5]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.floor(),向下取整，负数求整，向左</span></span><br><span class="line"><span class="built_in">print</span>(np.floor(A))</span><br><span class="line"><span class="comment"># [-1.  1.  2.  9. 13.]</span></span><br><span class="line"><span class="comment"># np.ceil() ，向上取整</span></span><br><span class="line"><span class="built_in">print</span>(np.ceil(A))</span><br><span class="line"><span class="comment"># [-0.  2.  3. 10. 13.]</span></span><br><span class="line"><span class="comment"># np.where(A&gt;a,b,c)对于矩阵中&gt;a的数为b,&lt;=a,为c</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">2</span>, -<span class="number">2</span>],</span><br><span class="line">     [-<span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.where(x&gt;<span class="number">0</span>,x,<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [[1 0]</span></span><br><span class="line"><span class="comment">#  [2 0]</span></span><br><span class="line"><span class="comment">#  [0 1]]</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy练习50</title>
      <link href="/2024/04/13/numpy%20%E7%BB%83%E4%B9%A050/"/>
      <url>/2024/04/13/numpy%20%E7%BB%83%E4%B9%A050/</url>
      
        <content type="html"><![CDATA[<p>1 导入numpy<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><br>2 打印 numpy 版本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.__version__)</span><br><span class="line"><span class="comment"># 1.26.0</span></span><br></pre></td></tr></table></figure><br>3 创建一个大小为 10 的空向量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A =  np.zeros(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]</span></span><br></pre></td></tr></table></figure><br>4 如何查找任何数组的内存大小<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(A.size * A.itemsize)</span><br><span class="line"><span class="comment"># 80</span></span><br></pre></td></tr></table></figure><br>5 如何从命令行获取 numpy add 函数的文档？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print(np.info(np.add))</span></span><br></pre></td></tr></table></figure><br>6 创建一个大小为 10 的空向量，但第五个值为 1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.zeros(<span class="number">10</span>)</span><br><span class="line">A[<span class="number">4</span>]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]</span></span><br></pre></td></tr></table></figure><br>7 创建一个数值范围为 10 到 49 的向量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33</span></span><br><span class="line"><span class="comment">#  34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49]</span></span><br></pre></td></tr></table></figure></p><ol><li>倒转向量（第一个元素变为最后一个元素）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(A[::-<span class="number">1</span>])</span><br><span class="line"><span class="comment"># [49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26</span></span><br><span class="line"><span class="comment">#  25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10]</span></span><br></pre></td></tr></table></figure></li></ol><p>9 创建一个 3x3 矩阵，数值范围为 0 至 8<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">0</span>,<span class="number">9</span>).reshape((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0 1 2]</span></span><br><span class="line"><span class="comment">#  [3 4 5]</span></span><br><span class="line"><span class="comment">#  [6 7 8]]</span></span><br></pre></td></tr></table></figure></p><p>10 从[1,2,0,0,4,0]中找出非零元素的索引<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(np.nonzero([<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>]))</span><br><span class="line"><span class="comment"># (array([0, 1, 4], dtype=int64),)</span></span><br></pre></td></tr></table></figure></p><p>11  创建 3x3单位矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.eye(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[1. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0. 1.]]</span></span><br></pre></td></tr></table></figure></p><p>12 用随机值创建一个 3x3x3 数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.random((<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[[0.51701641 0.70356544 0.90246089]</span></span><br><span class="line"><span class="comment">#   [0.93648379 0.99090459 0.28404539]</span></span><br><span class="line"><span class="comment">#   [0.56477766 0.45614644 0.43485708]]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  [[0.30986945 0.61224929 0.15321247]</span></span><br><span class="line"><span class="comment">#   [0.08243742 0.52434454 0.16549235]</span></span><br><span class="line"><span class="comment">#   [0.43315058 0.19596346 0.8242506 ]]</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  [[0.14449149 0.42690064 0.36303689]</span></span><br><span class="line"><span class="comment">#   [0.6005045  0.98059647 0.26418785]</span></span><br><span class="line"><span class="comment">#   [0.33624702 0.3691921  0.96844422]]]</span></span><br></pre></td></tr></table></figure></p><p>13 用随机值创建一个 10x10 数组，并找出最小值和最大值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.random((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">max</span>())</span><br><span class="line"><span class="built_in">print</span>(A.<span class="built_in">min</span>())</span><br><span class="line"><span class="comment"># 0.9907704759849023</span></span><br><span class="line"><span class="comment"># 0.015057056338748653</span></span><br></pre></td></tr></table></figure><br> 14 创建一个大小为30的随机向量，求其平均值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.random(<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(np.mean(A))</span><br><span class="line"><span class="comment"># 0.6084927498936027</span></span><br></pre></td></tr></table></figure></p><p>15 创建一个二维数组，边框为 1，内部为 0<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones((<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">A[<span class="number">1</span>:-<span class="number">1</span>,<span class="number">1</span>:-<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 0. 0. 0. 0. 0. 0. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]</span></span><br></pre></td></tr></table></figure></p><p>16 如何在现有数组周围添加边框（填充 0）？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">A = np.pad(A,pad_width=<span class="number">1</span>,mode=<span class="string">&#x27;constant&#x27;</span>,constant_values=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0. 0. 0. 0. 0. 0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 1. 1. 1. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 1. 1. 1. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 1. 1. 1. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 1. 1. 1. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 1. 1. 1. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0. 0. 0. 0. 0. 0.]]</span></span><br></pre></td></tr></table></figure><br>17 下面表达式的结果是什么？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0</span> * np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan == np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.inf &gt; np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan - np.nan)</span><br><span class="line"><span class="built_in">print</span>(np.nan <span class="keyword">in</span> <span class="built_in">set</span>([np.nan]))</span><br><span class="line"><span class="built_in">print</span>(<span class="number">0.3</span> == <span class="number">3</span> * <span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># nan</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># nan</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure></p><p>18 创建一个 5x5 矩阵，数值 1、2、3、4 刚好位于对角线下方<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.diag(v,k),v是二维数组，返回k位置的对角线，v是一维数组，返回一个v作为k位置对角线的二维数组，</span></span><br><span class="line"><span class="comment"># k默认为0，对角线位置，大于零位于对角线上面，小于零则在下面</span></span><br><span class="line">A = np.diag(<span class="number">1</span>+np.arange(<span class="number">4</span>),k=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0 0 0 0 0]</span></span><br><span class="line"><span class="comment">#  [1 0 0 0 0]</span></span><br><span class="line"><span class="comment">#  [0 2 0 0 0]</span></span><br><span class="line"><span class="comment">#  [0 0 3 0 0]</span></span><br><span class="line"><span class="comment">#  [0 0 0 4 0]]</span></span><br></pre></td></tr></table></figure></p><p>19 创建一个 8x8 矩阵并填充棋盘格图案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = np.zeros((<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">A[<span class="number">1</span>::<span class="number">2</span>,::<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line">A[::<span class="number">2</span>,<span class="number">1</span>::<span class="number">2</span>]=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0. 1. 0. 1. 0. 1. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 1. 0. 1. 0. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 0. 1. 0. 1. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 1. 0. 1. 0. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 0. 1. 0. 1. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 1. 0. 1. 0. 1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 0. 1. 0. 1. 0. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 0. 1. 0. 1. 0. 1. 0.]]</span></span><br></pre></td></tr></table></figure></p><p>20 考虑一个 (6,7,8) 形数组，第 100 个元素的索引 (x,y,z) 是多少？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.unravel_index()：求出数组某元素（或某组元素）拉成一维后的索引值在原本维度（或指定新维度）中对应的索引</span></span><br><span class="line"><span class="built_in">print</span>(np.unravel_index(<span class="number">100</span>,(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>)))</span><br><span class="line"><span class="comment"># (1, 5, 4)</span></span><br></pre></td></tr></table></figure></p><p>21 使用tile功能创建一个 8x8 的棋盘矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.tile() 把数组沿各个方向复制</span></span><br><span class="line">A = np.tile([[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]],(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0 1 0 1 0 1 0 1]</span></span><br><span class="line"><span class="comment">#  [1 0 1 0 1 0 1 0]</span></span><br><span class="line"><span class="comment">#  [0 1 0 1 0 1 0 1]</span></span><br><span class="line"><span class="comment">#  [1 0 1 0 1 0 1 0]</span></span><br><span class="line"><span class="comment">#  [0 1 0 1 0 1 0 1]</span></span><br><span class="line"><span class="comment">#  [1 0 1 0 1 0 1 0]</span></span><br><span class="line"><span class="comment">#  [0 1 0 1 0 1 0 1]</span></span><br><span class="line"><span class="comment">#  [1 0 1 0 1 0 1 0]]</span></span><br></pre></td></tr></table></figure></p><p>22 对 5x5 随机矩阵进行归一化处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归一化，消除指标指标之间的量纲影响</span></span><br><span class="line">A = np.random.random((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0.92685566 0.39959318 0.3216881  0.78607669 0.16330114]</span></span><br><span class="line"><span class="comment">#  [0.23358891 0.20173894 0.84570086 0.28074804 0.61127835]</span></span><br><span class="line"><span class="comment">#  [0.46738838 0.98496397 0.70750835 0.85889864 0.28920651]</span></span><br><span class="line"><span class="comment">#  [0.11662991 0.37791573 0.21508322 0.06199924 0.52202826]</span></span><br><span class="line"><span class="comment">#  [0.8160796  0.48271711 0.75723249 0.78233383 0.43627365]]</span></span><br><span class="line"><span class="built_in">print</span>(np.std(A))</span><br><span class="line"><span class="comment"># 0.22703384104018048</span></span><br><span class="line">A = (A-np.mean(A))/np.std(A)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[ 0.99714238  0.68295313  1.15975373  0.49175751  0.16118442]</span></span><br><span class="line"><span class="comment">#  [-0.29521244  0.6671127  -1.4414722   1.02782654 -0.62601601]</span></span><br><span class="line"><span class="comment">#  [-1.65080791  0.20360113  0.18228082 -0.68766934 -1.6732486 ]</span></span><br><span class="line"><span class="comment">#  [ 0.98050326  0.83047499  1.35795965  0.49417816  0.3231739 ]</span></span><br><span class="line"><span class="comment">#  [ 0.14973292 -0.5481092  -1.07215511  0.72507876 -2.44002318]]</span></span><br></pre></td></tr></table></figure></p><p>24 5x3 矩阵乘以 3x2 矩阵（实矩阵乘积）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.dot(np.ones((<span class="number">5</span>,<span class="number">3</span>)),np.ones((<span class="number">3</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[3. 3. 3.]</span></span><br><span class="line"><span class="comment">#  [3. 3. 3.]</span></span><br><span class="line"><span class="comment">#  [3. 3. 3.]</span></span><br><span class="line"><span class="comment">#  [3. 3. 3.]</span></span><br><span class="line"><span class="comment">#  [3. 3. 3.]]</span></span><br></pre></td></tr></table></figure><br>25 给定一个一维数组，对于所有介于3和8之间的元素取反。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">0</span>,<span class="number">11</span>)</span><br><span class="line"><span class="comment"># A = np.where( (A&gt;=3) &amp; (A&lt;=8),-A,A)</span></span><br><span class="line">A[(<span class="number">3</span>&lt;=A)&amp;(A&lt;=<span class="number">8</span>)]*=-<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><br>26 下列程序的输出是什么？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="comment"># sum[0,1,2,3,4] 再加上1</span></span><br><span class="line"><span class="comment"># 9</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(<span class="built_in">range</span>(<span class="number">5</span>),-<span class="number">1</span>))</span><br><span class="line"><span class="comment"># numpy中的sum函数，第二个参数，求和的轴，-1表示沿着最后一个轴进行求和</span></span><br></pre></td></tr></table></figure><br>30 如何查找两个数组的公共值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.intersect1d()，返回两个数组的交集</span></span><br><span class="line">A1 =np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(A1)</span><br><span class="line"><span class="comment"># [7 0 9 2 2 6 5 4 8 2]</span></span><br><span class="line">A2 =np.random.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(A2)</span><br><span class="line"><span class="comment"># [7 9 9 9 3 4 1 5 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(np.intersect1d(A1,A2))</span><br><span class="line"><span class="comment"># [4 5 7 9]</span></span><br></pre></td></tr></table></figure><br>33 如何获取昨天、今天和明天的日期？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yesterday = np.datetime64(<span class="string">&#x27;today&#x27;</span>,<span class="string">&#x27;D&#x27;</span>) -np.timedelta64(<span class="number">1</span>,<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">today = np.datetime64(<span class="string">&#x27;today&#x27;</span>,<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">tomorrow = np.datetime64(<span class="string">&#x27;today&#x27;</span>,<span class="string">&#x27;D&#x27;</span>)+np.timedelta64(<span class="number">1</span>,<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(yesterday,today,tomorrow)</span><br><span class="line"><span class="comment"># 2024-04-29 2024-04-30 2024-05-01</span></span><br></pre></td></tr></table></figure><br>34 如何获取与 2016 年 7 月相对应的所有日期？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="string">&#x27;2016-07&#x27;</span>,<span class="string">&#x27;2016-08&#x27;</span>,dtype=<span class="string">&#x27;datetime64[D]&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [&#x27;2016-07-01&#x27; &#x27;2016-07-02&#x27; &#x27;2016-07-03&#x27; &#x27;2016-07-04&#x27; &#x27;2016-07-05&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2016-07-06&#x27; &#x27;2016-07-07&#x27; &#x27;2016-07-08&#x27; &#x27;2016-07-09&#x27; &#x27;2016-07-10&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2016-07-11&#x27; &#x27;2016-07-12&#x27; &#x27;2016-07-13&#x27; &#x27;2016-07-14&#x27; &#x27;2016-07-15&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2016-07-16&#x27; &#x27;2016-07-17&#x27; &#x27;2016-07-18&#x27; &#x27;2016-07-19&#x27; &#x27;2016-07-20&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2016-07-21&#x27; &#x27;2016-07-22&#x27; &#x27;2016-07-23&#x27; &#x27;2016-07-24&#x27; &#x27;2016-07-25&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2016-07-26&#x27; &#x27;2016-07-27&#x27; &#x27;2016-07-28&#x27; &#x27;2016-07-29&#x27; &#x27;2016-07-30&#x27;</span></span><br><span class="line"><span class="comment">#  &#x27;2016-07-31&#x27;]</span></span><br></pre></td></tr></table></figure><br>35 如何就地计算 ((A+B)*(-A/2)) （无需复制）？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A = np.ones(<span class="number">3</span>)*<span class="number">1</span></span><br><span class="line">B = np.ones(<span class="number">3</span>)*<span class="number">2</span></span><br><span class="line">C = np.ones(<span class="number">3</span>)*<span class="number">3</span></span><br><span class="line">np.add(A,B,out=B)</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line"><span class="comment"># [3. 3. 3.]</span></span><br><span class="line">np.divide(A,<span class="number">2</span>,out=A)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.5 0.5 0.5]</span></span><br><span class="line">np.negative(A,out=A)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [-0.5 -0.5 -0.5]</span></span><br><span class="line">np.multiply(B,A,out=A)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [-1.5 -1.5 -1.5]</span></span><br></pre></td></tr></table></figure><br>36 用 5 种不同方法提取随机数组的整数部分<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># np.trunc(A) 函数会返回一个新的数组，其中包含与输入数组 A 中每个元素相同的值，但是将这些值截断为整数部分。</span></span><br><span class="line">A = np.random.uniform(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.18262916 6.77946139 9.20108589 6.79791964 6.0110954  4.34951841</span></span><br><span class="line"><span class="comment">#  9.08761797 1.50607495 2.64240807 8.54159946]</span></span><br><span class="line"><span class="built_in">print</span>(A-A%<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.floor(A))</span><br><span class="line"><span class="built_in">print</span>(np.ceil(A)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(np.trunc(A))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0. 6. 9. 6. 6. 4. 9. 1. 2. 8.]</span></span><br><span class="line"><span class="built_in">print</span>(A.astype(<span class="built_in">int</span>))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0 6 9 6 6 4 9 1 2 8]</span></span><br></pre></td></tr></table></figure><br>37 创建一个 5x5 矩阵，行值范围为 0 至 4<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A =np.zeros((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">A += np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [[0. 1. 2. 3. 4.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 2. 3. 4.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 2. 3. 4.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 2. 3. 4.]</span></span><br><span class="line"><span class="comment">#  [0. 1. 2. 3. 4.]]</span></span><br></pre></td></tr></table></figure><br>38 考虑一个generate函数，生成 10 个整数，并用它建立一个数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line">A = np.fromiter(generate(),dtype=<span class="built_in">float</span>,count=-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]</span></span><br></pre></td></tr></table></figure><br>39 创建一个大小为 10 的向量，其值范围为 0 至 1，开区间<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">11</span>,endpoint=<span class="literal">False</span>)[<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.09090909 0.18181818 0.27272727 0.36363636 0.45454545 0.54545455</span></span><br><span class="line"><span class="comment">#  0.63636364 0.72727273 0.81818182 0.90909091]</span></span><br></pre></td></tr></table></figure><br>40 创建大小为 10 的随机向量并排序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.random(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.88926125 0.27836093 0.85296294 0.33284357 0.79563254 0.94715995</span></span><br><span class="line"><span class="comment">#  0.49433492 0.36834956 0.80960441 0.97186405]</span></span><br><span class="line">A.sort()</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.27836093 0.33284357 0.36834956 0.49433492 0.79563254 0.80960441</span></span><br><span class="line"><span class="comment">#  0.85296294 0.88926125 0.94715995 0.97186405]</span></span><br></pre></td></tr></table></figure><br>42 考虑两个随机数组 A 和 B，检查它们是否相等<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.random(<span class="number">5</span>)</span><br><span class="line">B = np.random.random(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(A,B)</span><br><span class="line"><span class="comment"># [0.10499542 0.75789007 0.22211449 0.76080379 0.56697285]</span></span><br><span class="line"><span class="comment"># [0.60510406 0.56727591 0.58049127 0.75298729 0.66239856]</span></span><br><span class="line"><span class="built_in">print</span>(np.array_equal(A,B))</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure><br>45 创建大小为 10 的随机向量，并用 0 替换最大值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = np.random.random(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.46548663 0.26101477 0.98163071 0.03317805 0.44601752]</span></span><br><span class="line">index = np.argmax(A)</span><br><span class="line">A[index]=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line"><span class="comment"># [0.46548663 0.26101477 0.         0.03317805 0.44601752]</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘 数据库</title>
      <link href="/2024/04/11/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/04/11/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h2><p>特点：<br>开源的关系型数据库<br>将整个数据库的表，索引，数据都存储在一个单一的.db文件中<br>不需要网络配置和管理<br>没有账户和密码<br>数据库访问依赖于文件所在的操作系统<br>和数据库建立连接<br> 执行sql语句，接收返回值<br> 关闭数据库连接<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;trade.db&#x27;</span>)</span><br><span class="line">SQL =<span class="string">&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;</span></span><br><span class="line">conn.execute(SQL)</span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></p><h2 id="SQLite数据库操作"><a href="#SQLite数据库操作" class="headerlink" title="SQLite数据库操作"></a>SQLite数据库操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL= <span class="string">&#x27;&#x27;&#x27; drop table if exists stock&#x27;&#x27;&#x27;</span></span><br><span class="line">conn.execute(SQL)</span><br><span class="line">conn.commit()</span><br><span class="line">SQL=<span class="string">&#x27;&#x27;&#x27;create table stock (code char(8) not null,</span></span><br><span class="line"><span class="string">name char(10),price float, primary key(&quot;code&quot;))&#x27;&#x27;&#x27;</span></span><br><span class="line">conn.execute(SQL)</span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><h3 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;select title,link from info where title like &quot;东方%&quot; &#x27;&#x27;&#x27;</span></span><br><span class="line">alist = <span class="built_in">list</span>(conn.execute(SQL))</span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL =<span class="string">&#x27;&#x27;&#x27;insert into stock(code,name,price)</span></span><br><span class="line"><span class="string">values(&#x27;2349&#x27;,&#x27;精华制药&#x27;,10.49)&#x27;&#x27;&#x27;</span></span><br><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;insert into stock(code,name,price) values(%d,&#x27;%s&#x27;,%f)&#x27;&#x27;&#x27;</span> %(code,name,</span><br><span class="line">price)</span><br><span class="line">conn.execute(SQL)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">info = <span class="built_in">tuple</span>(into)</span><br><span class="line">result.append(info)</span><br><span class="line">result = <span class="built_in">list</span>(<span class="built_in">set</span>(result))</span><br><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;insert into stock(code,name,price)values(?,?,?)&#x27;&#x27;&#x27;</span></span><br><span class="line">conn.exexcutemany(SQL,result)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;update stock set price=11.5 where code = &#x27;2349&#x27; &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;delete from stock where code =&#x27;2349&#x27; &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;drop table stock&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="数据库操作实例"><a href="#数据库操作实例" class="headerlink" title="数据库操作实例"></a>数据库操作实例</h2><p>实例1<br>爬虫并存入数据库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3,re,requests</span><br><span class="line">url = <span class="string">&#x27;https://www.eastmoney.com/&#x27;</span></span><br><span class="line">html = requests.get(url)</span><br><span class="line">html.encoding = html.apparent_encoding</span><br><span class="line">data = html.text</span><br><span class="line">reg = <span class="string">r&#x27;&lt;a href=&quot;(https://.*?)&quot;.*?&gt;(.*?)&lt;/a&gt;&#x27;</span></span><br><span class="line">urls = re.findall(reg,data)</span><br><span class="line">conn = sqlite3.connect(<span class="string">&quot;web.db&quot;</span>)</span><br><span class="line">SQL = <span class="string">&quot;drop table if exists info&quot;</span></span><br><span class="line">conn.execute(SQL)</span><br><span class="line">conn.commit()</span><br><span class="line">SQL = <span class="string">&#x27;&#x27;&#x27;create table info(code integer not null,link char(30),title char(30),primary key(&#x27;code&#x27;))&#x27;&#x27;&#x27;</span></span><br><span class="line">conn.execute(SQL)</span><br><span class="line">conn.commit()</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    SQL =<span class="string">&#x27;&#x27;&#x27;insert into info(code,link,title) values(%d,&#x27;%s&#x27;,&#x27;%s&#x27;)&#x27;&#x27;&#x27;</span>%(count,url[<span class="number">0</span>],url[<span class="number">1</span>])</span><br><span class="line">    conn.execute(SQL)</span><br><span class="line">    conn.commit()</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><br>实例2 百度多公司多页面爬取<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">baidu</span>(<span class="params">company,page</span>):</span><br><span class="line">    num = page*<span class="number">10</span></span><br><span class="line">    url = <span class="string">&quot;http://www.baidu.com/s?tn=news&amp;rtt=4&amp;wd=&quot;</span>+company+<span class="string">&#x27;&amp;pn=&#x27;</span>+<span class="built_in">str</span>(num)</span><br><span class="line">    html = requests.get(url).text</span><br><span class="line">    <span class="comment"># 链接</span></span><br><span class="line">    reg_href =<span class="string">&#x27;&lt;h3 class=&quot;news-title_1YtI1 &quot;&gt;&lt;a href=&quot;(.*?)&quot;&#x27;</span></span><br><span class="line">    href = re.findall(reg_href,html,re.S)</span><br><span class="line">    <span class="comment"># 标题</span></span><br><span class="line">    reg_title =<span class="string">&#x27;&lt;h3 class=&quot;news-title_1YtI1 &quot;&gt;.*?&gt;&lt;!--s-text--&gt;(.*?)&lt;!--/s-text--&gt;&lt;/a&gt;&#x27;</span></span><br><span class="line">    title = re.findall(reg_title,html,re.S)</span><br><span class="line">    reg_date =<span class="string">&#x27;&lt;span class=&quot;c-color-gray2 c-font-normal c-gap-right-xsmall&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;</span></span><br><span class="line">    date = re.findall(reg_date,html,re.S)</span><br><span class="line">    reg_src = <span class="string">&#x27;&lt;span class=&quot;c-color-gray&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;</span></span><br><span class="line">    src = re.findall(reg_src,html,re.S)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(date)):</span><br><span class="line">        title[i]=title[i].strip()</span><br><span class="line">        title[i] = re.sub(<span class="string">&#x27;&lt;.*?&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,title[i])</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;小时&#x27;</span><span class="keyword">in</span> date[i]) <span class="keyword">or</span> (<span class="string">&#x27;分钟&#x27;</span><span class="keyword">in</span> date[i]):</span><br><span class="line">            date[i]=time.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.&#x27;</span>+title[i]+<span class="string">&#x27;(&#x27;</span>+date[i]+src[i]+<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(href[i])</span><br><span class="line">companys = [<span class="string">&#x27;阿里巴巴&#x27;</span>, <span class="string">&#x27;万科集团&#x27;</span>, <span class="string">&#x27;百度集团&#x27;</span>, <span class="string">&#x27;腾讯&#x27;</span>, <span class="string">&#x27;京东&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> com <span class="keyword">in</span> companys:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        baidu(com,i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;爬取&quot;</span>+com+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&quot;页成功&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>错误处理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">&lt;语句块<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">except</span> &lt;异常类型<span class="number">1</span>&gt;:</span><br><span class="line">&lt;语句块<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">&lt;语句块<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">&lt;句块<span class="number">4</span>&gt;</span><br><span class="line"><span class="comment"># finally，无论有没有报错都执行，</span></span><br><span class="line"><span class="comment"># except可以多个</span></span><br></pre></td></tr></table></figure><br>案例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    filename = <span class="built_in">input</span>(<span class="string">&quot;please input filename:&quot;</span>)</span><br><span class="line">    fobj = <span class="built_in">open</span>(filename,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fobj:</span><br><span class="line">        line = line.strip()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;没有这个文件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    fobj.close()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;程序执行完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">companys = [<span class="string">&#x27;阿里巴巴&#x27;</span>, <span class="string">&#x27;万科集团&#x27;</span>, <span class="string">&#x27;腾讯&#x27;</span>, <span class="string">&#x27;京东&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> companys:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">baidu(each,i)</span><br><span class="line"><span class="built_in">print</span>(each + <span class="string">&#x27;第&#x27;</span> + <span class="built_in">str</span>(i+<span class="number">1</span>) + <span class="string">&#x27;页爬取成功&#x27;</span>)</span><br><span class="line">time. sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(each+<span class="string">&#x27;爬虫失败！ &#x27;</span>))</span><br></pre></td></tr></table></figure></p><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p>关系型数据库，在WEB方面十分流行<br>连接<br>1 创建connection<br>2 获取cursor<br>3 执行SQL语句<br>4 关闭cursor<br>5 关闭connection</p><h2 id="MySQL数据库操作"><a href="#MySQL数据库操作" class="headerlink" title="MySQL数据库操作"></a>MySQL数据库操作</h2><h3 id="MySQL创建表"><a href="#MySQL创建表" class="headerlink" title="MySQL创建表"></a>MySQL创建表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">conn = pymysql.connect(host=<span class="string">&quot;localhost&quot;</span>,user=<span class="string">&quot;root&quot;</span>,password=<span class="string">&quot;1234&quot;</span>,</span><br><span class="line">                       database=<span class="string">&quot;pymysql&quot;</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line">sql = <span class="string">&quot;drop table if exists staff&quot;</span></span><br><span class="line">cur.execute(sql)</span><br><span class="line">sql = <span class="string">&#x27;&#x27;&#x27;create table staff(number char(10) primary key,</span></span><br><span class="line"><span class="string">                            name char(20),</span></span><br><span class="line"><span class="string">                            age int,</span></span><br><span class="line"><span class="string">                            sex char(1),</span></span><br><span class="line"><span class="string">                            salary float)&#x27;&#x27;&#x27;</span></span><br><span class="line">cur.execute(sql)</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h3 id="MySQL中插入数据"><a href="#MySQL中插入数据" class="headerlink" title="MySQL中插入数据"></a>MySQL中插入数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MySQL中插入数据</span></span><br><span class="line">sql = <span class="string">&#x27;&#x27;&#x27;insert into staff(number,name,age,sex,salary)</span></span><br><span class="line"><span class="string">        values(&#x27;1001&#x27;,&#x27;张三&#x27;,28,&#x27;M&#x27;,7078.5)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    conn.rollback()</span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入多条数据</span></span><br><span class="line">aList=[(<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;Mike&quot;</span>,<span class="number">35</span>,<span class="string">&quot;M&quot;</span>,<span class="number">10000</span>),(<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;Jack&quot;</span>,<span class="number">45</span>,<span class="string">&quot;F&quot;</span>,<span class="number">12000</span>)]</span><br><span class="line">sql=<span class="string">&#x27;&#x27;&#x27;insert into staff(number,name,age,sex,salary)</span></span><br><span class="line"><span class="string">        values(%s,%s,%s,%s,%s)&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.executemany(sql,aList)</span><br><span class="line">    conn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    conn.rollback()</span><br></pre></td></tr></table></figure><h3 id="MySQL查找"><a href="#MySQL查找" class="headerlink" title="MySQL查找"></a>MySQL查找</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cond = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入工资:&quot;</span>))</span><br><span class="line">sql = <span class="string">&#x27;&#x27;&#x27;select * from staff where salary &gt;%f&#x27;&#x27;&#x27;</span>%cond</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    res = cur.fetchall() <span class="comment"># 获取所有记录列表</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> res:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;number=%s,name=%s,age=%d,sex=%s,salary=%f&quot;</span> % \</span><br><span class="line">              (row[<span class="number">0</span>], row[<span class="number">1</span>], row[<span class="number">2</span>], row[<span class="number">3</span>], row[<span class="number">4</span>]))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;error&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="MySQL更新"><a href="#MySQL更新" class="headerlink" title="MySQL更新"></a>MySQL更新</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sql = <span class="string">&quot;update staff set age = age + 10 where sex = &#x27;%c&#x27; &quot;</span>%<span class="string">&#x27;M&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    conn.rollback()</span><br></pre></td></tr></table></figure><h3 id="MySQL删除"><a href="#MySQL删除" class="headerlink" title="MySQL删除"></a>MySQL删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sql =<span class="string">&quot;delete from staff where age&gt;&#x27;%d&#x27;&quot;</span>%<span class="number">30</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    conn.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    conn.rollback()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2024/04/10/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/04/10/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h2><p>可以使用<a href="https://markdown.com.cn/editor/">在线编辑器</a>，边学边应用，同时Markdown可以内嵌HTML标签</p><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#  表示h1</span></span><br><span class="line"><span class="section">## 表示h2，以此类推，最多6个，即h1~h6</span></span><br><span class="line"></span><br><span class="line">可选语法</span><br><span class="line">在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题</span><br><span class="line"><span class="section">h1</span></span><br><span class="line"><span class="section">========</span></span><br><span class="line"></span><br><span class="line"><span class="section">h2</span></span><br><span class="line"><span class="section">--------</span></span><br><span class="line"></span><br><span class="line">最佳实践</span><br><span class="line"><span class="section"># 与标题之间进行间隔</span></span><br></pre></td></tr></table></figure><h2 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用空白行将一行或多行文本进行分割，每一部分作为一个段落</span><br><span class="line">段落1，你好</span><br><span class="line"></span><br><span class="line">段落2，hello</span><br><span class="line"></span><br><span class="line">最佳实践</span><br><span class="line">不用空格和制表符来缩进段落</span><br></pre></td></tr></table></figure><h2 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行<span class="language-xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">粗体 使用<span class="strong">**bold text**</span>或者<span class="strong">__bold text__</span></span><br><span class="line">如果要在单词的中间部分加粗，使用love<span class="strong">**is**</span>bold而不是love<span class="strong">__is__</span>bold</span><br><span class="line"></span><br><span class="line">斜体 使用<span class="emphasis">*italic*</span>,或者<span class="emphasis">_italic_</span></span><br><span class="line"></span><br><span class="line">最佳实践，</span><br><span class="line">同时使用斜体和粗体</span><br><span class="line">在单词或短语的前后各添加三个星号或下划线，<span class="strong">**<span class="emphasis">*bold italic*</span>**</span></span><br></pre></td></tr></table></figure><h2 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在段落前添加&gt; 符号来创建块引用</span><br><span class="line"><span class="quote">&gt; 块应用实例</span></span><br><span class="line"></span><br><span class="line">多个段落的块引用</span><br><span class="line"><span class="quote">&gt; 块应用实例1</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; 块应用实例2</span></span><br><span class="line"></span><br><span class="line">嵌套块引用</span><br><span class="line">在要嵌套的段落前添加一个&gt;&gt; 符号</span><br><span class="line"><span class="quote">&gt; 块应用实例1</span></span><br><span class="line"><span class="quote">&gt; 块应用实例2</span></span><br><span class="line">&gt;&gt; 块应用实例3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">带有其他元素的块引用</span><br><span class="line"><span class="quote">&gt; ### 标题h3</span></span><br><span class="line"><span class="quote">&gt; - 实例li</span></span><br><span class="line"><span class="quote">&gt; - 实例li2</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt;  <span class="emphasis">*italic*</span> is <span class="strong">**bold**</span></span></span><br></pre></td></tr></table></figure><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">有序列表</span><br><span class="line">创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。</span><br><span class="line"><span class="bullet">1.</span> First item</span><br><span class="line"><span class="bullet">2.</span> Second item</span><br><span class="line"><span class="bullet">3.</span> Third item</span><br><span class="line"></span><br><span class="line">无序列表</span><br><span class="line">创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (<span class="emphasis">*) 或加号 (+)</span></span><br><span class="line"><span class="emphasis">- First item</span></span><br><span class="line"><span class="emphasis">- Second item</span></span><br><span class="line"><span class="emphasis">- Third item</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">缩进一个或多个列表项可创建嵌套列表。</span></span><br><span class="line"><span class="emphasis">- First item</span></span><br><span class="line"><span class="emphasis">- Second item</span></span><br><span class="line"><span class="emphasis">- Third item</span></span><br><span class="line"><span class="emphasis">    - Indented item</span></span><br><span class="line"><span class="emphasis">    - Indented item</span></span><br><span class="line"><span class="emphasis">- Fourth ite</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">在列表中嵌套其他元素</span></span><br><span class="line"><span class="emphasis">在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符</span></span><br><span class="line"><span class="emphasis">- First item</span></span><br><span class="line"><span class="emphasis">  </span></span><br><span class="line"><span class="emphasis">添加一个段落</span></span><br><span class="line"><span class="emphasis">&gt; 引用块</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">- Second item</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">代码块</span></span><br><span class="line"><span class="emphasis">代码块通常采用四个空格或一个制表符缩进。当它们被放在列表中时，请将它们缩进八个空格或两个制表符。</span></span><br><span class="line"><span class="emphasis">1.  First item</span></span><br><span class="line"><span class="emphasis">2.  code</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">        <span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">          <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">            <span class="language-xml"><span class="tag">&lt;<span class="name">title</span>&gt;</span></span>Test<span class="language-xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis">          <span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3.  Second item</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">图片</span></span><br><span class="line"><span class="emphasis">1.  Open the file containing the Linux mascot.</span></span><br><span class="line"><span class="emphasis">2.  Marvel at its beauty.</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">    ![<span class="string">Tux, the Linux mascot</span>](<span class="link">/assets/images/tux.png</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">3.  Close the file.</span></span><br></pre></td></tr></table></figure><h2 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">将单词或短语表示为代码，请将其包裹在反引号 (`) 中。</span><br><span class="line">请输入<span class="code">`pip install`</span></span><br><span class="line"></span><br><span class="line">如果要表示为代码部分包含反引号，将代码包裹在双反引号(``)中。</span><br><span class="line"><span class="code">``请输入`</span>pip install<span class="code">` `</span>`</span><br><span class="line"></span><br><span class="line">代码块</span><br><span class="line">要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</span><br><span class="line"><span class="code">    &lt;html&gt;</span></span><br><span class="line"><span class="code">      &lt;head&gt;</span></span><br><span class="line"><span class="code">      &lt;/head&gt;</span></span><br><span class="line"><span class="code">    &lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h2 id="分割线语法"><a href="#分割线语法" class="headerlink" title="分割线语法"></a>分割线语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建分隔线，请在单独一行上使用三个或多个星号 (<span class="strong">**<span class="emphasis">*)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">最佳实践，在分割线的前后均添加空白行</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">---</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br></pre></td></tr></table></figure><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">链接文本放在中括号内，链接地址放在后面的括号中，链接title可选</span><br><span class="line">超链接Markdown语法代码：[<span class="string">超链接显示名</span>](<span class="link">超链接地址 &quot;超链接title&quot;</span>)</span><br><span class="line"></span><br><span class="line">链接title是当鼠标悬停在链接上时会出现的文字</span><br><span class="line"></span><br><span class="line">网址和Email地址</span><br><span class="line">使用尖括号可以很方便地把URL或者email地址变成可点击的链接</span><br><span class="line"><span class="language-xml">&lt;https://markdown.com.cn&gt;</span></span><br><span class="line"><span class="language-xml">&lt;fake@example.com&gt;</span></span><br><span class="line"></span><br><span class="line">链接语法可搭配其他语法</span><br><span class="line">the <span class="strong">**[<span class="string">EFF</span>](<span class="link">https://eff.org</span>)**</span>.</span><br><span class="line">the <span class="emphasis">*[<span class="string">Markdown Guide</span>](<span class="link">https://www.markdownguide.org</span>)*</span>.</span><br><span class="line"> on [<span class="string">`code`</span>](<span class="link">https://tangwan16.cn</span>)</span><br><span class="line"></span><br><span class="line"> 引用类型链接</span><br><span class="line">  引用类型链接的第一部分 </span><br><span class="line"><span class="code">[显示为链接的文本][1]，后一个[]指向存储在文档其他位置的链接，可以是字母，数字</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">引用类型链接的第二部分，可以放在文档的任何位置</span></span><br><span class="line"><span class="code">[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</span></span><br></pre></td></tr></table></figure><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本</span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">图片链接 &quot;图片鼠标悬浮名&quot;</span>)</span><br><span class="line"></span><br><span class="line">链接图片，给图片增加链接</span><br><span class="line">[<span class="string">![沙漠中的岩石图片</span>](<span class="link">/assets/img/shiprock.jpg &quot;Shiprock&quot;</span>)](<span class="link">https://markdown.com.cn</span>)</span><br></pre></td></tr></table></figure><h2 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>使用三个或多个连字符（—-）创建每列的标题，并使用管道（|）分隔每列。您可以选择在表的任一端添加管道。可以使用<a href="https://www.tablesgenerator.com/markdown_tables">Markdown表格生成器</a> 生成表格<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br><span class="line"></span><br><span class="line">单元格宽度可以变化，下面的代码与上面相同</span><br><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对其方式设置</span><br><span class="line">分别为左对齐，居中对其，右对齐</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br></pre></td></tr></table></figure></p><h2 id="围栏代码块"><a href="#围栏代码块" class="headerlink" title="围栏代码块"></a>围栏代码块</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">除了将行缩进四个空格或一个制表符来创建代码块，可以用<span class="code">``` ```</span>将代码块包裹</span><br><span class="line"><span class="code">```使用的语言名</span></span><br><span class="line"><span class="code">代码</span></span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Smith&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">25</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## 脚注</span><br><span class="line">当创建脚注时，带有脚注的上标数字会出现在您添加脚注参考的位置，以单击链接以跳至页面底部的脚注内容。脚注内容可以放在文章任何位置</span><br><span class="line">```markdown</span><br><span class="line">Here&#x27;s a simple footnote,[^1]</span><br><span class="line"></span><br><span class="line">[^1]: This is the first footnote.</span><br></pre></td></tr></table></figure></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>在单词中心放置一条水平线来删除单词<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在要删除内容前后使用两个波浪号~~</span><br><span class="line">~~世界是平坦的。~~ 我们现在知道世界是圆的。</span><br></pre></td></tr></table></figure></p><h2 id="任务列表语法"><a href="#任务列表语法" class="headerlink" title="任务列表语法"></a>任务列表语法</h2><p>任务列表使您可以创建带有复选框的项目列表。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。</span><br><span class="line"><span class="bullet">-</span> [x] Write the press release</span><br><span class="line"><span class="bullet">-</span> [ ] Update the website</span><br><span class="line"><span class="bullet">-</span> [ ] Contact the media</span><br></pre></td></tr></table></figure></p><h2 id="自动网址链接"><a href="#自动网址链接" class="headerlink" title="自动网址链接"></a>自动网址链接</h2><p>会自动将URL转换为链接，如果要禁止自动URL链接，将URL表示为带反引号的代码来删除该链接。</p>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘 数据获取</title>
      <link href="/2024/04/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
      <url>/2024/04/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-requests"><a href="#1-requests" class="headerlink" title="1 requests"></a>1 requests</h2><h3 id="1-1requests-属性"><a href="#1-1requests-属性" class="headerlink" title="1.1requests.属性"></a>1.1requests.属性</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r = requests.get(url)</span><br><span class="line"><span class="comment"># 网页响应内容的字符串形式</span></span><br><span class="line">r.text</span><br><span class="line"><span class="comment"># 网页响应内容的二进制形式</span></span><br><span class="line">r.content</span><br><span class="line"><span class="comment"># 猜测网页响应内容的编码方式</span></span><br><span class="line">r.encoding</span><br><span class="line"><span class="comment"># 根据网页内容分析出内容的编码方式</span></span><br><span class="line">r.apparent_encoding</span><br><span class="line"><span class="comment"># 状态码 200代表连接成功，404表示失败</span></span><br><span class="line">r.status_code</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-2-requests-实例"><a href="#1-2-requests-实例" class="headerlink" title="1.2 requests 实例"></a>1.2 requests 实例</h3><p>实例1 爬取单张图片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;https://fileshare.tangwan16.cn/image/about.jpg&quot;</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line"><span class="comment"># request.get(url,headers=&#x27;&#x27;,timeout=10)</span></span><br><span class="line">data = r.content</span><br><span class="line">fobj = <span class="built_in">open</span>(<span class="string">&quot;result.jpg&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">fobj.write(data)</span><br><span class="line">fobj.close()</span><br></pre></td></tr></table></figure><br>实例2 爬取网页<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://www.people.com.cn&quot;</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">data = r.text</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;paper.txt&quot;</span>, <span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fobj:</span><br><span class="line">    fobj.write(data)</span><br></pre></td></tr></table></figure></p><h2 id="2-re"><a href="#2-re" class="headerlink" title="2 re"></a>2 re</h2><h3 id="2-1-re库的内置函数"><a href="#2-1-re库的内置函数" class="headerlink" title="2.1 re库的内置函数"></a>2.1 re库的内置函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">string = <span class="string">&quot;I love it. It loves me.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于从起始位置匹配，若起始位置字符不是匹配内容返回none</span></span><br><span class="line">re.<span class="keyword">match</span>(<span class="string">&quot;it&quot;</span>,string)</span><br><span class="line"><span class="comment"># 搜索整个字符串，返回第一次出现的位置</span></span><br><span class="line">re.search(<span class="string">&quot;it&quot;</span>,string)</span><br><span class="line"><span class="comment"># 以列表形式返回全部能匹配的字符串</span></span><br><span class="line">re.findall(<span class="string">&quot;it&quot;</span>,string)</span><br><span class="line"><span class="comment"># 创建一个正则表达式对象，可以配合正则表达式修饰符使用</span></span><br><span class="line">re.<span class="built_in">compile</span>(<span class="string">&quot;it&quot;</span>，)</span><br></pre></td></tr></table></figure><h3 id="2-2-正则表达式修饰符含义"><a href="#2-2-正则表达式修饰符含义" class="headerlink" title="2.2 正则表达式修饰符含义"></a>2.2 正则表达式修饰符含义</h3><p><img src="https://hexo-tangwan16-pic.oss-cn-shanghai.aliyuncs.com/202405281044289.png" alt=""></p><h3 id="2-3-字符串匹配表"><a href="#2-3-字符串匹配表" class="headerlink" title="2.3 字符串匹配表"></a>2.3 字符串匹配表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配一个数字字符</span></span><br><span class="line">\d </span><br><span class="line"><span class="comment"># 匹配一个字母、数字及下划线字符</span></span><br><span class="line">\W</span><br><span class="line"><span class="comment"># 匹配一个空白字符</span></span><br><span class="line">\s</span><br><span class="line"><span class="comment"># 匹配一个任意字符，换行符除外</span></span><br><span class="line">.</span><br><span class="line"><span class="comment"># 匹配一个换行符</span></span><br><span class="line">\n</span><br><span class="line"><span class="comment"># 匹配一个制表符</span></span><br><span class="line">\t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配前面的字符0次或n次</span></span><br><span class="line">*</span><br><span class="line"><span class="comment"># 匹配前面的字符1次或n次</span></span><br><span class="line">+</span><br><span class="line"><span class="comment"># 匹配前面的字符0次或1次</span></span><br><span class="line">?</span><br><span class="line"><span class="comment"># 匹配括号内表达式，也表示一个组</span></span><br><span class="line">()</span><br><span class="line"><span class="comment"># 匹配m-n个字符</span></span><br><span class="line">&#123;m,n&#125;</span><br><span class="line"><span class="comment"># 表示字符范围,方括号中只能取一个</span></span><br><span class="line">[]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示行开头，^\d表示必须以数字开头 </span></span><br><span class="line">^</span><br><span class="line"><span class="comment"># 表示行结束,\d$表示必须以数字结束</span></span><br><span class="line">$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组合使用实例,匹配以e结尾不超过4个长度的字符</span></span><br><span class="line">re.findall(<span class="string">&quot;\w&#123;1,4&#125;e&quot;</span>,string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取html中src中连接</span></span><br><span class="line">s=<span class="string">&#x27;&#x27;&#x27;&lt;img src=&quot;C:\\XH.jpg&quot; width=&quot;300&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;img src=&quot;C:\\FX.jpg&quot; width=&quot;300&quot;/&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 贪婪模式，尽可能多的匹配字符</span></span><br><span class="line">result5 = re.findall(<span class="string">&#x27;&lt;img src=&quot;(.*)&quot;&#x27;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(result5) [<span class="string">&#x27;C:\\XH.jpg&quot; width=&quot;300&#x27;</span>, <span class="string">&#x27;C:\\FX.jpg&quot; width=&quot;300&#x27;</span>]</span><br><span class="line"><span class="comment"># 非贪婪模式，尽可能少的匹配字符</span></span><br><span class="line">result6 = re.findall(<span class="string">&#x27;&lt;img src=&quot;(.*?)&quot;&#x27;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(result6) [<span class="string">&#x27;C:\\XH.jpg&#x27;</span>, <span class="string">&#x27;C:\\FX.jpg&#x27;</span>]</span><br><span class="line">result7 = re.findall(<span class="string">&#x27;&lt;img src=&quot;(.*?)&quot; width=&quot;(.*?)&quot;&#x27;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(result7) [<span class="string">&#x27;C:\\XH.jpg&#x27;</span>, <span class="string">&#x27;C:\\FX.jpg&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4 实例"></a>2.4 实例</h3><p>实例1 爬取人民网连接和标题<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,requests</span><br><span class="line">url = <span class="string">&quot;http://www.people.com.cn&quot;</span></span><br><span class="line">html = requests.get(url)</span><br><span class="line">html.encoding = html.apparent_encoding</span><br><span class="line">data = html.text</span><br><span class="line"></span><br><span class="line">res = re.findall(<span class="string">&#x27;&lt;li&gt;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot;&gt;(.*?)&lt;/a&gt;&lt;/li&gt;&#x27;</span>,data)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">fobj = <span class="built_in">open</span>(<span class="string">&#x27;people.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> res:</span><br><span class="line">    fobj.write(line[<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+line[<span class="number">1</span>]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fobj.close()</span><br></pre></td></tr></table></figure><br>实例2 爬取新闻图片素材<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re,requests</span><br><span class="line">url = <span class="string">&quot;http://www.people.com.cn&quot;</span></span><br><span class="line">html = requests.get(url)</span><br><span class="line">html.encoding = html.apparent_encoding</span><br><span class="line">data = html.text</span><br><span class="line"></span><br><span class="line">res = re.findall(<span class="string">&#x27;&lt;img src=&quot;(.*?.jpg)&quot;&#x27;</span>,data)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> img <span class="keyword">in</span> res:</span><br><span class="line">    html = requests.get(url+img)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./result/&quot;</span>+<span class="built_in">str</span>(x)+<span class="string">&quot;.jpg&quot;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fobj:</span><br><span class="line">        fobj.write(html.content)</span><br><span class="line">    x+=<span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="3-数据清洗常见方法"><a href="#3-数据清洗常见方法" class="headerlink" title="3 数据清洗常见方法"></a>3 数据清洗常见方法</h2><h3 id="3-1-用strip-函数删除空格及换行符等非相关符号"><a href="#3-1-用strip-函数删除空格及换行符等非相关符号" class="headerlink" title="3.1 用strip()函数删除空格及换行符等非相关符号"></a>3.1 用strip()函数删除空格及换行符等非相关符号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res=<span class="string">&#x27; 华能信托本年实现利润32.05亿元 &#x27;</span></span><br><span class="line">res = res.strip()</span><br><span class="line"><span class="built_in">print</span>(res) 华能信托本年实现利润<span class="number">32.05</span>亿元</span><br></pre></td></tr></table></figure><h3 id="3-2-用split-函数截取需求的内容"><a href="#3-2-用split-函数截取需求的内容" class="headerlink" title="3.2 用split()函数截取需求的内容"></a>3.2 用split()函数截取需求的内容</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date=<span class="string">&#x27;2019-01-20 10:10:10&#x27;</span></span><br><span class="line">date = date.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(date) <span class="number">2019</span>-01-<span class="number">20</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-用sub-函数进行内容替换"><a href="#3-3-用sub-函数进行内容替换" class="headerlink" title="3.3 用sub()函数进行内容替换"></a>3.3 用sub()函数进行内容替换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">title=<span class="string">&#x27;阿里&lt;em&gt;巴巴&lt;/em&gt;人工智能再发力&#x27;</span></span><br><span class="line">title = re.sub(<span class="string">&#x27;&lt;(.*?)&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>,title)</span><br><span class="line"><span class="built_in">print</span>(title) 阿里巴巴人工智能再发力</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Butterfly</title>
      <link href="/2024/03/23/Hexo+Butterfly/"/>
      <url>/2024/03/23/Hexo+Butterfly/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-Butterfly"><a href="#Hexo-Butterfly" class="headerlink" title="Hexo+Butterfly"></a>Hexo+Butterfly</h1>]]></content>
      
      
      <categories>
          
          <category> 建站教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo+Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinia的部署与使用</title>
      <link href="/2024/03/23/pinia/"/>
      <url>/2024/03/23/pinia/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装pinia到项目中"><a href="#1-安装pinia到项目中" class="headerlink" title="1 安装pinia到项目中"></a>1 安装pinia到项目中</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add pinia</span><br><span class="line">或 </span><br><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">const pinia = createPinia()</span><br><span class="line">const app = createApp(App)</span><br><span class="line">app.use(pinia).mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><h2 id="store的定义与使用"><a href="#store的定义与使用" class="headerlink" title="store的定义与使用"></a>store的定义与使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">store/counter.js</span><br><span class="line">defineStore(仓库的唯一标识，()=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line">export const userCounterStore =defineStore(&#x27;counter&#x27;,()=&gt;&#123;</span><br><span class="line">//声明数据state使用ref()</span><br><span class="line">const count =ref(100)</span><br><span class="line">//声明操作数据的方法（普通函数）</span><br><span class="line">const addCount =()=&gt;count.value++</span><br><span class="line">const subCount =()=&gt;count.value--</span><br><span class="line">//声明基于数据派生的计算属性getters使用computed</span><br><span class="line">const doubleCount =computed(()=&gt;count.value*2)</span><br><span class="line">return &#123;</span><br><span class="line">count,</span><br><span class="line">addCount,</span><br><span class="line">subCount,</span><br><span class="line">doubleCount</span><br><span class="line">&#125;</span><br><span class="line">//异步请求</span><br><span class="line">const channels = ref([])</span><br><span class="line">const getList = async ()=&gt;&#123;</span><br><span class="line">const data = await axios.get(&#x27;http://geek.itheima.net/v1_0/channels&#x27;)</span><br><span class="line">channels.value =data.data.data.channels</span><br><span class="line">console.log(channels.value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="数据的解构同时保持数据-storeToRefs"><a href="#数据的解构同时保持数据-storeToRefs" class="headerlink" title="数据的解构同时保持数据 storeToRefs"></a>数据的解构同时保持数据 storeToRefs</h2><p>//响应式丢失，视图不再更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//响应式丢失，视图不再更新</span><br><span class="line">const &#123;count,doubleCount &#125; = counterStore</span><br><span class="line">//保持数据响应式</span><br><span class="line">const &#123;count,doubleCount &#125; =storeToRefs(counterStore)</span><br><span class="line">//函数结构不需要的使用storeToRefs</span><br></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>官方文档：<a href="https://prazdevs.github.io/pinia-plugin-persistedstate/zh/">https://prazdevs.github.io/pinia-plugin-persistedstate/zh/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add pinia-plugin-persistedstate</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createPinia &#125; from &#x27;pinia&#x27;</span><br><span class="line">import piniaPluginPersistedstate from &#x27;pinia-plugin-persistedstate&#x27;</span><br><span class="line"></span><br><span class="line">const pinia = createPinia()</span><br><span class="line">pinia.use(piniaPluginPersistedstate)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export const useCounterStore = defineStore(&#x27;counter&#x27;, () =&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  return &#123;</span><br><span class="line">    count,</span><br><span class="line">    doubleCount,</span><br><span class="line">    increment</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  persist: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">persist: &#123;</span><br><span class="line">  key: &#x27;my-custom-key&#x27;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export const useStore = defineStore(&#x27;store&#x27;, &#123;</span><br><span class="line">  state: () =&gt; (&#123;</span><br><span class="line">    save: &#123;</span><br><span class="line">      me: &#x27;saved&#x27;,</span><br><span class="line">      notMe: &#x27;not-saved&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    saveMeToo: &#x27;saved&#x27;,</span><br><span class="line">  &#125;),</span><br><span class="line">  persist: &#123;</span><br><span class="line">    paths: [&#x27;save.me&#x27;, &#x27;saveMeToo&#x27;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pinia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2024/03/19/springboot/"/>
      <url>/2024/03/19/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h1><p>测试服务器链接git是否成功</p>]]></content>
      
      
      <categories>
          
          <category> 后端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3</title>
      <link href="/2024/03/19/vue3/"/>
      <url>/2024/03/19/vue3/</url>
      
        <content type="html"><![CDATA[<h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1>]]></content>
      
      
      <categories>
          
          <category> 前端学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
